{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 5, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/league.service.ts"],"sourcesContent":["/**\n * League Service for MatchDay\n * \n * Handles league discovery and joining operations with focus on:\n * - League discovery and filtering (read-only, no league creation)\n * - Advanced search and compatibility matching\n * - Join request management for teams within leagues\n * - Player's league membership tracking\n * \n * Optimized for player-centric amateur sports league experience\n */\n\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport {\n  Database,\n  League,\n  Team,\n  LeagueDiscovery,\n  LeagueFilters,\n  ServiceResponse,\n  ServiceError,\n  PaginatedServiceResponse,\n  TeamJoinRequest,\n  JoinRequestStatus,\n  SportType,\n  LeagueType,\n  CacheOptions,\n  RealtimeSubscriptionOptions\n} from '@/lib/types/database.types';\n\nexport interface LeagueCompatibilityScore {\n  leagueId: string;\n  score: number;\n  factors: {\n    skillMatch: number;\n    locationProximity: number;\n    scheduleCompatibility: number;\n    teamAvailability: number;\n    entryAffordability: number;\n  };\n  recommendations: string[];\n}\n\nexport interface TeamAvailability {\n  teamId: string;\n  teamName: string;\n  currentPlayers: number;\n  maxPlayers: number;\n  availableSpots: number;\n  isRecruiting: boolean;\n  requiredPositions: string[];\n  captainContact?: {\n    name: string;\n    id: string;\n  };\n}\n\nexport class LeagueService {\n  private static instance: LeagueService;\n  private supabase: SupabaseClient<Database>;\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n\n  private constructor(supabaseClient: SupabaseClient<Database>) {\n    this.supabase = supabaseClient;\n  }\n\n  static getInstance(supabaseClient?: SupabaseClient<Database>): LeagueService {\n    if (!LeagueService.instance) {\n      if (!supabaseClient) {\n        throw new Error('SupabaseClient required for first initialization');\n      }\n      LeagueService.instance = new LeagueService(supabaseClient);\n    }\n    return LeagueService.instance;\n  }\n\n  /**\n   * Handle service errors consistently\n   */\n  private handleError(error: any, operation: string): ServiceError {\n    console.error(`LeagueService.${operation}:`, {\n      error,\n      code: error?.code,\n      message: error?.message,\n      stack: error?.stack,\n      type: typeof error,\n      keys: Object.keys(error || {})\n    });\n    return {\n      code: error?.code || 'UNKNOWN_ERROR',\n      message: error?.message || 'An unexpected error occurred',\n      details: error.details || error,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Cache management utilities\n   */\n  private getCacheKey(operation: string, params: any): string {\n    return `league_service:${operation}:${JSON.stringify(params)}`;\n  }\n\n  private getFromCache<T>(key: string): T | null {\n    const cached = this.cache.get(key);\n    if (!cached) return null;\n    \n    if (Date.now() - cached.timestamp > cached.ttl * 1000) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return cached.data as T;\n  }\n\n  private setCache<T>(key: string, data: T, ttl = 600): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl\n    });\n  }\n\n  /**\n   * Discover available leagues with advanced filtering\n   */\n  async discoverLeagues(\n    filters: LeagueFilters = {},\n    options: {\n      userId?: string;\n      includeCompatibilityScore?: boolean;\n      limit?: number;\n      offset?: number;\n    } = {}\n  ): Promise<PaginatedServiceResponse<LeagueDiscovery>> {\n    try {\n      const cacheKey = this.getCacheKey('discoverLeagues', { filters, options: { ...options, userId: undefined } });\n      const cached = this.getFromCache<LeagueDiscovery[]>(cacheKey);\n      \n      if (cached && !options.userId) {\n        return { \n          data: cached, \n          error: null, \n          success: true,\n          pagination: {\n            page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n            limit: options.limit || 20,\n            total: cached.length,\n            totalPages: Math.ceil(cached.length / (options.limit || 20)),\n            hasNext: false,\n            hasPrevious: false\n          }\n        };\n      }\n\n      // Build query with filters\n      let query = this.supabase\n        .from('leagues')\n        .select(`\n          *,\n          teams (\n            id,\n            name,\n            team_color,\n            captain_id,\n            max_players,\n            min_players,\n            is_recruiting\n          )\n        `, { count: 'exact' })\n        .eq('is_active', true)\n        .eq('is_public', true);\n\n      if (filters.sportType) {\n        query = query.eq('sport_type', filters.sportType);\n      }\n\n      if (filters.leagueType) {\n        query = query.eq('league_type', filters.leagueType);\n      }\n\n      if (filters.location) {\n        query = query.ilike('location', `%${filters.location}%`);\n      }\n\n      if (filters.entryFeeMax !== undefined) {\n        query = query.lte('entry_fee', filters.entryFeeMax);\n      }\n\n      if (filters.seasonActive) {\n        const now = new Date().toISOString();\n        // Include leagues where season_end is null (ongoing/no end date) OR season_end is in the future\n        query = query.or(`season_end.gte.${now},season_end.is.null`);\n      }\n\n      if (filters.search) {\n        query = query.or(`name.ilike.%${filters.search}%,description.ilike.%${filters.search}%`);\n      }\n\n      const { data: leagues, error, count } = await query\n        .order('created_at', { ascending: false })\n        .range(options.offset || 0, (options.offset || 0) + (options.limit || 20) - 1);\n\n      if (error) throw error;\n\n      // Get user's current memberships if userId provided\n      let userMemberships: string[] = [];\n      if (options.userId) {\n        const { data: memberships } = await this.supabase\n          .from('team_members')\n          .select(`\n            team:teams!inner(league_id)\n          `)\n          .eq('user_id', options.userId)\n          .eq('is_active', true);\n\n        userMemberships = memberships?.map(m => m.team.league_id) || [];\n      }\n\n      // Process leagues into discovery format\n      const discoveryLeagues: LeagueDiscovery[] = await Promise.all(\n        (leagues || []).map(async (league) => {\n          const teams = league.teams || [];\n          const playerCount = await this.getLeaguePlayerCount(league.id);\n          const availableSpots = await this.getLeagueAvailableSpots(league.id);\n          \n          let compatibilityScore;\n          if (options.includeCompatibilityScore && options.userId) {\n            const compatibility = await this.calculateCompatibilityScore(league.id, options.userId);\n            compatibilityScore = compatibility.data?.score;\n          }\n\n          return {\n            ...league,\n            teams,\n            teamCount: teams.length,\n            playerCount: playerCount.data || 0,\n            availableSpots: availableSpots.data || 0,\n            isUserMember: userMemberships.includes(league.id),\n            compatibilityScore\n          };\n        })\n      );\n\n      // Sort by compatibility score if available\n      if (options.includeCompatibilityScore) {\n        discoveryLeagues.sort((a, b) => (b.compatibilityScore || 0) - (a.compatibilityScore || 0));\n      }\n\n      // Cache results (without user-specific data)\n      if (!options.userId) {\n        this.setCache(cacheKey, discoveryLeagues, 600);\n      }\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n        limit: options.limit || 20,\n        total: count || 0,\n        totalPages: Math.ceil((count || 0) / (options.limit || 20)),\n        hasNext: ((options.offset || 0) + (options.limit || 20)) < (count || 0),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: discoveryLeagues,\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'discoverLeagues'),\n        success: false,\n        pagination: {\n          page: 1,\n          limit: options.limit || 20,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrevious: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Get detailed league information\n   */\n  async getLeagueDetails(\n    leagueId: string,\n    options: { userId?: string } = {}\n  ): Promise<ServiceResponse<LeagueDiscovery>> {\n    try {\n      console.log('LeagueService.getLeagueDetails - Starting:', { leagueId, options });\n      const cacheKey = this.getCacheKey('getLeagueDetails', { leagueId });\n      const cached = this.getFromCache<LeagueDiscovery>(cacheKey);\n      \n      if (cached && !options.userId) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Use API endpoint instead of direct Supabase query to avoid RLS issues\n      let league;\n      try {\n        const response = await fetch(`/api/leagues/${leagueId}`);\n        const result = await response.json();\n        \n        if (!response.ok || !result.success) {\n          if (response.status === 404) {\n            return {\n              data: null,\n              error: { code: 'LEAGUE_NOT_FOUND', message: 'League not found', timestamp: new Date().toISOString() },\n              success: false\n            };\n          }\n          throw new Error(result.error || `HTTP ${response.status}: ${response.statusText}`);\n        }\n        \n        league = result.data;\n      } catch (error) {\n        console.error('LeagueService.getLeagueDetails - API request error:', error);\n        return {\n          data: null,\n          error: { \n            code: 'API_ERROR', \n            message: error instanceof Error ? error.message : 'Failed to fetch league details via API', \n            timestamp: new Date().toISOString() \n          },\n          success: false\n        };\n      }\n\n      // Process the league data to include statistics\n      console.log('LeagueService.getLeagueDetails - Processing league:', { leagueId, hasTeams: !!league.teams, teamsCount: league.teams?.length });\n      const teams = league.teams || [];\n      const teamCount = teams.length;\n      \n      // Calculate total active players across all teams\n      const playerCount = teams.reduce((total, team) => {\n        const activeMembers = team.team_members?.filter(member => member.is_active) || [];\n        return total + activeMembers.length;\n      }, 0);\n\n      // Calculate available spots across all teams\n      const availableSpots = teams.reduce((total, team) => {\n        const activeMembers = team.team_members?.filter(member => member.is_active) || [];\n        const maxPlayers = team.max_players || 22;\n        return total + Math.max(0, maxPlayers - activeMembers.length);\n      }, 0);\n\n      // Clean up team member data for response\n      const processedTeams = teams.map(team => ({\n        ...team,\n        currentPlayers: team.team_members?.filter(member => member.is_active).length || 0,\n        members: team.team_members?.filter(member => member.is_active).map(member => ({\n          id: member.id,\n          user_id: member.user_id,\n          position: member.position,\n          jersey_number: member.jersey_number,\n          joined_at: member.joined_at,\n          user_name: null, // User details not available in this query\n          user_email: null // User details not available in this query\n        })) || []\n      }));\n\n      // Remove the raw team_members data\n      processedTeams.forEach(team => delete team.team_members);\n      \n      // Check if user is member (if userId provided)\n      let isUserMember = false;\n      let joinRequests: TeamJoinRequest[] = [];\n      \n      if (options.userId && teams.length > 0) {\n        // Check if user is a member of any team in this league\n        const userTeams = teams.filter(team => \n          team.team_members?.some(member => \n            member.user_id === options.userId && member.is_active\n          )\n        );\n        isUserMember = userTeams.length > 0;\n      }\n\n      const leagueDiscovery: LeagueDiscovery = {\n        ...league,\n        teams: processedTeams,\n        teamCount,\n        playerCount,\n        availableSpots,\n        isUserMember,\n        joinRequests: options.userId ? joinRequests : undefined,\n        // Add derived stats\n        isOpenForTeams: teamCount < (league.max_teams || 16),\n        hasActiveTeams: teamCount > 0,\n        averagePlayersPerTeam: teamCount > 0 ? Math.round(playerCount / teamCount * 10) / 10 : 0\n      };\n\n      // Cache if not user-specific\n      if (!options.userId) {\n        this.setCache(cacheKey, leagueDiscovery, 300);\n      }\n\n      return { data: leagueDiscovery, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getLeagueDetails'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Calculate compatibility score between user and league\n   */\n  async calculateCompatibilityScore(\n    leagueId: string,\n    userId: string\n  ): Promise<ServiceResponse<LeagueCompatibilityScore>> {\n    try {\n      const cacheKey = this.getCacheKey('calculateCompatibilityScore', { leagueId, userId });\n      const cached = this.getFromCache<LeagueCompatibilityScore>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Get league details\n      const leagueResponse = await this.getLeagueDetails(leagueId);\n      if (!leagueResponse.success || !leagueResponse.data) {\n        throw new Error('League not found');\n      }\n\n      const league = leagueResponse.data;\n\n      // Get user profile and stats\n      const { data: userProfile, error: profileError } = await this.supabase\n        .from('users')\n        .select('*')\n        .eq('id', userId)\n        .single();\n\n      if (profileError) throw profileError;\n\n      // Get user's cross-league stats\n      const { data: userStats } = await this.supabase\n        .from('player_cross_league_stats')\n        .select('*')\n        .eq('player_id', userId)\n        .eq('season_year', new Date().getFullYear())\n        .single();\n\n      // Calculate compatibility factors\n      const factors = {\n        skillMatch: this.calculateSkillMatch(league, userStats),\n        locationProximity: this.calculateLocationProximity(league, userProfile),\n        scheduleCompatibility: this.calculateScheduleCompatibility(league),\n        teamAvailability: this.calculateTeamAvailability(league),\n        entryAffordability: this.calculateEntryAffordability(league, userProfile)\n      };\n\n      // Calculate overall score (weighted average)\n      const weights = {\n        skillMatch: 0.3,\n        locationProximity: 0.2,\n        scheduleCompatibility: 0.2,\n        teamAvailability: 0.2,\n        entryAffordability: 0.1\n      };\n\n      const score = Math.round(\n        factors.skillMatch * weights.skillMatch +\n        factors.locationProximity * weights.locationProximity +\n        factors.scheduleCompatibility * weights.scheduleCompatibility +\n        factors.teamAvailability * weights.teamAvailability +\n        factors.entryAffordability * weights.entryAffordability\n      );\n\n      // Generate recommendations\n      const recommendations = this.generateRecommendations(factors, league);\n\n      const compatibility: LeagueCompatibilityScore = {\n        leagueId,\n        score,\n        factors,\n        recommendations\n      };\n\n      // Cache for 30 minutes\n      this.setCache(cacheKey, compatibility, 1800);\n\n      return { data: compatibility, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'calculateCompatibilityScore'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get available teams in a league for joining\n   */\n  async getAvailableTeams(\n    leagueId: string,\n    options: { userId?: string } = {}\n  ): Promise<ServiceResponse<TeamAvailability[]>> {\n    try {\n      const { data: teams, error } = await this.supabase\n        .from('teams')\n        .select(`\n          *,\n          team_members!inner (\n            id,\n            user_id,\n            position,\n            is_active\n          )\n        `)\n        .eq('league_id', leagueId)\n        .eq('is_recruiting', true);\n\n      if (error) throw error;\n\n      // Get captain details\n      const captainIds = teams?.map(t => t.captain_id).filter(Boolean) || [];\n      const { data: captains } = captainIds.length > 0 ? await this.supabase\n        .from('users')\n        .select('id, display_name')\n        .in('id', captainIds) : { data: [] };\n\n      const teamAvailabilities: TeamAvailability[] = (teams || []).map(team => {\n        const activeMembers = team.team_members?.filter(m => m.is_active) || [];\n        const captain = captains?.find(c => c.id === team.captain_id);\n        \n        // Calculate required positions (simplified - would need more complex logic)\n        const requiredPositions = this.getRequiredPositions(team, activeMembers);\n\n        return {\n          teamId: team.id,\n          teamName: team.name,\n          currentPlayers: activeMembers.length,\n          maxPlayers: team.max_players || 11,\n          availableSpots: Math.max(0, (team.max_players || 11) - activeMembers.length),\n          isRecruiting: team.is_recruiting,\n          requiredPositions,\n          captainContact: captain ? {\n            name: captain.display_name,\n            id: captain.id\n          } : undefined\n        };\n      });\n\n      // Filter out full teams\n      const availableTeams = teamAvailabilities.filter(team => team.availableSpots > 0);\n\n      return { data: availableTeams, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getAvailableTeams'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get player's league memberships\n   */\n  async getPlayerLeagueMemberships(\n    userId: string\n  ): Promise<ServiceResponse<Array<LeagueDiscovery & {\n    teamMembership: {\n      teamId: string;\n      teamName: string;\n      position?: string;\n      jerseyNumber?: number;\n      joinedAt: string;\n    };\n  }>>> {\n    try {\n      const cacheKey = this.getCacheKey('getPlayerLeagueMemberships', { userId });\n      const cached = this.getFromCache<any>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      const { data: memberships, error } = await this.supabase\n        .from('team_members')\n        .select(`\n          *,\n          team:teams!inner (\n            *,\n            league:leagues!inner (*)\n          )\n        `)\n        .eq('user_id', userId)\n        .eq('is_active', true);\n\n      if (error) throw error;\n\n      // Process into league discovery format with membership details\n      const leagueMemberships = await Promise.all(\n        (memberships || []).map(async (membership) => {\n          const league = membership.team.league;\n          const playerCount = await this.getLeaguePlayerCount(league.id);\n          const availableSpots = await this.getLeagueAvailableSpots(league.id);\n\n          // Get all teams in the league\n          const { data: allTeams } = await this.supabase\n            .from('teams')\n            .select('*')\n            .eq('league_id', league.id);\n\n          return {\n            ...league,\n            teams: allTeams || [],\n            teamCount: allTeams?.length || 0,\n            playerCount: playerCount.data || 0,\n            availableSpots: availableSpots.data || 0,\n            isUserMember: true,\n            teamMembership: {\n              teamId: membership.team_id,\n              teamName: membership.team.name,\n              position: membership.position,\n              jerseyNumber: membership.jersey_number,\n              joinedAt: membership.joined_at\n            }\n          };\n        })\n      );\n\n      // Cache for 5 minutes\n      this.setCache(cacheKey, leagueMemberships, 300);\n\n      return { data: leagueMemberships, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerLeagueMemberships'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n  private async getLeaguePlayerCount(leagueId: string): Promise<ServiceResponse<number>> {\n    try {\n      // Get all teams in the league first\n      const { data: teams, error: teamsError } = await this.supabase\n        .from('teams')\n        .select('id')\n        .eq('league_id', leagueId);\n\n      if (teamsError) throw teamsError;\n      \n      if (!teams || teams.length === 0) {\n        return { data: 0, error: null, success: true };\n      }\n\n      // Get count of active team members for those teams\n      const { count, error } = await this.supabase\n        .from('team_members')\n        .select('*', { count: 'exact', head: true })\n        .eq('is_active', true)\n        .in('team_id', teams.map(t => t.id));\n\n      if (error) throw error;\n      return { data: count || 0, error: null, success: true };\n    } catch (error) {\n      return { data: 0, error: this.handleError(error, 'getLeaguePlayerCount'), success: false };\n    }\n  }\n\n  private async getLeagueAvailableSpots(leagueId: string): Promise<ServiceResponse<number>> {\n    try {\n      // Get all teams in the league with their member counts\n      const { data: teams, error } = await this.supabase\n        .from('teams')\n        .select(`\n          id,\n          max_players,\n          team_members(id, is_active)\n        `)\n        .eq('league_id', leagueId);\n\n      if (error) throw error;\n      \n      if (!teams || teams.length === 0) {\n        return { data: 0, error: null, success: true };\n      }\n\n      // Calculate available spots across all teams\n      const availableSpots = teams.reduce((total, team) => {\n        const activeMembers = team.team_members?.filter(member => member.is_active).length || 0;\n        const maxPlayers = team.max_players || 11;\n        return total + Math.max(0, maxPlayers - activeMembers);\n      }, 0);\n\n      return { data: availableSpots, error: null, success: true };\n    } catch (error) {\n      return { data: 0, error: this.handleError(error, 'getLeagueAvailableSpots'), success: false };\n    }\n  }\n\n  private calculateSkillMatch(league: LeagueDiscovery, userStats: any): number {\n    if (!userStats) return 50; // Neutral score for new players\n\n    const avgGoalsPerGame = userStats.avg_goals_per_game || 0;\n    const totalGames = userStats.total_games_played || 0;\n\n    // Simple skill matching logic\n    if (league.league_type === 'casual' && totalGames < 10) return 85;\n    if (league.league_type === 'competitive' && avgGoalsPerGame > 0.5) return 80;\n    if (league.league_type === 'friendly') return 75;\n    \n    return 60;\n  }\n\n  private calculateLocationProximity(league: LeagueDiscovery, userProfile: any): number {\n    // Simplified location matching - would need geolocation in real implementation\n    if (!league.location || !userProfile.location) return 50;\n    \n    const leagueLocation = league.location.toLowerCase();\n    const userLocation = userProfile.location.toLowerCase();\n    \n    if (leagueLocation.includes(userLocation) || userLocation.includes(leagueLocation)) {\n      return 90;\n    }\n    \n    return 40;\n  }\n\n  private calculateScheduleCompatibility(league: LeagueDiscovery): number {\n    const now = new Date();\n    const seasonStart = new Date(league.season_start || now);\n    const seasonEnd = new Date(league.season_end || now);\n    \n    // Check if season is upcoming or current\n    if (seasonStart > now) return 85; // Upcoming season\n    if (seasonEnd > now) return 70; // Current season\n    \n    return 30; // Past season\n  }\n\n  private calculateTeamAvailability(league: LeagueDiscovery): number {\n    if (league.availableSpots === 0) return 0;\n    if (league.availableSpots > 10) return 95;\n    if (league.availableSpots > 5) return 80;\n    return 60;\n  }\n\n  private calculateEntryAffordability(league: LeagueDiscovery, userProfile: any): number {\n    const entryFee = league.entry_fee || 0;\n    \n    // Simplified affordability calculation\n    if (entryFee === 0) return 100;\n    if (entryFee < 50) return 85;\n    if (entryFee < 100) return 70;\n    return 50;\n  }\n\n  private generateRecommendations(factors: any, league: LeagueDiscovery): string[] {\n    const recommendations: string[] = [];\n    \n    if (factors.skillMatch < 60) {\n      recommendations.push('Consider improving your skills before joining this competitive league');\n    }\n    \n    if (factors.locationProximity < 50) {\n      recommendations.push('This league might be far from your location');\n    }\n    \n    if (factors.teamAvailability < 50) {\n      recommendations.push('Limited team spots available - apply soon');\n    }\n    \n    if (factors.entryAffordability < 60) {\n      recommendations.push('Entry fee might be higher than average');\n    }\n    \n    return recommendations;\n  }\n\n  private getRequiredPositions(team: any, activeMembers: any[]): string[] {\n    // Simplified position requirement logic\n    const positions = ['Goalkeeper', 'Defender', 'Midfielder', 'Forward'];\n    const occupiedPositions = activeMembers.map(m => m.position).filter(Boolean);\n    \n    return positions.filter(pos => !occupiedPositions.includes(pos));\n  }\n\n  /**\n   * Subscribe to real-time league updates\n   */\n  subscribeToLeagueUpdates(\n    leagueId: string,\n    callback: (payload: any) => void,\n    options: RealtimeSubscriptionOptions = { table: 'leagues', event: '*' }\n  ) {\n    return this.supabase\n      .channel(`league-${leagueId}-updates`)\n      .on(\n        'postgres_changes',\n        {\n          event: options.event,\n          schema: options.schema || 'public',\n          table: options.table,\n          filter: options.filter || `id=eq.${leagueId}`\n        },\n        callback\n      )\n      .subscribe();\n  }\n\n  /**\n   * Clear cache\n   */\n  clearCache(pattern?: string): void {\n    if (!pattern) {\n      this.cache.clear();\n      return;\n    }\n\n    const keys = Array.from(this.cache.keys());\n    keys.forEach(key => {\n      if (key.includes(pattern)) {\n        this.cache.delete(key);\n      }\n    });\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 680, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/team.service.ts"],"sourcesContent":["/**\n * Team Service for MatchDay\n * \n * Handles comprehensive team-related operations with focus on:\n * - Team creation and management\n * - Team member management and join requests\n * - Team statistics and performance tracking\n * - Real-time team updates and notifications\n * \n * Optimized for amateur sports leagues with proper error handling,\n * caching strategies, and authentication integration.\n */\n\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport {\n  Database,\n  Team,\n  TeamMember,\n  InsertTeam,\n  UpdateTeam,\n  CreateTeamForm,\n  ServiceResponse,\n  ServiceError,\n  PaginatedServiceResponse,\n  TeamJoinRequest,\n  JoinRequestStatus,\n  UserProfile,\n  League,\n  CacheOptions,\n  RealtimeSubscriptionOptions\n} from '@/lib/types/database.types';\n\nexport interface TeamWithDetails extends Team {\n  league: League | null;\n  leagues: Array<{\n    id: string;\n    name: string;\n    seasons: number[];\n    isCurrent: boolean;\n  }>;\n  captain?: UserProfile;\n  members: Array<TeamMember & { user_profile: UserProfile }>;\n  memberCount: number;\n  availableSpots: number;\n  joinRequests?: TeamJoinRequest[];\n  stats?: {\n    wins: number;\n    draws: number;\n    losses: number;\n    goals_for: number;\n    goals_against: number;\n    points: number;\n    position: number;\n    total_teams: number;\n  };\n  isOrphaned?: boolean;\n  previousLeagueName?: string;\n}\n\nexport interface TeamCreationOptions {\n  auto_add_creator: boolean;\n  initial_position?: string;\n  initial_jersey_number?: number;\n}\n\nexport class TeamService {\n  private static instance: TeamService;\n  private supabase: SupabaseClient<Database>;\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n\n  private constructor(supabaseClient: SupabaseClient<Database>) {\n    this.supabase = supabaseClient;\n  }\n\n  static getInstance(supabaseClient?: SupabaseClient<Database>): TeamService {\n    if (!TeamService.instance) {\n      if (!supabaseClient) {\n        throw new Error('SupabaseClient required for first initialization');\n      }\n      TeamService.instance = new TeamService(supabaseClient);\n    } else if (supabaseClient) {\n      // Always update the supabase client to ensure fresh authentication context\n      TeamService.instance.supabase = supabaseClient;\n    }\n    return TeamService.instance;\n  }\n\n  /**\n   * Handle service errors consistently\n   */\n  private handleError(error: any, operation: string): ServiceError {\n    console.error(`TeamService.${operation}:`, error);\n    return {\n      code: error.code || 'UNKNOWN_ERROR',\n      message: error.message || 'An unexpected error occurred',\n      details: error.details || error,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Cache management utilities\n   */\n  private getCacheKey(operation: string, params: any): string {\n    return `team_service:${operation}:${JSON.stringify(params)}`;\n  }\n\n  private getFromCache<T>(key: string): T | null {\n    const cached = this.cache.get(key);\n    if (!cached) return null;\n    \n    if (Date.now() - cached.timestamp > cached.ttl * 1000) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return cached.data as T;\n  }\n\n  private setCache<T>(key: string, data: T, ttl = 300): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl\n    });\n  }\n\n  /**\n   * Create a new team\n   */\n  async createTeam(\n    captainId: string,\n    teamData: CreateTeamForm,\n    options: TeamCreationOptions = { auto_add_creator: true }\n  ): Promise<ServiceResponse<TeamWithDetails>> {\n    try {\n      // First, validate that the league exists and is active\n      const { data: league, error: leagueError } = await this.supabase\n        .from('leagues')\n        .select('*')\n        .eq('id', teamData.league_id)\n        .eq('is_active', true)\n        .single();\n\n      if (leagueError) {\n        if (leagueError.code === 'PGRST116') {\n          return {\n            data: null,\n            error: {\n              code: 'LEAGUE_NOT_FOUND',\n              message: 'Selected league not found or is not active',\n              timestamp: new Date().toISOString()\n            },\n            success: false\n          };\n        }\n        throw leagueError;\n      }\n\n      // Check if team name is unique within the league\n      const { data: existingTeam, error: nameCheckError } = await this.supabase\n        .from('teams')\n        .select('id')\n        .eq('league_id', teamData.league_id)\n        .eq('name', teamData.name)\n        .single();\n\n      if (nameCheckError && nameCheckError.code !== 'PGRST116') {\n        throw nameCheckError;\n      }\n\n      if (existingTeam) {\n        return {\n          data: null,\n          error: {\n            code: 'TEAM_NAME_EXISTS',\n            message: 'A team with this name already exists in the selected league',\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      // Use a transaction-like approach: create team without captain first, then add member, then update captain\n      // This avoids the chicken-and-egg problem with foreign key constraints\n      \n      // Step 1: Create team record without captain initially\n      const teamInsert: InsertTeam = {\n        league_id: teamData.league_id,\n        name: teamData.name,\n        team_color: teamData.team_color,\n        captain_id: null, // Initially null to avoid FK constraint issues\n        max_players: teamData.max_players || 22,\n        min_players: teamData.min_players || 7,\n        is_recruiting: true,\n        team_bio: teamData.description || null\n      };\n\n      const { data: newTeam, error: teamError } = await this.supabase\n        .from('teams')\n        .insert(teamInsert)\n        .select()\n        .single();\n\n      if (teamError) throw teamError;\n\n      try {\n        // Step 2: Add creator as team member\n        if (options.auto_add_creator) {\n          const { error: memberError } = await this.supabase\n            .from('team_members')\n            .insert({\n              team_id: newTeam.id,\n              user_id: captainId,\n              position: options.initial_position || 'midfielder',\n              jersey_number: options.initial_jersey_number || 1,\n              is_active: true\n            });\n\n          if (memberError) throw memberError;\n        }\n\n        // Step 3: Update team with captain_id now that member exists\n        const { error: updateError } = await this.supabase\n          .from('teams')\n          .update({ captain_id: captainId })\n          .eq('id', newTeam.id);\n\n        if (updateError) throw updateError;\n\n      } catch (error) {\n        // If any step fails, clean up the team\n        await this.supabase.from('teams').delete().eq('id', newTeam.id);\n        throw error;\n      }\n\n      // Return the created team data directly without complex details lookup\n      // to avoid potential infinite recursion during creation\n      const basicTeamData: TeamWithDetails = {\n        ...newTeam,\n        captain_id: captainId, // Use the updated captain_id\n        league: null, // Will be populated later if needed\n        captain: undefined,\n        members: [],\n        memberCount: options.auto_add_creator ? 1 : 0,\n        availableSpots: (teamData.max_players || 22) - (options.auto_add_creator ? 1 : 0),\n        isOrphaned: false,\n        previousLeagueName: undefined\n      };\n\n      // Clear relevant caches\n      this.clearCache('getUserTeams');\n\n      return {\n        data: basicTeamData,\n        error: null,\n        success: true\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'createTeam'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get season year for a team by checking their actual match dates\n   */\n  private async getTeamSeasonYear(teamId: string): Promise<number> {\n    // Check if team has completed matches and get their season year\n    const { data: matchYears } = await this.supabase\n      .from('matches')\n      .select('match_date')\n      .or(`home_team_id.eq.${teamId},away_team_id.eq.${teamId}`)\n      .eq('status', 'completed')\n      .limit(1);\n    \n    if (matchYears && matchYears.length > 0) {\n      const matchYear = new Date(matchYears[0].match_date).getFullYear();\n      return matchYear;\n    }\n    \n    // Fallback to current year if no completed matches\n    return new Date().getFullYear();\n  }\n\n  /**\n   * Get all leagues this team has participated in\n   */\n  private async getTeamLeagues(teamId: string): Promise<Array<{\n    id: string;\n    name: string;\n    seasons: number[];\n    isCurrent: boolean;\n  }>> {\n    try {\n      // Get all leagues from team_stats (historical participation)\n      const { data: leagueStats, error } = await this.supabase\n        .from('team_stats')\n        .select(`\n          league_id,\n          season_year,\n          leagues!inner(id, name)\n        `)\n        .eq('team_id', teamId);\n\n      if (error) {\n        console.error('Error fetching team leagues:', error);\n        return [];\n      }\n\n      if (!leagueStats || leagueStats.length === 0) {\n        return [];\n      }\n\n      // Group by league and collect seasons\n      const leaguesMap = new Map();\n      \n      leagueStats.forEach(stat => {\n        if (!stat.leagues) return;\n        \n        const leagueId = stat.leagues.id;\n        if (!leaguesMap.has(leagueId)) {\n          leaguesMap.set(leagueId, {\n            id: leagueId,\n            name: stat.leagues.name,\n            seasons: [],\n            isCurrent: false\n          });\n        }\n        \n        const league = leaguesMap.get(leagueId);\n        if (!league.seasons.includes(stat.season_year)) {\n          league.seasons.push(stat.season_year);\n        }\n      });\n\n      // Convert map to array and sort seasons\n      const leagues = Array.from(leaguesMap.values());\n      leagues.forEach(league => {\n        league.seasons.sort((a, b) => b - a); // Latest first\n        // Mark as current if it's the team's current league\n        // We'll determine this in the main method\n      });\n\n      return leagues.sort((a, b) => a.name.localeCompare(b.name));\n    } catch (error) {\n      console.error('Error in getTeamLeagues:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get detailed team information\n   */\n  async getTeamDetails(\n    teamId: string,\n    options: CacheOptions = {}\n  ): Promise<ServiceResponse<TeamWithDetails>> {\n    try {\n      const cacheKey = this.getCacheKey('getTeamDetails', { teamId });\n      const cached = this.getFromCache<TeamWithDetails>(cacheKey);\n      \n      if (cached && !options.revalidateOnBackground) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Get team with league and member details\n      // Use left join for leagues since team might be orphaned\n      const { data: team, error: teamError } = await this.supabase\n        .from('teams')\n        .select(`\n          *,\n          league:leagues(*),\n          team_members(\n            *,\n            user_profile:users(*)\n          )\n        `)\n        .eq('id', teamId)\n        .single();\n\n      if (teamError) {\n        if (teamError.code === 'PGRST116') {\n          return {\n            data: null,\n            error: {\n              code: 'TEAM_NOT_FOUND',\n              message: 'Team not found',\n              timestamp: new Date().toISOString()\n            },\n            success: false\n          };\n        }\n        throw teamError;\n      }\n\n      // Get captain profile if exists\n      let captain: UserProfile | undefined;\n      if (team.captain_id) {\n        const { data: captainProfile } = await this.supabase\n          .from('users')\n          .select('*')\n          .eq('id', team.captain_id)\n          .single();\n        \n        captain = captainProfile || undefined;\n      }\n\n      // Get season year for this team\n      const seasonYear = await this.getTeamSeasonYear(teamId);\n      \n      // Get all leagues this team has participated in\n      const teamLeagues = await this.getTeamLeagues(teamId);\n      \n      // Get team statistics\n      const { data: teamStats } = await this.supabase\n        .from('team_stats')\n        .select('*')\n        .eq('team_id', teamId)\n        .eq('season_year', seasonYear)\n        .single();\n\n      // Calculate team position if stats exist and team has a league\n      let stats;\n      if (teamStats && team.league_id) {\n        const { data: leagueTeams } = await this.supabase\n          .from('team_stats')\n          .select('team_id, points, goals_for, goals_against')\n          .eq('league_id', team.league_id)\n          .eq('season_year', seasonYear)\n          .order('points', { ascending: false });\n\n        const position = leagueTeams?.findIndex(t => t.team_id === teamId) + 1 || 1;\n        \n        stats = {\n          wins: teamStats.wins || 0,\n          draws: teamStats.draws || 0,\n          losses: teamStats.losses || 0,\n          goals: teamStats.goals_for || 0,\n          goalsAgainst: teamStats.goals_against || 0,\n          points: teamStats.points || 0,\n          position,\n          totalTeams: leagueTeams?.length || 1\n        };\n      } else if (teamStats) {\n        // Team has stats but no league (orphaned team)\n        stats = {\n          wins: teamStats.wins || 0,\n          draws: teamStats.draws || 0,\n          losses: teamStats.losses || 0,\n          goals: teamStats.goals_for || 0,\n          goalsAgainst: teamStats.goals_against || 0,\n          points: teamStats.points || 0,\n          position: 0,\n          totalTeams: 0\n        };\n      }\n\n      // Mark current league in the leagues array\n      const leagues = teamLeagues.map(league => ({\n        ...league,\n        isCurrent: league.id === team.league_id\n      }));\n\n      const activeMembers = team.team_members?.filter((m: any) => m.is_active) || [];\n      const teamWithDetails: TeamWithDetails = {\n        ...team,\n        league: team.league || null,\n        leagues: leagues,\n        captain,\n        members: activeMembers,\n        memberCount: activeMembers.length,\n        availableSpots: Math.max(0, (team.max_players || 22) - activeMembers.length),\n        stats,\n        isOrphaned: !team.league_id,\n        previousLeagueName: team.previous_league_name || undefined\n      };\n\n      // Cache for 5 minutes, but clear existing cache to ensure fresh data\n      this.clearCache('getTeamDetails');\n      this.setCache(cacheKey, teamWithDetails, options.ttl || 300);\n\n      return { data: teamWithDetails, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getTeamDetails'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get all teams for a user (where user is a member)\n   */\n  async getUserTeams(\n    userId: string,\n    options: { includeInactive?: boolean; limit?: number } = {}\n  ): Promise<ServiceResponse<TeamWithDetails[]>> {\n    try {\n      const cacheKey = this.getCacheKey('getUserTeams', { userId, options });\n      const cached = this.getFromCache<TeamWithDetails[]>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      console.log(' TeamService.getUserTeams - Querying for user:', userId);\n\n      let memberQuery = this.supabase\n        .from('team_members')\n        .select(`\n          *,\n          team:teams!inner(\n            *,\n            league:leagues(*)\n          )\n        `)\n        .eq('user_id', userId);\n\n      if (!options.includeInactive) {\n        memberQuery = memberQuery.eq('is_active', true);\n      }\n\n      console.log(' TeamService.getUserTeams - Executing query...');\n      const { data: memberships, error: memberError } = await memberQuery\n        .order('joined_at', { ascending: false })\n        .limit(options.limit || 50);\n\n      console.log(' TeamService.getUserTeams - Query result:', {\n        membershipsCount: memberships?.length || 0,\n        error: memberError?.message || null,\n        memberships: memberships\n      });\n\n      if (memberError) throw memberError;\n\n      // PERFORMANCE OPTIMIZATION: Use embedded team data directly instead of expensive getTeamDetails calls\n      console.log(' TeamService.getUserTeams - Processing', memberships?.length || 0, 'memberships');\n      console.log(' OPTIMIZATION: Using embedded team data to eliminate N+1 query problem');\n      \n      const teams = (memberships || []).map((membership, index) => {\n        console.log(` TeamService.getUserTeams - Processing membership ${index + 1}:`, {\n          teamId: membership.team_id,\n          position: membership.position,\n          hasEmbeddedTeam: !!membership.team,\n          teamName: membership.team?.name\n        });\n        \n        if (!membership.team) {\n          console.warn(` No embedded team data for membership ${membership.team_id}`);\n          return null;\n        }\n\n        // Create TeamWithDetails from embedded data - no additional queries needed\n        const teamWithDetails: TeamWithDetails = {\n          // Core team data (all available from the initial query)\n          id: membership.team.id,\n          name: membership.team.name,\n          description: membership.team.description || '',\n          team_color: membership.team.team_color,\n          max_players: membership.team.max_players || 22,\n          team_bio: membership.team.team_bio || '',\n          captain_id: membership.team.captain_id,\n          league_id: membership.team.league_id,\n          is_active: membership.team.is_active ?? true,\n          created_at: membership.team.created_at,\n          updated_at: membership.team.updated_at,\n          \n          // League information (already included in query via join)\n          league: membership.team.league,\n          \n          // Simplified member information for team listing (avoid expensive queries)\n          captain: null, // Skip captain lookup for performance\n          members: [], // Skip member list for team listing\n          memberCount: 1, // At least the current user is a member\n          availableSpots: Math.max(0, (membership.team.max_players || 22) - 1),\n          \n          // Status flags\n          isOrphaned: !membership.team.league_id,\n          \n          // Skip expensive aggregations for team listing\n          stats: undefined,\n          joinRequests: undefined\n        };\n\n        console.log(` Created optimized team data for ${membership.team.name} (no additional queries)`);\n        return teamWithDetails;\n      });\n      console.log(' TeamService.getUserTeams - Team processing results:', {\n        totalTeams: teams.length,\n        validTeams: teams.filter(t => t !== null).length,\n        nullTeams: teams.filter(t => t === null).length\n      });\n      \n      const validTeams = teams.filter((team): team is TeamWithDetails => team !== null);\n\n      // Cache for 5 minutes\n      this.setCache(cacheKey, validTeams, 300);\n\n      console.log(' TeamService.getUserTeams - Final result:', {\n        success: true,\n        teamsCount: validTeams.length,\n        teamNames: validTeams.map(t => t.name)\n      });\n\n      return { data: validTeams, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getUserTeams'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Update team information\n   */\n  async updateTeam(\n    teamId: string,\n    captainId: string,\n    updates: UpdateTeam\n  ): Promise<ServiceResponse<Team>> {\n    try {\n      // Verify the user is the team captain\n      const { data: team, error: verifyError } = await this.supabase\n        .from('teams')\n        .select('captain_id')\n        .eq('id', teamId)\n        .single();\n\n      if (verifyError) throw verifyError;\n\n      if (team.captain_id !== captainId) {\n        return {\n          data: null,\n          error: {\n            code: 'UNAUTHORIZED',\n            message: 'Only team captains can update team information',\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      // Update team\n      const { data: updatedTeam, error: updateError } = await this.supabase\n        .from('teams')\n        .update({\n          ...updates,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', teamId)\n        .select()\n        .single();\n\n      if (updateError) throw updateError;\n\n      // Clear caches\n      this.clearCache('getTeamDetails');\n      this.clearCache('getUserTeams');\n\n      return { data: updatedTeam, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'updateTeam'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Find league by sport and location for team creation\n   */\n  async findLeagueByName(\n    sport: string,\n    leagueName: string\n  ): Promise<ServiceResponse<League>> {\n    try {\n      const { data: league, error } = await this.supabase\n        .from('leagues')\n        .select('*')\n        .eq('sport_type', sport.toLowerCase())\n        .eq('name', leagueName)\n        .eq('is_active', true)\n        .eq('is_public', true)\n        .single();\n\n      if (error) {\n        if (error.code === 'PGRST116') {\n          return {\n            data: null,\n            error: {\n              code: 'LEAGUE_NOT_FOUND',\n              message: 'No active league found with the specified name and sport',\n              timestamp: new Date().toISOString()\n            },\n            success: false\n          };\n        }\n        throw error;\n      }\n\n      return { data: league, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'findLeagueByName'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Search teams across leagues\n   */\n  async searchTeams(options: {\n    query?: string;\n    sport?: string;\n    location?: string;\n    hasAvailableSpots?: boolean;\n    limit?: number;\n    offset?: number;\n  } = {}): Promise<PaginatedServiceResponse<TeamWithDetails>> {\n    try {\n      let query = this.supabase\n        .from('teams')\n        .select(`\n          *,\n          league:leagues!inner(*)\n        `, { count: 'exact' })\n        .eq('league.is_active', true)\n        .eq('league.is_public', true);\n\n      if (options.query) {\n        query = query.or(`name.ilike.%${options.query}%,team_bio.ilike.%${options.query}%`);\n      }\n\n      if (options.sport) {\n        query = query.eq('league.sport_type', options.sport.toLowerCase());\n      }\n\n      if (options.location) {\n        query = query.ilike('league.location', `%${options.location}%`);\n      }\n\n      if (options.hasAvailableSpots) {\n        query = query.eq('is_recruiting', true);\n      }\n\n      const { data: teams, error, count } = await query\n        .order('created_at', { ascending: false })\n        .range(options.offset || 0, (options.offset || 0) + (options.limit || 20) - 1);\n\n      if (error) throw error;\n\n      // Get detailed information for each team\n      const teamPromises = (teams || []).map(async (team) => {\n        const teamDetails = await this.getTeamDetails(team.id);\n        return teamDetails.data;\n      });\n\n      const detailedTeams = await Promise.all(teamPromises);\n      const validTeams = detailedTeams.filter((team): team is TeamWithDetails => team !== null);\n\n      // Filter by available spots if requested\n      const filteredTeams = options.hasAvailableSpots \n        ? validTeams.filter(team => team.availableSpots > 0)\n        : validTeams;\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n        limit: options.limit || 20,\n        total: count || 0,\n        totalPages: Math.ceil((count || 0) / (options.limit || 20)),\n        hasNext: ((options.offset || 0) + (options.limit || 20)) < (count || 0),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: filteredTeams,\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'searchTeams'),\n        success: false,\n        pagination: {\n          page: 1,\n          limit: options.limit || 20,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrevious: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Subscribe to real-time team updates\n   */\n  subscribeToTeamUpdates(\n    teamId: string,\n    callback: (payload: any) => void,\n    options: RealtimeSubscriptionOptions = { table: 'teams', event: '*' }\n  ) {\n    return this.supabase\n      .channel(`team-${teamId}-updates`)\n      .on(\n        'postgres_changes',\n        {\n          event: options.event,\n          schema: options.schema || 'public',\n          table: options.table,\n          filter: options.filter || `id=eq.${teamId}`\n        },\n        callback\n      )\n      .subscribe();\n  }\n\n  /**\n   * Clear cache for specific operations or all cache\n   */\n  clearCache(pattern?: string): void {\n    if (!pattern) {\n      this.cache.clear();\n      return;\n    }\n\n    const keys = Array.from(this.cache.keys());\n    keys.forEach(key => {\n      if (key.includes(pattern)) {\n        this.cache.delete(key);\n      }\n    });\n  }\n\n  /**\n   * Get all orphaned teams (teams without a league)\n   */\n  async getOrphanedTeams(options: {\n    includeArchived?: boolean;\n    limit?: number;\n    offset?: number;\n  } = {}): Promise<PaginatedServiceResponse<TeamWithDetails>> {\n    try {\n      let query = this.supabase\n        .from('teams')\n        .select(`\n          *,\n          league:leagues(*),\n          team_members(\n            *,\n            user_profile:users(*)\n          )\n        `, { count: 'exact' })\n        .is('league_id', null);\n\n      if (!options.includeArchived) {\n        query = query.eq('is_archived', false);\n      }\n\n      const { data: teams, error, count } = await query\n        .order('updated_at', { ascending: false })\n        .range(options.offset || 0, (options.offset || 0) + (options.limit || 20) - 1);\n\n      if (error) throw error;\n\n      // Get detailed information for each team\n      const teamPromises = (teams || []).map(async (team) => {\n        const teamDetails = await this.getTeamDetails(team.id);\n        return teamDetails.data;\n      });\n\n      const detailedTeams = await Promise.all(teamPromises);\n      const validTeams = detailedTeams.filter((team): team is TeamWithDetails => team !== null);\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n        limit: options.limit || 20,\n        total: count || 0,\n        totalPages: Math.ceil((count || 0) / (options.limit || 20)),\n        hasNext: ((options.offset || 0) + (options.limit || 20)) < (count || 0),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: validTeams,\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getOrphanedTeams'),\n        success: false,\n        pagination: {\n          page: 1,\n          limit: options.limit || 20,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrevious: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Reassign an orphaned team to a new league\n   */\n  async reassignTeamToLeague(\n    teamId: string,\n    newLeagueId: string,\n    userId: string\n  ): Promise<ServiceResponse<TeamWithDetails>> {\n    try {\n      // Verify the user is the team captain\n      const { data: team, error: verifyError } = await this.supabase\n        .from('teams')\n        .select('captain_id, name, league_id')\n        .eq('id', teamId)\n        .single();\n\n      if (verifyError) throw verifyError;\n\n      if (team.captain_id !== userId) {\n        return {\n          data: null,\n          error: {\n            code: 'UNAUTHORIZED',\n            message: 'Only team captains can reassign their team to a new league',\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      // Verify the new league exists and is active\n      const { data: league, error: leagueError } = await this.supabase\n        .from('leagues')\n        .select('*')\n        .eq('id', newLeagueId)\n        .eq('is_active', true)\n        .single();\n\n      if (leagueError) {\n        if (leagueError.code === 'PGRST116') {\n          return {\n            data: null,\n            error: {\n              code: 'LEAGUE_NOT_FOUND',\n              message: 'Selected league not found or is not active',\n              timestamp: new Date().toISOString()\n            },\n            success: false\n          };\n        }\n        throw leagueError;\n      }\n\n      // Check if team name is unique in the new league\n      const { data: existingTeam, error: nameCheckError } = await this.supabase\n        .from('teams')\n        .select('id')\n        .eq('league_id', newLeagueId)\n        .eq('name', team.name)\n        .neq('id', teamId)\n        .single();\n\n      if (nameCheckError && nameCheckError.code !== 'PGRST116') {\n        throw nameCheckError;\n      }\n\n      if (existingTeam) {\n        return {\n          data: null,\n          error: {\n            code: 'TEAM_NAME_EXISTS',\n            message: 'A team with this name already exists in the selected league',\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      // Update the team\n      const { data: updatedTeam, error: updateError } = await this.supabase\n        .from('teams')\n        .update({\n          league_id: newLeagueId,\n          previous_league_name: null,\n          is_archived: false,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', teamId)\n        .select()\n        .single();\n\n      if (updateError) throw updateError;\n\n      // Get the complete team details\n      const teamDetails = await this.getTeamDetails(teamId);\n      \n      if (!teamDetails.success || !teamDetails.data) {\n        throw new Error('Failed to retrieve updated team details');\n      }\n\n      // Clear caches\n      this.clearCache('getTeamDetails');\n      this.clearCache('getUserTeams');\n      this.clearCache('getOrphanedTeams');\n\n      return {\n        data: teamDetails.data,\n        error: null,\n        success: true\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'reassignTeamToLeague'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Archive an orphaned team\n   */\n  async archiveTeam(\n    teamId: string,\n    userId: string\n  ): Promise<ServiceResponse<Team>> {\n    try {\n      // Verify the user is the team captain\n      const { data: team, error: verifyError } = await this.supabase\n        .from('teams')\n        .select('captain_id')\n        .eq('id', teamId)\n        .single();\n\n      if (verifyError) throw verifyError;\n\n      if (team.captain_id !== userId) {\n        return {\n          data: null,\n          error: {\n            code: 'UNAUTHORIZED',\n            message: 'Only team captains can archive their team',\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      // Archive the team\n      const { data: archivedTeam, error: updateError } = await this.supabase\n        .from('teams')\n        .update({\n          is_archived: true,\n          is_recruiting: false,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', teamId)\n        .select()\n        .single();\n\n      if (updateError) throw updateError;\n\n      // Clear caches\n      this.clearCache('getTeamDetails');\n      this.clearCache('getUserTeams');\n      this.clearCache('getOrphanedTeams');\n\n      return { data: archivedTeam, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'archiveTeam'),\n        success: false\n      };\n    }\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1479, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/match.service.ts"],"sourcesContent":["/**\n * Match Service for MatchDay\n * \n * Handles match viewing and statistics operations with focus on:\n * - Player's upcoming and past matches\n * - Match events and statistics\n * - Live match tracking and real-time updates\n * - Performance metrics and match analysis\n * \n * Optimized for player-centric match experience with comprehensive statistics\n */\n\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport {\n  Database,\n  Match,\n  MatchEvent,\n  MatchWithDetails,\n  LiveMatchData,\n  ActiveMatch,\n  ServiceResponse,\n  ServiceError,\n  PaginatedServiceResponse,\n  MatchStatus,\n  EventType,\n  CacheOptions,\n  RealtimeSubscriptionOptions\n} from '@/lib/types/database.types';\n\nexport interface MatchFilters {\n  leagueId?: string;\n  teamId?: string;\n  status?: MatchStatus;\n  dateFrom?: string;\n  dateTo?: string;\n  venue?: string;\n  sportType?: string;\n}\n\nexport interface PlayerMatchStats {\n  matchId: string;\n  playerId: string;\n  playerName: string;\n  goals: number;\n  assists: number;\n  yellowCards: number;\n  redCards: number;\n  minutesPlayed: number;\n  position?: string;\n  events: MatchEvent[];\n  performance: {\n    rating: number;\n    keyPasses: number;\n    successfulPasses: number;\n    totalPasses: number;\n    tackles: number;\n    saves?: number;\n  };\n}\n\nexport interface MatchPrediction {\n  matchId: string;\n  homeWinProbability: number;\n  drawProbability: number;\n  awayWinProbability: number;\n  expectedGoalsHome: number;\n  expectedGoalsAway: number;\n  keyFactors: string[];\n  confidence: number;\n}\n\nexport interface MatchAnalytics {\n  matchId: string;\n  duration: number;\n  totalEvents: number;\n  goalsByPeriod: {\n    firstHalf: { home: number; away: number };\n    secondHalf: { home: number; away: number };\n    extraTime?: { home: number; away: number };\n  };\n  cardsByTeam: {\n    home: { yellow: number; red: number };\n    away: { yellow: number; red: number };\n  };\n  topPerformers: {\n    home: PlayerMatchStats[];\n    away: PlayerMatchStats[];\n  };\n  matchMomentum: Array<{\n    minute: number;\n    homeScore: number;\n    awayScore: number;\n    eventType: EventType;\n    momentum: number; // -100 to 100 (negative = away momentum, positive = home momentum)\n  }>;\n}\n\nexport class MatchService {\n  private static instance: MatchService;\n  private supabase: SupabaseClient<Database>;\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n\n  private constructor(supabaseClient: SupabaseClient<Database>) {\n    this.supabase = supabaseClient;\n  }\n\n  static getInstance(supabaseClient?: SupabaseClient<Database>): MatchService {\n    if (!MatchService.instance) {\n      if (!supabaseClient) {\n        throw new Error('SupabaseClient required for first initialization');\n      }\n      MatchService.instance = new MatchService(supabaseClient);\n    }\n    return MatchService.instance;\n  }\n\n  /**\n   * Handle service errors consistently\n   */\n  private handleError(error: any, operation: string): ServiceError {\n    console.error(`MatchService.${operation}:`, error);\n    return {\n      code: error.code || 'UNKNOWN_ERROR',\n      message: error.message || 'An unexpected error occurred',\n      details: error.details || error,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Cache management utilities\n   */\n  private getCacheKey(operation: string, params: any): string {\n    return `match_service:${operation}:${JSON.stringify(params)}`;\n  }\n\n  private getFromCache<T>(key: string): T | null {\n    const cached = this.cache.get(key);\n    if (!cached) return null;\n    \n    if (Date.now() - cached.timestamp > cached.ttl * 1000) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return cached.data as T;\n  }\n\n  private setCache<T>(key: string, data: T, ttl = 300): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl\n    });\n  }\n\n  /**\n   * Get player's matches with detailed information\n   */\n  async getPlayerMatches(\n    userId: string,\n    filters: MatchFilters = {},\n    options: {\n      limit?: number;\n      offset?: number;\n      includeFutureMatches?: boolean;\n      includeStats?: boolean;\n    } = {}\n  ): Promise<PaginatedServiceResponse<MatchWithDetails>> {\n    try {\n      const cacheKey = this.getCacheKey('getPlayerMatches', { userId, filters, options });\n      const cached = this.getFromCache<MatchWithDetails[]>(cacheKey);\n      \n      if (cached) {\n        return {\n          data: cached,\n          error: null,\n          success: true,\n          pagination: {\n            page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n            limit: options.limit || 20,\n            total: cached.length,\n            totalPages: Math.ceil(cached.length / (options.limit || 20)),\n            hasNext: false,\n            hasPrevious: false\n          }\n        };\n      }\n\n      // Get player's teams to find their matches\n      const { data: userTeams, error: teamsError } = await this.supabase\n        .from('team_members')\n        .select('team_id')\n        .eq('user_id', userId)\n        .eq('is_active', true);\n\n      if (teamsError) throw teamsError;\n\n      if (!userTeams || userTeams.length === 0) {\n        return {\n          data: [],\n          error: null,\n          success: true,\n          pagination: {\n            page: 1,\n            limit: options.limit || 20,\n            total: 0,\n            totalPages: 0,\n            hasNext: false,\n            hasPrevious: false\n          }\n        };\n      }\n\n      const teamIds = userTeams.map(tm => tm.team_id);\n\n      // Build match query\n      let query = this.supabase\n        .from('matches')\n        .select(`\n          *,\n          home_team:teams!matches_home_team_id_fkey(*),\n          away_team:teams!matches_away_team_id_fkey(*),\n          league:leagues!inner(*)\n        `, { count: 'exact' })\n        .or(`home_team_id.in.(${teamIds.join(',')}),away_team_id.in.(${teamIds.join(',')})`);\n\n      // Apply filters\n      if (filters.leagueId) {\n        query = query.eq('league_id', filters.leagueId);\n      }\n\n      if (filters.status) {\n        query = query.eq('status', filters.status);\n      }\n\n      if (filters.dateFrom) {\n        query = query.gte('scheduled_date', filters.dateFrom);\n      }\n\n      if (filters.dateTo) {\n        query = query.lte('scheduled_date', filters.dateTo);\n      }\n\n      if (filters.venue) {\n        query = query.ilike('venue', `%${filters.venue}%`);\n      }\n\n      if (!options.includeFutureMatches) {\n        query = query.lte('scheduled_date', new Date().toISOString());\n      }\n\n      const { data: matches, error, count } = await query\n        .order('scheduled_date', { ascending: false })\n        .range(options.offset || 0, (options.offset || 0) + (options.limit || 20) - 1);\n\n      if (error) throw error;\n\n      // Get match events and stats for each match\n      const matchesWithDetails: MatchWithDetails[] = await Promise.all(\n        (matches || []).map(async (match) => {\n          // Get match events\n          const { data: events, error: eventsError } = await this.supabase\n            .from('match_events')\n            .select('*')\n            .eq('match_id', match.id)\n            .order('event_time', { ascending: true });\n\n          if (eventsError) throw eventsError;\n\n          // Get team players\n          const { data: homePlayers, error: homeError } = await this.supabase\n            .from('team_members')\n            .select(`\n              user_id,\n              position,\n              jersey_number,\n              users!inner(*)\n            `)\n            .eq('team_id', match.home_team_id)\n            .eq('is_active', true);\n\n          const { data: awayPlayers, error: awayError } = await this.supabase\n            .from('team_members')\n            .select(`\n              user_id,\n              position,\n              jersey_number,\n              users!inner(*)\n            `)\n            .eq('team_id', match.away_team_id)\n            .eq('is_active', true);\n\n          if (homeError) throw homeError;\n          if (awayError) throw awayError;\n\n          // Calculate player stats if requested\n          let playerStats;\n          if (options.includeStats) {\n            playerStats = await this.calculateMatchPlayerStats(match.id, userId);\n          }\n\n          return {\n            ...match,\n            homeTeam: match.home_team,\n            awayTeam: match.away_team,\n            league: match.league,\n            events: events || [],\n            homeTeamPlayers: (homePlayers || []).map(p => p.users),\n            awayTeamPlayers: (awayPlayers || []).map(p => p.users),\n            playerStats: playerStats ? [playerStats] : undefined\n          };\n        })\n      );\n\n      // Cache for 2 minutes (shorter for live data)\n      this.setCache(cacheKey, matchesWithDetails, 120);\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n        limit: options.limit || 20,\n        total: count || 0,\n        totalPages: Math.ceil((count || 0) / (options.limit || 20)),\n        hasNext: ((options.offset || 0) + (options.limit || 20)) < (count || 0),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: matchesWithDetails,\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerMatches'),\n        success: false,\n        pagination: {\n          page: 1,\n          limit: options.limit || 20,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrevious: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Get detailed match information\n   */\n  async getMatchDetails(\n    matchId: string,\n    options: { userId?: string; includeAnalytics?: boolean } = {}\n  ): Promise<ServiceResponse<MatchWithDetails & { analytics?: MatchAnalytics }>> {\n    try {\n      const cacheKey = this.getCacheKey('getMatchDetails', { matchId, includeAnalytics: options.includeAnalytics });\n      const cached = this.getFromCache<any>(cacheKey);\n      \n      if (cached && !options.userId) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Get match with complete details\n      const { data: match, error: matchError } = await this.supabase\n        .from('matches')\n        .select(`\n          *,\n          home_team:teams!matches_home_team_id_fkey(*),\n          away_team:teams!matches_away_team_id_fkey(*),\n          league:leagues!inner(*),\n          match_events(*)\n        `)\n        .eq('id', matchId)\n        .single();\n\n      if (matchError) {\n        if (matchError.code === 'PGRST116') {\n          return {\n            data: null,\n            error: { code: 'MATCH_NOT_FOUND', message: 'Match not found', timestamp: new Date().toISOString() },\n            success: false\n          };\n        }\n        throw matchError;\n      }\n\n      // Get team players with profiles\n      const [homePlayers, awayPlayers] = await Promise.all([\n        this.supabase\n          .from('team_members')\n          .select(`\n            user_id,\n            position,\n            jersey_number,\n            users!inner(*)\n          `)\n          .eq('team_id', match.home_team_id)\n          .eq('is_active', true),\n        this.supabase\n          .from('team_members')\n          .select(`\n            user_id,\n            position,\n            jersey_number,\n            users!inner(*)\n          `)\n          .eq('team_id', match.away_team_id)\n          .eq('is_active', true)\n      ]);\n\n      if (homePlayers.error) throw homePlayers.error;\n      if (awayPlayers.error) throw awayPlayers.error;\n\n      // Calculate player stats if userId provided\n      let playerStats;\n      if (options.userId) {\n        playerStats = await this.calculateMatchPlayerStats(matchId, options.userId);\n      }\n\n      // Generate match analytics if requested\n      let analytics;\n      if (options.includeAnalytics) {\n        analytics = await this.generateMatchAnalytics(matchId);\n      }\n\n      const matchWithDetails: MatchWithDetails = {\n        ...match,\n        homeTeam: match.home_team,\n        awayTeam: match.away_team,\n        league: match.league,\n        events: match.match_events || [],\n        homeTeamPlayers: (homePlayers.data || []).map(p => p.users),\n        awayTeamPlayers: (awayPlayers.data || []).map(p => p.users),\n        playerStats: playerStats ? [playerStats] : undefined\n      };\n\n      const result = {\n        ...matchWithDetails,\n        analytics: analytics?.data || undefined\n      };\n\n      // Cache if not user-specific\n      if (!options.userId) {\n        this.setCache(cacheKey, result, match.status === 'live' ? 30 : 600);\n      }\n\n      return { data: result, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getMatchDetails'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get live match data with real-time updates\n   */\n  async getLiveMatchData(matchId: string): Promise<ServiceResponse<LiveMatchData>> {\n    try {\n      // Get match details first\n      const matchResponse = await this.getMatchDetails(matchId, { includeAnalytics: true });\n      if (!matchResponse.success || !matchResponse.data) {\n        throw new Error('Match not found');\n      }\n\n      const match = matchResponse.data;\n\n      // Get recent events (last 10 minutes)\n      const tenMinutesAgo = new Date(Date.now() - 10 * 60 * 1000);\n      const { data: recentEvents, error: eventsError } = await this.supabase\n        .from('match_events')\n        .select('*')\n        .eq('match_id', matchId)\n        .gte('created_at', tenMinutesAgo.toISOString())\n        .order('created_at', { ascending: false })\n        .limit(10);\n\n      if (eventsError) throw eventsError;\n\n      // Calculate live stats\n      const liveStats = await this.calculateLiveStats(matchId);\n\n      const liveMatchData: LiveMatchData = {\n        match,\n        recentEvents: recentEvents || [],\n        liveStats: liveStats.data || {\n          homeTeamStats: {},\n          awayTeamStats: {},\n          playerStats: {}\n        }\n      };\n\n      return { data: liveMatchData, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getLiveMatchData'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get active/live matches\n   */\n  async getActiveMatches(\n    filters: { leagueId?: string; sportType?: string } = {},\n    limit = 50\n  ): Promise<ServiceResponse<ActiveMatch[]>> {\n    try {\n      const cacheKey = this.getCacheKey('getActiveMatches', { filters, limit });\n      const cached = this.getFromCache<ActiveMatch[]>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      let query = this.supabase\n        .from('active_matches')\n        .select('*')\n        .limit(limit);\n\n      if (filters.leagueId) {\n        query = query.eq('league_id', filters.leagueId);\n      }\n\n      if (filters.sportType) {\n        query = query.eq('sport_type', filters.sportType);\n      }\n\n      const { data: activeMatches, error } = await query;\n\n      if (error) throw error;\n\n      // Cache for 1 minute (short cache for live data)\n      this.setCache(cacheKey, activeMatches || [], 60);\n\n      return { data: activeMatches || [], error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getActiveMatches'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get match predictions based on team and player statistics\n   */\n  async getMatchPrediction(matchId: string): Promise<ServiceResponse<MatchPrediction>> {\n    try {\n      const cacheKey = this.getCacheKey('getMatchPrediction', { matchId });\n      const cached = this.getFromCache<MatchPrediction>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Get match details\n      const matchResponse = await this.getMatchDetails(matchId);\n      if (!matchResponse.success || !matchResponse.data) {\n        throw new Error('Match not found');\n      }\n\n      const match = matchResponse.data;\n\n      // Get team statistics\n      const [homeTeamStats, awayTeamStats] = await Promise.all([\n        this.supabase\n          .from('team_stats')\n          .select('*')\n          .eq('team_id', match.homeTeam.id)\n          .eq('league_id', match.league_id)\n          .single(),\n        this.supabase\n          .from('team_stats')\n          .select('*')\n          .eq('team_id', match.awayTeam.id)\n          .eq('league_id', match.league_id)\n          .single()\n      ]);\n\n      // Calculate prediction probabilities using simple algorithm\n      const prediction = this.calculateMatchPrediction(\n        homeTeamStats.data,\n        awayTeamStats.data,\n        match\n      );\n\n      // Cache for 24 hours\n      this.setCache(cacheKey, prediction, 86400);\n\n      return { data: prediction, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getMatchPrediction'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get player's performance metrics for a specific match\n   */\n  async getPlayerMatchPerformance(\n    matchId: string,\n    playerId: string\n  ): Promise<ServiceResponse<PlayerMatchStats>> {\n    try {\n      const cacheKey = this.getCacheKey('getPlayerMatchPerformance', { matchId, playerId });\n      const cached = this.getFromCache<PlayerMatchStats>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      const playerStats = await this.calculateMatchPlayerStats(matchId, playerId);\n      \n      if (!playerStats) {\n        return {\n          data: null,\n          error: { code: 'PLAYER_NOT_IN_MATCH', message: 'Player not found in this match', timestamp: new Date().toISOString() },\n          success: false\n        };\n      }\n\n      // Cache for 30 minutes\n      this.setCache(cacheKey, playerStats, 1800);\n\n      return { data: playerStats, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerMatchPerformance'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n  private async calculateMatchPlayerStats(matchId: string, playerId: string): Promise<PlayerMatchStats | null> {\n    // Get player profile\n    const { data: player, error: playerError } = await this.supabase\n      .from('users')\n      .select('display_name')\n      .eq('id', playerId)\n      .single();\n\n    if (playerError || !player) return null;\n\n    // Get player's events in this match\n    const { data: events, error: eventsError } = await this.supabase\n      .from('match_events')\n      .select('*')\n      .eq('match_id', matchId)\n      .eq('player_id', playerId)\n      .order('event_time', { ascending: true });\n\n    if (eventsError) return null;\n\n    // Calculate stats from events\n    const stats = (events || []).reduce(\n      (acc, event) => {\n        switch (event.event_type) {\n          case 'goal':\n            acc.goals++;\n            break;\n          case 'assist':\n            acc.assists++;\n            break;\n          case 'yellow_card':\n            acc.yellowCards++;\n            break;\n          case 'red_card':\n            acc.redCards++;\n            break;\n        }\n        return acc;\n      },\n      {\n        goals: 0,\n        assists: 0,\n        yellowCards: 0,\n        redCards: 0\n      }\n    );\n\n    // Calculate performance rating (simplified)\n    const performance = {\n      rating: Math.min(10, Math.max(1, \n        5 + (stats.goals * 2) + (stats.assists * 1.5) - (stats.yellowCards * 0.5) - (stats.redCards * 2)\n      )),\n      keyPasses: 0, // Would need more detailed event tracking\n      successfulPasses: 0,\n      totalPasses: 0,\n      tackles: 0,\n      saves: undefined\n    };\n\n    return {\n      matchId,\n      playerId,\n      playerName: player.display_name,\n      goals: stats.goals,\n      assists: stats.assists,\n      yellowCards: stats.yellowCards,\n      redCards: stats.redCards,\n      minutesPlayed: 90, // Simplified - would need substitution tracking\n      events: events || [],\n      performance\n    };\n  }\n\n  private async calculateLiveStats(matchId: string): Promise<ServiceResponse<{\n    homeTeamStats: { [key: string]: number };\n    awayTeamStats: { [key: string]: number };\n    playerStats: { [playerId: string]: any };\n  }>> {\n    try {\n      // Get all match events\n      const { data: events, error } = await this.supabase\n        .from('match_events')\n        .select('*')\n        .eq('match_id', matchId);\n\n      if (error) throw error;\n\n      const homeTeamStats: { [key: string]: number } = {};\n      const awayTeamStats: { [key: string]: number } = {};\n      const playerStats: { [playerId: string]: any } = {};\n\n      // Process events to calculate live stats\n      (events || []).forEach(event => {\n        // Team stats\n        const isHomeTeam = event.team_id === 'home'; // This would need proper team ID checking\n        const teamStats = isHomeTeam ? homeTeamStats : awayTeamStats;\n        \n        teamStats[event.event_type] = (teamStats[event.event_type] || 0) + 1;\n\n        // Player stats\n        if (event.player_id) {\n          if (!playerStats[event.player_id]) {\n            playerStats[event.player_id] = {};\n          }\n          playerStats[event.player_id][event.event_type] = \n            (playerStats[event.player_id][event.event_type] || 0) + 1;\n        }\n      });\n\n      return {\n        data: { homeTeamStats, awayTeamStats, playerStats },\n        error: null,\n        success: true\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'calculateLiveStats'),\n        success: false\n      };\n    }\n  }\n\n  private async generateMatchAnalytics(matchId: string): Promise<ServiceResponse<MatchAnalytics>> {\n    try {\n      const { data: match, error: matchError } = await this.supabase\n        .from('matches')\n        .select('*')\n        .eq('id', matchId)\n        .single();\n\n      if (matchError) throw matchError;\n\n      const { data: events, error: eventsError } = await this.supabase\n        .from('match_events')\n        .select('*')\n        .eq('match_id', matchId)\n        .order('event_time', { ascending: true });\n\n      if (eventsError) throw eventsError;\n\n      // Calculate analytics\n      const analytics: MatchAnalytics = {\n        matchId,\n        duration: match.match_duration || 90,\n        totalEvents: events?.length || 0,\n        goalsByPeriod: this.calculateGoalsByPeriod(events || []),\n        cardsByTeam: this.calculateCardsByTeam(events || []),\n        topPerformers: {\n          home: [],\n          away: []\n        },\n        matchMomentum: this.calculateMatchMomentum(events || [])\n      };\n\n      return { data: analytics, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'generateMatchAnalytics'),\n        success: false\n      };\n    }\n  }\n\n  private calculateMatchPrediction(\n    homeStats: any,\n    awayStats: any,\n    match: MatchWithDetails\n  ): MatchPrediction {\n    // Simplified prediction algorithm\n    const homeForm = homeStats ? (homeStats.wins || 0) / Math.max(homeStats.games_played || 1, 1) : 0.5;\n    const awayForm = awayStats ? (awayStats.wins || 0) / Math.max(awayStats.games_played || 1, 1) : 0.5;\n    \n    const homeAttack = homeStats ? (homeStats.goals_for || 0) / Math.max(homeStats.games_played || 1, 1) : 1;\n    const awayAttack = awayStats ? (awayStats.goals_for || 0) / Math.max(awayStats.games_played || 1, 1) : 1;\n    \n    // Simple probability calculation\n    const totalStrength = homeForm + awayForm + 0.1; // Add small constant to avoid division by zero\n    const homeWinProbability = Math.round(((homeForm + 0.1) / totalStrength) * 100);\n    const awayWinProbability = Math.round(((awayForm + 0.1) / totalStrength) * 100);\n    const drawProbability = 100 - homeWinProbability - awayWinProbability;\n\n    return {\n      matchId: match.id,\n      homeWinProbability,\n      drawProbability,\n      awayWinProbability,\n      expectedGoalsHome: Number(homeAttack.toFixed(1)),\n      expectedGoalsAway: Number(awayAttack.toFixed(1)),\n      keyFactors: [\n        `${match.homeTeam.name} home advantage`,\n        `Recent form comparison`,\n        `Head-to-head record`\n      ],\n      confidence: 75\n    };\n  }\n\n  private calculateGoalsByPeriod(events: MatchEvent[]) {\n    return events.reduce(\n      (acc, event) => {\n        if (event.event_type === 'goal' && event.event_time !== null) {\n          if (event.event_time <= 45) {\n            // Would need team determination logic\n            acc.firstHalf.home++;\n          } else if (event.event_time <= 90) {\n            acc.secondHalf.home++;\n          }\n        }\n        return acc;\n      },\n      {\n        firstHalf: { home: 0, away: 0 },\n        secondHalf: { home: 0, away: 0 }\n      }\n    );\n  }\n\n  private calculateCardsByTeam(events: MatchEvent[]) {\n    return {\n      home: { yellow: 0, red: 0 },\n      away: { yellow: 0, red: 0 }\n    };\n  }\n\n  private calculateMatchMomentum(events: MatchEvent[]) {\n    return events.map((event, index) => ({\n      minute: event.event_time || 0,\n      homeScore: 0, // Would need proper score tracking\n      awayScore: 0,\n      eventType: event.event_type as EventType,\n      momentum: 0 // Would need momentum calculation algorithm\n    }));\n  }\n\n  /**\n   * Subscribe to real-time match updates\n   */\n  subscribeToMatchUpdates(\n    matchId: string,\n    callback: (payload: any) => void,\n    options: RealtimeSubscriptionOptions = { table: 'match_events', event: '*' }\n  ) {\n    return this.supabase\n      .channel(`match-${matchId}-updates`)\n      .on(\n        'postgres_changes',\n        {\n          event: options.event,\n          schema: options.schema || 'public',\n          table: options.table,\n          filter: options.filter || `match_id=eq.${matchId}`\n        },\n        callback\n      )\n      .subscribe();\n  }\n\n  /**\n   * Create a new match between two teams\n   */\n  async createMatch(data: {\n    homeTeamId: string;\n    awayTeamId: string;\n    matchDate: string;\n    venue?: string;\n    leagueId?: string;\n    matchType?: 'friendly' | 'league' | 'tournament' | 'regular_season';\n  }): Promise<ServiceResponse<any>> {\n    try {\n      console.log(' MatchService.createMatch:', data);\n\n      // Validate teams exist and are different\n      const { data: teams, error: teamsError } = await this.supabase\n        .from('teams')\n        .select('id, name')\n        .in('id', [data.homeTeamId, data.awayTeamId]);\n\n      if (teamsError) throw teamsError;\n\n      if (!teams || teams.length !== 2) {\n        return {\n          data: null,\n          error: { code: 'INVALID_TEAMS', message: 'One or both teams do not exist', timestamp: new Date().toISOString() },\n          success: false\n        };\n      }\n\n      // Create the match\n      const { data: match, error: matchError } = await this.supabase\n        .from('matches')\n        .insert({\n          home_team_id: data.homeTeamId,\n          away_team_id: data.awayTeamId,\n          match_date: data.matchDate,\n          scheduled_date: data.matchDate,\n          venue: data.venue || 'TBD',\n          league_id: data.leagueId || null,\n          match_type: data.matchType || 'friendly',\n          status: 'scheduled'\n        })\n        .select(`\n          *,\n          home_team:teams!matches_home_team_id_fkey(*),\n          away_team:teams!matches_away_team_id_fkey(*),\n          league:leagues(*)\n        `)\n        .single();\n\n      if (matchError) throw matchError;\n\n      // Clear cache\n      this.clearCache('getPlayerMatches');\n      this.clearCache('getActiveMatches');\n\n      return { data: match, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'createMatch'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Update match score and status\n   */\n  async updateMatchScore(\n    matchId: string, \n    data: {\n      homeScore: number;\n      awayScore: number;\n      status?: MatchStatus;\n      duration?: number;\n      notes?: string;\n    }\n  ): Promise<ServiceResponse<any>> {\n    try {\n      console.log(' MatchService.updateMatchScore:', matchId, data);\n\n      const updateData: any = {\n        home_score: data.homeScore,\n        away_score: data.awayScore,\n        updated_at: new Date().toISOString()\n      };\n\n      if (data.status) {\n        updateData.status = data.status;\n      }\n\n      if (data.duration !== undefined) {\n        updateData.match_duration = data.duration;\n      }\n\n      if (data.notes !== undefined) {\n        updateData.notes = data.notes;\n      }\n\n      const { data: match, error: updateError } = await this.supabase\n        .from('matches')\n        .update(updateData)\n        .eq('id', matchId)\n        .select(`\n          *,\n          home_team:teams!matches_home_team_id_fkey(*),\n          away_team:teams!matches_away_team_id_fkey(*),\n          league:leagues(*)\n        `)\n        .single();\n\n      if (updateError) throw updateError;\n\n      // Clear cache\n      this.clearCache('getPlayerMatches');\n      this.clearCache('getMatchDetails');\n      this.clearCache('getActiveMatches');\n\n      return { data: match, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'updateMatchScore'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get match participants\n   */\n  async getMatchParticipants(matchId: string): Promise<ServiceResponse<{\n    homeTeam: { id: string; name: string; participants: any[] };\n    awayTeam: { id: string; name: string; participants: any[] };\n  }>> {\n    try {\n      console.log(' MatchService.getMatchParticipants:', matchId);\n\n      const cacheKey = this.getCacheKey('getMatchParticipants', { matchId });\n      const cached = this.getFromCache<any>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Get match details\n      const { data: match, error: matchError } = await this.supabase\n        .from('matches')\n        .select(`\n          id,\n          home_team_id,\n          away_team_id,\n          home_team:teams!matches_home_team_id_fkey(id, name, team_color),\n          away_team:teams!matches_away_team_id_fkey(id, name, team_color)\n        `)\n        .eq('id', matchId)\n        .single();\n\n      if (matchError) throw matchError;\n\n      // Get participants\n      const { data: participants, error: participantsError } = await this.supabase\n        .from('match_participants')\n        .select(`\n          *,\n          user:user_profiles(id, display_name, full_name, avatar_url, preferred_position)\n        `)\n        .eq('match_id', matchId)\n        .order('jersey_number', { ascending: true });\n\n      if (participantsError) throw participantsError;\n\n      // Group by team\n      const homeParticipants = participants?.filter(p => p.team_id === match.home_team_id) || [];\n      const awayParticipants = participants?.filter(p => p.team_id === match.away_team_id) || [];\n\n      const result = {\n        homeTeam: {\n          ...match.home_team,\n          participants: homeParticipants.map(p => ({\n            id: p.id,\n            userId: p.user_id,\n            position: p.position,\n            jerseyNumber: p.jersey_number,\n            isStarter: p.is_starter,\n            isCaptain: p.is_captain,\n            selectedAt: p.selected_at,\n            player: p.user\n          }))\n        },\n        awayTeam: {\n          ...match.away_team,\n          participants: awayParticipants.map(p => ({\n            id: p.id,\n            userId: p.user_id,\n            position: p.position,\n            jerseyNumber: p.jersey_number,\n            isStarter: p.is_starter,\n            isCaptain: p.is_captain,\n            selectedAt: p.selected_at,\n            player: p.user\n          }))\n        }\n      };\n\n      // Cache for 5 minutes\n      this.setCache(cacheKey, result, 300);\n\n      return { data: result, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getMatchParticipants'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Add participant to match\n   */\n  async addMatchParticipant(data: {\n    matchId: string;\n    teamId: string;\n    userId: string;\n    position?: string;\n    jerseyNumber?: number;\n    isStarter?: boolean;\n    isCaptain?: boolean;\n  }): Promise<ServiceResponse<any>> {\n    try {\n      console.log(' MatchService.addMatchParticipant:', data);\n\n      const { data: participant, error } = await this.supabase\n        .from('match_participants')\n        .upsert({\n          match_id: data.matchId,\n          team_id: data.teamId,\n          user_id: data.userId,\n          position: data.position || null,\n          jersey_number: data.jerseyNumber || null,\n          is_starter: data.isStarter || false,\n          is_captain: data.isCaptain || false\n        }, {\n          onConflict: 'match_id,user_id'\n        })\n        .select(`\n          *,\n          user:user_profiles(id, display_name, full_name)\n        `)\n        .single();\n\n      if (error) throw error;\n\n      // Clear cache\n      this.clearCache('getMatchParticipants');\n\n      return { data: participant, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'addMatchParticipant'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Remove participant from match\n   */\n  async removeMatchParticipant(participantId: string): Promise<ServiceResponse<void>> {\n    try {\n      console.log(' MatchService.removeMatchParticipant:', participantId);\n\n      const { error } = await this.supabase\n        .from('match_participants')\n        .delete()\n        .eq('id', participantId);\n\n      if (error) throw error;\n\n      // Clear cache\n      this.clearCache('getMatchParticipants');\n\n      return { data: null, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'removeMatchParticipant'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Clear cache\n   */\n  clearCache(pattern?: string): void {\n    if (!pattern) {\n      this.cache.clear();\n      return;\n    }\n\n    const keys = Array.from(this.cache.keys());\n    keys.forEach(key => {\n      if (key.includes(pattern)) {\n        this.cache.delete(key);\n      }\n    });\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2418, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/season.service.ts"],"sourcesContent":["/**\n * Season Service for MatchDay\n * \n * Handles season management operations including:\n * - Season creation and management\n * - Team registration for seasons\n * - Match scheduling and fixture generation\n * - Season statistics and standings\n */\n\nimport { SupabaseClient } from '@supabase/supabase-js';\n\nexport interface Season {\n  id: string;\n  name: string;\n  league_id: string;\n  season_year: number;\n  display_name?: string;\n  status: 'draft' | 'registration' | 'active' | 'completed' | 'cancelled';\n  tournament_format: 'league' | 'knockout' | 'hybrid';\n  start_date: string;\n  end_date: string;\n  registration_deadline?: string;\n  match_frequency?: number;\n  preferred_match_time?: string;\n  min_teams?: number;\n  max_teams?: number;\n  registered_teams_count?: number;\n  rounds?: number;\n  points_for_win?: number;\n  points_for_draw?: number;\n  points_for_loss?: number;\n  allow_draws?: boolean;\n  home_away_balance?: boolean;\n  fixtures_status: 'pending' | 'generating' | 'completed' | 'error';\n  fixtures_generated_at?: string;\n  total_matches_planned?: number;\n  rules?: any;\n  settings?: any;\n  metadata?: any;\n  created_at: string;\n  updated_at: string;\n  created_by?: string;\n  updated_by?: string;\n}\n\nexport interface SeasonTeam {\n  id: string;\n  season_id: string;\n  team_id: string;\n  registration_date: string;\n  status: 'registered' | 'confirmed' | 'withdrawn';\n  team?: {\n    id: string;\n    name: string;\n    team_color?: string;\n    captain_id?: string;\n  };\n}\n\nexport interface Match {\n  id: string;\n  season_id: string;\n  home_team_id: string;\n  away_team_id: string;\n  match_date?: string;\n  round_number?: number;\n  status: 'scheduled' | 'in_progress' | 'completed' | 'cancelled';\n  home_score?: number;\n  away_score?: number;\n  venue?: string;\n  home_team?: {\n    id: string;\n    name: string;\n    team_color?: string;\n  };\n  away_team?: {\n    id: string;\n    name: string;\n    team_color?: string;\n  };\n}\n\nexport interface ServiceResponse<T> {\n  data: T | null;\n  error: any | null;\n  success: boolean;\n  message?: string;\n}\n\nexport class SeasonService {\n  private static instance: SeasonService;\n  private supabase: SupabaseClient;\n\n  private constructor(supabaseClient: SupabaseClient) {\n    this.supabase = supabaseClient;\n  }\n\n  static getInstance(supabaseClient?: SupabaseClient): SeasonService {\n    if (!SeasonService.instance) {\n      if (!supabaseClient) {\n        throw new Error('SupabaseClient required for first initialization');\n      }\n      SeasonService.instance = new SeasonService(supabaseClient);\n    }\n    return SeasonService.instance;\n  }\n\n  /**\n   * Get all seasons for a league\n   */\n  async getSeasonsByLeague(leagueId: string): Promise<ServiceResponse<Season[]>> {\n    try {\n      const { data: seasons, error } = await this.supabase\n        .from('seasons')\n        .select('*')\n        .eq('league_id', leagueId)\n        .order('season_year', { ascending: false });\n\n      if (error) throw error;\n\n      return {\n        data: seasons || [],\n        error: null,\n        success: true,\n        message: 'Seasons retrieved successfully'\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error,\n        success: false,\n        message: 'Failed to get seasons'\n      };\n    }\n  }\n\n  /**\n   * Get season details with teams\n   */\n  async getSeasonDetails(seasonId: string): Promise<ServiceResponse<Season & { teams?: SeasonTeam[] }>> {\n    try {\n      const { data: season, error } = await this.supabase\n        .from('seasons')\n        .select(`\n          *,\n          season_teams (\n            id,\n            team_id,\n            registration_date,\n            status,\n            team:teams (\n              id,\n              name,\n              team_color,\n              captain_id\n            )\n          )\n        `)\n        .eq('id', seasonId)\n        .single();\n\n      if (error) {\n        if (error.code === 'PGRST116') {\n          return {\n            data: null,\n            error: { code: 'SEASON_NOT_FOUND', message: 'Season not found' },\n            success: false\n          };\n        }\n        throw error;\n      }\n\n      return {\n        data: {\n          ...season,\n          teams: season.season_teams || []\n        },\n        error: null,\n        success: true,\n        message: 'Season details retrieved successfully'\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error,\n        success: false,\n        message: 'Failed to get season details'\n      };\n    }\n  }\n\n  /**\n   * Create a new season\n   */\n  async createSeason(seasonData: Partial<Season>): Promise<ServiceResponse<Season>> {\n    try {\n      const { data: season, error } = await this.supabase\n        .from('seasons')\n        .insert([{\n          name: seasonData.name,\n          league_id: seasonData.league_id,\n          season_year: seasonData.season_year || new Date().getFullYear(),\n          display_name: seasonData.display_name || seasonData.name,\n          status: seasonData.status || 'draft',\n          tournament_format: seasonData.tournament_format || 'league',\n          start_date: seasonData.start_date,\n          end_date: seasonData.end_date,\n          registration_deadline: seasonData.registration_deadline,\n          match_frequency: seasonData.match_frequency || 7,\n          preferred_match_time: seasonData.preferred_match_time || '15:00:00',\n          min_teams: seasonData.min_teams || 2,\n          max_teams: seasonData.max_teams,\n          rounds: seasonData.rounds || 1,\n          points_for_win: seasonData.points_for_win || 3,\n          points_for_draw: seasonData.points_for_draw || 1,\n          points_for_loss: seasonData.points_for_loss || 0,\n          allow_draws: seasonData.allow_draws !== false,\n          home_away_balance: seasonData.home_away_balance !== false,\n          rules: seasonData.rules || {},\n          settings: seasonData.settings || {},\n          metadata: seasonData.metadata || {}\n        }])\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      return {\n        data: season,\n        error: null,\n        success: true,\n        message: 'Season created successfully'\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error,\n        success: false,\n        message: 'Failed to create season'\n      };\n    }\n  }\n\n  /**\n   * Update season\n   */\n  async updateSeason(seasonId: string, updates: Partial<Season>): Promise<ServiceResponse<Season>> {\n    try {\n      const { data: season, error } = await this.supabase\n        .from('seasons')\n        .update({\n          ...updates,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', seasonId)\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      return {\n        data: season,\n        error: null,\n        success: true,\n        message: 'Season updated successfully'\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error,\n        success: false,\n        message: 'Failed to update season'\n      };\n    }\n  }\n\n  /**\n   * Register team for season\n   */\n  async registerTeamForSeason(seasonId: string, teamId: string): Promise<ServiceResponse<SeasonTeam>> {\n    try {\n      // Check if team is already registered\n      const { data: existing, error: checkError } = await this.supabase\n        .from('season_teams')\n        .select('id')\n        .eq('season_id', seasonId)\n        .eq('team_id', teamId)\n        .single();\n\n      if (checkError && checkError.code !== 'PGRST116') throw checkError;\n\n      if (existing) {\n        return {\n          data: null,\n          error: { code: 'ALREADY_REGISTERED', message: 'Team is already registered for this season' },\n          success: false\n        };\n      }\n\n      // Register the team\n      const { data: registration, error } = await this.supabase\n        .from('season_teams')\n        .insert([{\n          season_id: seasonId,\n          team_id: teamId,\n          registration_date: new Date().toISOString(),\n          status: 'registered'\n        }])\n        .select(`\n          *,\n          team:teams (\n            id,\n            name,\n            team_color,\n            captain_id\n          )\n        `)\n        .single();\n\n      if (error) throw error;\n\n      // Update registered teams count\n      await this.updateRegisteredTeamsCount(seasonId);\n\n      return {\n        data: registration,\n        error: null,\n        success: true,\n        message: 'Team registered for season successfully'\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error,\n        success: false,\n        message: 'Failed to register team for season'\n      };\n    }\n  }\n\n  /**\n   * Generate round-robin fixtures for a season\n   */\n  async generateFixtures(seasonId: string): Promise<ServiceResponse<Match[]>> {\n    try {\n      // Get season details\n      const seasonResponse = await this.getSeasonDetails(seasonId);\n      if (!seasonResponse.success || !seasonResponse.data) {\n        throw new Error('Season not found');\n      }\n\n      const season = seasonResponse.data;\n      const teams = season.teams?.filter(t => t.status === 'registered' || t.status === 'confirmed') || [];\n\n      if (teams.length < 2) {\n        return {\n          data: null,\n          error: { code: 'INSUFFICIENT_TEAMS', message: 'Need at least 2 teams to generate fixtures' },\n          success: false\n        };\n      }\n\n      // Update fixtures status to generating\n      await this.updateSeason(seasonId, { \n        fixtures_status: 'generating',\n        total_matches_planned: this.calculateTotalMatches(teams.length, season.rounds || 1, season.home_away_balance || false)\n      });\n\n      // Generate round-robin fixtures\n      const fixtures = this.generateRoundRobinFixtures(teams, season.rounds || 1, season.home_away_balance || false);\n      \n      // Calculate match dates based on season start date and frequency\n      const fixturesWithDates = this.assignMatchDates(fixtures, season);\n\n      // Clear existing fixtures for this season\n      await this.supabase\n        .from('matches')\n        .delete()\n        .eq('season_id', seasonId);\n\n      // Insert new fixtures\n      const { data: matches, error } = await this.supabase\n        .from('matches')\n        .insert(fixturesWithDates.map(fixture => ({\n          season_id: seasonId,\n          home_team_id: fixture.home_team_id,\n          away_team_id: fixture.away_team_id,\n          match_date: fixture.match_date,\n          status: 'scheduled'\n        })))\n        .select(`\n          *,\n          home_team:teams!matches_home_team_id_fkey (\n            id,\n            name,\n            team_color\n          ),\n          away_team:teams!matches_away_team_id_fkey (\n            id,\n            name,\n            team_color\n          )\n        `);\n\n      if (error) throw error;\n\n      // Update fixtures status to completed\n      await this.updateSeason(seasonId, { \n        fixtures_status: 'completed',\n        fixtures_generated_at: new Date().toISOString()\n      });\n\n      return {\n        data: matches || [],\n        error: null,\n        success: true,\n        message: 'Fixtures generated successfully'\n      };\n    } catch (error) {\n      // Update fixtures status to error\n      await this.updateSeason(seasonId, { \n        fixtures_status: 'error',\n        fixtures_generation_error: error instanceof Error ? error.message : 'Unknown error'\n      });\n\n      return {\n        data: null,\n        error,\n        success: false,\n        message: 'Failed to generate fixtures'\n      };\n    }\n  }\n\n  /**\n   * Get matches for a season\n   */\n  async getSeasonMatches(seasonId: string): Promise<ServiceResponse<Match[]>> {\n    try {\n      const { data: matches, error } = await this.supabase\n        .from('matches')\n        .select(`\n          *,\n          home_team:teams!matches_home_team_id_fkey (\n            id,\n            name,\n            team_color\n          ),\n          away_team:teams!matches_away_team_id_fkey (\n            id,\n            name,\n            team_color\n          )\n        `)\n        .eq('season_id', seasonId)\n        .order('match_date', { ascending: true });\n\n      if (error) throw error;\n\n      return {\n        data: matches || [],\n        error: null,\n        success: true,\n        message: 'Season matches retrieved successfully'\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error,\n        success: false,\n        message: 'Failed to get season matches'\n      };\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n  private async updateRegisteredTeamsCount(seasonId: string): Promise<void> {\n    const { count } = await this.supabase\n      .from('season_teams')\n      .select('*', { count: 'exact', head: true })\n      .eq('season_id', seasonId)\n      .in('status', ['registered', 'confirmed']);\n\n    await this.supabase\n      .from('seasons')\n      .update({ registered_teams_count: count || 0 })\n      .eq('id', seasonId);\n  }\n\n  private calculateTotalMatches(teamsCount: number, rounds: number, homeAndAway: boolean): number {\n    const matchesPerRound = (teamsCount * (teamsCount - 1)) / 2;\n    const multiplier = homeAndAway ? 2 : 1;\n    return matchesPerRound * rounds * multiplier;\n  }\n\n  private generateRoundRobinFixtures(teams: SeasonTeam[], rounds: number, homeAndAway: boolean): Array<{\n    home_team_id: string;\n    away_team_id: string;\n    round_number: number;\n  }> {\n    const fixtures: Array<{\n      home_team_id: string;\n      away_team_id: string;\n      round_number: number;\n    }> = [];\n\n    for (let round = 1; round <= rounds; round++) {\n      // Generate all possible pairings\n      for (let i = 0; i < teams.length; i++) {\n        for (let j = i + 1; j < teams.length; j++) {\n          fixtures.push({\n            home_team_id: teams[i].team_id,\n            away_team_id: teams[j].team_id,\n            round_number: round\n          });\n\n          // Add reverse fixture if home and away\n          if (homeAndAway) {\n            fixtures.push({\n              home_team_id: teams[j].team_id,\n              away_team_id: teams[i].team_id,\n              round_number: round\n            });\n          }\n        }\n      }\n    }\n\n    return fixtures;\n  }\n\n  private assignMatchDates(fixtures: Array<{\n    home_team_id: string;\n    away_team_id: string;\n    round_number: number;\n  }>, season: Season): Array<{\n    home_team_id: string;\n    away_team_id: string;\n    round_number: number;\n    match_date: string;\n  }> {\n    const startDate = new Date(season.start_date);\n    const matchFrequencyDays = season.match_frequency || 7;\n    const preferredTime = season.preferred_match_time || '15:00:00';\n\n    return fixtures.map((fixture, index) => {\n      const dayOffset = Math.floor(index / 2) * matchFrequencyDays; // 2 matches per day\n      const matchDate = new Date(startDate);\n      matchDate.setDate(matchDate.getDate() + dayOffset);\n      \n      return {\n        ...fixture,\n        match_date: `${matchDate.toISOString().split('T')[0]}T${preferredTime}Z`\n      };\n    });\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2814, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/player.service.ts"],"sourcesContent":["/**\n * Enhanced Player Service for MatchDay\n * \n * Handles comprehensive player-related operations with focus on:\n * - Player profiles and cross-league statistics\n * - Achievement tracking and progress\n * - Performance analytics and rankings\n * - Team memberships and join requests\n * \n * Optimized for amateur sports leagues with proper error handling,\n * caching strategies, and real-time updates.\n */\n\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport { \n  Database, \n  UserProfile, \n  PlayerStats, \n  PlayerProfileExtended, \n  PlayerCrossLeagueStats,\n  ServiceResponse,\n  ServiceError,\n  PaginatedServiceResponse,\n  TeamJoinRequest,\n  JoinRequestStatus,\n  Achievement,\n  UserAchievement,\n  CacheOptions,\n  RealtimeSubscriptionOptions\n} from '@/lib/types/database.types';\n\nexport class PlayerService {\n  private static instance: PlayerService;\n  private supabase: SupabaseClient<Database>;\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n\n  private constructor(supabaseClient: SupabaseClient<Database>) {\n    this.supabase = supabaseClient;\n  }\n\n  static getInstance(supabaseClient?: SupabaseClient<Database>): PlayerService {\n    if (!PlayerService.instance) {\n      if (!supabaseClient) {\n        throw new Error('SupabaseClient required for first initialization');\n      }\n      PlayerService.instance = new PlayerService(supabaseClient);\n    }\n    return PlayerService.instance;\n  }\n\n  /**\n   * Handle service errors consistently\n   */\n  private handleError(error: any, operation: string): ServiceError {\n    console.error(`PlayerService.${operation}:`, error);\n    return {\n      code: error.code || 'UNKNOWN_ERROR',\n      message: error.message || 'An unexpected error occurred',\n      details: error.details || error,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Cache management utilities\n   */\n  private getCacheKey(operation: string, params: any): string {\n    return `player_service:${operation}:${JSON.stringify(params)}`;\n  }\n\n  private getFromCache<T>(key: string): T | null {\n    const cached = this.cache.get(key);\n    if (!cached) return null;\n    \n    if (Date.now() - cached.timestamp > cached.ttl * 1000) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return cached.data as T;\n  }\n\n  private setCache<T>(key: string, data: T, ttl = 300): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl\n    });\n  }\n\n  /**\n   * Get comprehensive player profile with all related data\n   */\n  async getPlayerProfile(userId: string, options: CacheOptions = {}): Promise<ServiceResponse<PlayerProfileExtended>> {\n    try {\n      const cacheKey = this.getCacheKey('getPlayerProfile', { userId });\n      const cached = this.getFromCache<PlayerProfileExtended>(cacheKey);\n      \n      if (cached && !options.revalidateOnBackground) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Get basic profile\n      const { data: profile, error: profileError } = await this.supabase\n        .from('users')\n        .select('*')\n        .eq('id', userId)\n        .single();\n\n      if (profileError) {\n        if (profileError.code === 'PGRST116') {\n          return { \n            data: null, \n            error: { code: 'PLAYER_NOT_FOUND', message: 'Player not found', timestamp: new Date().toISOString() }, \n            success: false \n          };\n        }\n        throw profileError;\n      }\n\n      // Get team memberships with league details\n      const { data: teamMemberships, error: teamsError } = await this.supabase\n        .from('team_members')\n        .select(`\n          *,\n          team:teams!inner(\n            *,\n            league:leagues!inner(*)\n          )\n        `)\n        .eq('user_id', userId)\n        .eq('is_active', true);\n\n      if (teamsError) throw teamsError;\n\n      // Get achievements\n      const { data: userAchievements, error: achievementsError } = await this.supabase\n        .from('user_achievements')\n        .select(`\n          *,\n          achievement:achievements!inner(*)\n        `)\n        .eq('user_id', userId)\n        .order('earned_at', { ascending: false });\n\n      if (achievementsError) throw achievementsError;\n\n      // Get cross-league stats\n      const { data: crossLeagueStats, error: crossStatsError } = await this.supabase\n        .from('player_cross_league_stats')\n        .select('*')\n        .eq('player_id', userId)\n        .eq('season_year', new Date().getFullYear())\n        .single();\n\n      // Don't throw error if no cross-league stats exist\n      if (crossStatsError && crossStatsError.code !== 'PGRST116') {\n        throw crossStatsError;\n      }\n\n      // Get global rankings\n      const globalRankings = await this.getPlayerGlobalRankings(userId);\n\n      const playerProfile: PlayerProfileExtended = {\n        ...profile,\n        teams: teamMemberships?.map(tm => ({\n          team: tm.team as any,\n          membership: tm\n        })) || [],\n        achievements: userAchievements?.map(ua => ({\n          achievement: ua.achievement as Achievement,\n          userAchievement: ua\n        })) || [],\n        crossLeagueStats: crossLeagueStats || null,\n        globalRankings: globalRankings.data || {\n          goals: null,\n          assists: null,\n          matches: null\n        }\n      };\n\n      // Cache the result\n      this.setCache(cacheKey, playerProfile, options.ttl || 300);\n\n      return { data: playerProfile, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerProfile'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Update player profile information\n   */\n  async updatePlayerProfile(\n    userId: string, \n    updates: Partial<Database['public']['Tables']['user_profiles']['Update']>\n  ): Promise<ServiceResponse<UserProfile>> {\n    try {\n      const { data, error } = await this.supabase\n        .from('users')\n        .update({\n          ...updates,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', userId)\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      // Invalidate cache\n      const cacheKey = this.getCacheKey('getPlayerProfile', { userId });\n      this.cache.delete(cacheKey);\n\n      return { data, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'updatePlayerProfile'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get player's cross-league statistics aggregation\n   */\n  async getCrossLeagueStats(userId: string, seasonYear?: number): Promise<ServiceResponse<PlayerCrossLeagueStats>> {\n    try {\n      const year = seasonYear || new Date().getFullYear();\n      const cacheKey = this.getCacheKey('getCrossLeagueStats', { userId, year });\n      const cached = this.getFromCache<PlayerCrossLeagueStats>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      const { data, error } = await this.supabase\n        .from('player_cross_league_stats')\n        .select('*')\n        .eq('player_id', userId)\n        .eq('season_year', year)\n        .single();\n\n      if (error && error.code !== 'PGRST116') throw error;\n\n      // Cache for 10 minutes\n      this.setCache(cacheKey, data, 600);\n\n      return { data: data || null, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getCrossLeagueStats'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get player's global rankings across different stats\n   */\n  async getPlayerGlobalRankings(userId: string): Promise<ServiceResponse<{\n    goals: { rank: number; total: number; percentile: number } | null;\n    assists: { rank: number; total: number; percentile: number } | null;\n    matches: { rank: number; total: number; percentile: number } | null;\n  }>> {\n    try {\n      const cacheKey = this.getCacheKey('getPlayerGlobalRankings', { userId });\n      const cached = this.getFromCache<any>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Get rankings for different stats using stored procedures\n      const [goalsRank, assistsRank, matchesRank] = await Promise.allSettled([\n        this.supabase.rpc('get_player_global_rank', { \n          player_id: userId, \n          stat_column: 'total_goals' \n        }),\n        this.supabase.rpc('get_player_global_rank', { \n          player_id: userId, \n          stat_column: 'total_assists' \n        }),\n        this.supabase.rpc('get_player_global_rank', { \n          player_id: userId, \n          stat_column: 'total_games_played' \n        })\n      ]);\n\n      const rankings = {\n        goals: goalsRank.status === 'fulfilled' && goalsRank.value.data ? {\n          rank: goalsRank.value.data.rank,\n          total: goalsRank.value.data.total_players,\n          percentile: Math.round((1 - (goalsRank.value.data.rank / goalsRank.value.data.total_players)) * 100)\n        } : null,\n        assists: assistsRank.status === 'fulfilled' && assistsRank.value.data ? {\n          rank: assistsRank.value.data.rank,\n          total: assistsRank.value.data.total_players,\n          percentile: Math.round((1 - (assistsRank.value.data.rank / assistsRank.value.data.total_players)) * 100)\n        } : null,\n        matches: matchesRank.status === 'fulfilled' && matchesRank.value.data ? {\n          rank: matchesRank.value.data.rank,\n          total: matchesRank.value.data.total_players,\n          percentile: Math.round((1 - (matchesRank.value.data.rank / matchesRank.value.data.total_players)) * 100)\n        } : null\n      };\n\n      // Cache for 30 minutes\n      this.setCache(cacheKey, rankings, 1800);\n\n      return { data: rankings, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerGlobalRankings'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get player's achievements with progress tracking\n   */\n  async getPlayerAchievements(userId: string, options: {\n    category?: string;\n    completed?: boolean;\n    limit?: number;\n    offset?: number;\n  } = {}): Promise<PaginatedServiceResponse<{\n    achievement: Achievement;\n    userAchievement: UserAchievement | null;\n    progress?: {\n      current: number;\n      target: number;\n      percentage: number;\n    };\n  }>> {\n    try {\n      let query = this.supabase\n        .from('achievements')\n        .select(`\n          *,\n          user_achievements!left(*)\n        `)\n        .eq('is_active', true);\n\n      if (options.category) {\n        query = query.eq('category', options.category);\n      }\n\n      if (options.completed !== undefined) {\n        if (options.completed) {\n          query = query.not('user_achievements', 'is', null);\n        } else {\n          query = query.is('user_achievements', null);\n        }\n      }\n\n      const { data: achievements, error, count } = await query\n        .order('sort_order')\n        .range(options.offset || 0, (options.offset || 0) + (options.limit || 50) - 1);\n\n      if (error) throw error;\n\n      // Get current player stats for progress calculation\n      const playerStats = await this.getCrossLeagueStats(userId);\n      const stats = playerStats.data;\n\n      const achievementData = achievements?.map(achievement => {\n        const userAchievement = achievement.user_achievements?.find(\n          (ua: any) => ua.user_id === userId\n        );\n\n        // Calculate progress if not completed\n        let progress;\n        if (!userAchievement && stats) {\n          const requirements = achievement.requirements as any;\n          let current = 0;\n          let target = 0;\n\n          if (requirements.goals) {\n            current = stats.total_goals || 0;\n            target = requirements.goals;\n          } else if (requirements.assists) {\n            current = stats.total_assists || 0;\n            target = requirements.assists;\n          } else if (requirements.matches_played) {\n            current = stats.total_games_played || 0;\n            target = requirements.matches_played;\n          }\n\n          if (target > 0) {\n            progress = {\n              current,\n              target,\n              percentage: Math.min(100, Math.round((current / target) * 100))\n            };\n          }\n        }\n\n        return {\n          achievement,\n          userAchievement: userAchievement || null,\n          progress\n        };\n      }) || [];\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 50)) + 1,\n        limit: options.limit || 50,\n        total: count || 0,\n        totalPages: Math.ceil((count || 0) / (options.limit || 50)),\n        hasNext: ((options.offset || 0) + (options.limit || 50)) < (count || 0),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: achievementData,\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerAchievements'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get player's team join requests\n   */\n  async getTeamJoinRequests(\n    userId: string,\n    options: { status?: JoinRequestStatus; limit?: number } = {}\n  ): Promise<ServiceResponse<Array<TeamJoinRequest & {\n    team: Database['public']['Tables']['teams']['Row'];\n    league: Database['public']['Tables']['leagues']['Row'];\n  }>>> {\n    try {\n      let query = this.supabase\n        .from('team_join_requests')\n        .select(`\n          *,\n          team:teams!inner(\n            *,\n            league:leagues!inner(*)\n          )\n        `)\n        .eq('user_id', userId);\n\n      if (options.status) {\n        query = query.eq('status', options.status);\n      }\n\n      const { data, error } = await query\n        .order('created_at', { ascending: false })\n        .limit(options.limit || 50);\n\n      if (error) throw error;\n\n      return { data: data || [], error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getTeamJoinRequests'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Submit a team join request\n   */\n  async submitTeamJoinRequest(\n    userId: string,\n    teamId: string,\n    options: {\n      message?: string;\n      preferredPosition?: string;\n      requestedJerseyNumber?: number;\n    } = {}\n  ): Promise<ServiceResponse<TeamJoinRequest>> {\n    try {\n      // Check if user already has a pending request for this team\n      const { data: existing, error: checkError } = await this.supabase\n        .from('team_join_requests')\n        .select('id')\n        .eq('user_id', userId)\n        .eq('team_id', teamId)\n        .eq('status', 'pending')\n        .single();\n\n      if (checkError && checkError.code !== 'PGRST116') throw checkError;\n\n      if (existing) {\n        return {\n          data: null,\n          error: {\n            code: 'DUPLICATE_REQUEST',\n            message: 'You already have a pending request for this team',\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      const { data, error } = await this.supabase\n        .from('team_join_requests')\n        .insert({\n          user_id: userId,\n          team_id: teamId,\n          message: options.message,\n          preferred_position: options.preferredPosition,\n          requested_jersey_number: options.requestedJerseyNumber,\n          status: 'pending',\n          expires_at: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString() // 30 days\n        })\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      return { data, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'submitTeamJoinRequest'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Withdraw a team join request\n   */\n  async withdrawTeamJoinRequest(userId: string, requestId: string): Promise<ServiceResponse<boolean>> {\n    try {\n      const { data, error } = await this.supabase\n        .from('team_join_requests')\n        .update({ status: 'withdrawn' })\n        .eq('id', requestId)\n        .eq('user_id', userId)\n        .eq('status', 'pending')\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      return { data: true, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'withdrawTeamJoinRequest'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Search for players across leagues\n   */\n  async searchPlayers(options: {\n    query?: string;\n    leagueId?: string;\n    sportType?: string;\n    minGames?: number;\n    limit?: number;\n    offset?: number;\n  } = {}): Promise<PaginatedServiceResponse<PlayerCrossLeagueStats>> {\n    try {\n      let query = this.supabase\n        .from('player_cross_league_stats')\n        .select('*', { count: 'exact' })\n        .eq('season_year', new Date().getFullYear());\n\n      if (options.query) {\n        query = query.ilike('display_name', `%${options.query}%`);\n      }\n\n      if (options.minGames) {\n        query = query.gte('total_games_played', options.minGames);\n      }\n\n      const { data, error, count } = await query\n        .order('total_goals', { ascending: false })\n        .range(options.offset || 0, (options.offset || 0) + (options.limit || 20) - 1);\n\n      if (error) throw error;\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n        limit: options.limit || 20,\n        total: count || 0,\n        totalPages: Math.ceil((count || 0) / (options.limit || 20)),\n        hasNext: ((options.offset || 0) + (options.limit || 20)) < (count || 0),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: data || [],\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'searchPlayers'),\n        success: false,\n        pagination: {\n          page: 1,\n          limit: options.limit || 20,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrevious: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Subscribe to real-time updates for player data\n   */\n  subscribeToPlayerUpdates(\n    userId: string,\n    callback: (payload: any) => void,\n    options: RealtimeSubscriptionOptions = { table: 'user_profiles', event: '*' }\n  ) {\n    return this.supabase\n      .channel(`player-${userId}-updates`)\n      .on(\n        'postgres_changes',\n        {\n          event: options.event,\n          schema: options.schema || 'public',\n          table: options.table,\n          filter: options.filter || `id=eq.${userId}`\n        },\n        callback\n      )\n      .subscribe();\n  }\n\n  /**\n   * Clear cache for specific operations or all cache\n   */\n  clearCache(pattern?: string): void {\n    if (!pattern) {\n      this.cache.clear();\n      return;\n    }\n\n    const keys = Array.from(this.cache.keys());\n    keys.forEach(key => {\n      if (key.includes(pattern)) {\n        this.cache.delete(key);\n      }\n    });\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3336, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/user.service.ts"],"sourcesContent":["/**\n * User Service for MatchDay\n * \n * Handles user profile operations with Supabase integration.\n * Provides CRUD operations for user profiles and related data.\n */\n\nimport { supabase } from '@/lib/supabase/client';\nimport type { UserProfile, UpdateUserProfile, ServiceResponse } from '@/lib/types/database.types';\n\nexport class UserService {\n  private static instance: UserService;\n  \n  static getInstance(): UserService {\n    if (!UserService.instance) {\n      UserService.instance = new UserService();\n    }\n    return UserService.instance;\n  }\n\n  /**\n   * Get user profile by ID\n   */\n  async getUserProfile(userId: string): Promise<ServiceResponse<UserProfile>> {\n    console.log(' UserService - getUserProfile called for userId:', userId);\n    \n    try {\n      console.log(' UserService - querying user_profiles table...');\n      \n      // Add timeout handling\n      const timeoutPromise = new Promise((_, reject) =>\n        setTimeout(() => reject(new Error('getUserProfile request timed out after 10 seconds')), 10000)\n      );\n      \n      const queryPromise = supabase\n        .from('users')\n        .select('*')\n        .eq('id', userId)\n        .single();\n\n      const { data, error } = await Promise.race([queryPromise, timeoutPromise]) as any;\n\n      console.log(' UserService - supabase response:', { \n        hasData: !!data, \n        error: error?.message, \n        errorCode: error?.code,\n        dataDisplayName: data?.display_name \n      });\n\n      if (error) {\n        console.log(' UserService - returning error response:', error.message);\n        return {\n          data: null,\n          error: {\n            code: 'PROFILE_NOT_FOUND',\n            message: error.message,\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      console.log(' UserService - returning success response');\n      return {\n        data: data,\n        error: null,\n        success: true\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error: {\n          code: 'UNEXPECTED_ERROR',\n          message: error instanceof Error ? error.message : 'An unexpected error occurred',\n          timestamp: new Date().toISOString()\n        },\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Update user profile\n   */\n  async updateUserProfile(userId: string, updates: UpdateUserProfile): Promise<ServiceResponse<UserProfile>> {\n    try {\n      const { data, error } = await supabase\n        .from('users')\n        .update({\n          ...updates,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', userId)\n        .select('*')\n        .single();\n\n      if (error) {\n        return {\n          data: null,\n          error: {\n            code: 'UPDATE_FAILED',\n            message: error.message,\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      return {\n        data: data,\n        error: null,\n        success: true,\n        message: 'Profile updated successfully'\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error: {\n          code: 'UNEXPECTED_ERROR',\n          message: error instanceof Error ? error.message : 'Failed to update profile',\n          timestamp: new Date().toISOString()\n        },\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Create user profile (typically called during signup)\n   */\n  async createUserProfile(userId: string, profileData: {\n    display_name: string;\n    preferred_position?: string;\n    location?: string;\n    bio?: string;\n    date_of_birth?: string;\n  }): Promise<ServiceResponse<UserProfile>> {\n    try {\n      const { data, error } = await supabase\n        .from('users')\n        .insert({\n          id: userId,\n          display_name: profileData.display_name,\n          preferred_position: profileData.preferred_position,\n          location: profileData.location,\n          bio: profileData.bio,\n          date_of_birth: profileData.date_of_birth,\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString()\n        })\n        .select('*')\n        .single();\n\n      if (error) {\n        return {\n          data: null,\n          error: {\n            code: 'CREATE_FAILED',\n            message: error.message,\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      return {\n        data: data,\n        error: null,\n        success: true,\n        message: 'Profile created successfully'\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error: {\n          code: 'UNEXPECTED_ERROR',\n          message: error instanceof Error ? error.message : 'Failed to create profile',\n          timestamp: new Date().toISOString()\n        },\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Check if user profile exists\n   */\n  async profileExists(userId: string): Promise<ServiceResponse<boolean>> {\n    try {\n      const { data, error } = await supabase\n        .from('users')\n        .select('id')\n        .eq('id', userId)\n        .maybeSingle();\n\n      if (error) {\n        return {\n          data: false,\n          error: {\n            code: 'CHECK_FAILED',\n            message: error.message,\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      return {\n        data: !!data,\n        error: null,\n        success: true\n      };\n    } catch (error) {\n      return {\n        data: false,\n        error: {\n          code: 'UNEXPECTED_ERROR',\n          message: error instanceof Error ? error.message : 'Failed to check profile',\n          timestamp: new Date().toISOString()\n        },\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get or create user profile (ensures profile exists)\n   */\n  async getOrCreateUserProfile(userId: string, fallbackData?: {\n    display_name: string;\n    preferred_position?: string;\n    location?: string;\n  }): Promise<ServiceResponse<UserProfile>> {\n    try {\n      // First try to get existing profile\n      const profileResult = await this.getUserProfile(userId);\n      \n      if (profileResult.success && profileResult.data) {\n        return profileResult;\n      }\n\n      // If profile doesn't exist and we have fallback data, create it\n      if (fallbackData) {\n        return await this.createUserProfile(userId, fallbackData);\n      }\n\n      // No profile and no fallback data\n      return {\n        data: null,\n        error: {\n          code: 'PROFILE_NOT_FOUND',\n          message: 'User profile not found and no fallback data provided',\n          timestamp: new Date().toISOString()\n        },\n        success: false\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error: {\n          code: 'UNEXPECTED_ERROR',\n          message: error instanceof Error ? error.message : 'Failed to get or create profile',\n          timestamp: new Date().toISOString()\n        },\n        success: false\n      };\n    }\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3556, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/stats.service.ts"],"sourcesContent":["/**\n * Stats Service for MatchDay\n * \n * Handles comprehensive performance analytics operations with focus on:\n * - Individual player statistics and trends\n * - Cross-league performance comparisons\n * - Global rankings and leaderboards\n * - Performance trend analysis and predictions\n * \n * Optimized for providing deep insights into player performance across leagues\n */\n\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport {\n  Database,\n  PlayerStats,\n  PlayerCrossLeagueStats,\n  LeagueComparison,\n  PerformanceTrend,\n  GlobalRanking,\n  ServiceResponse,\n  ServiceError,\n  PaginatedServiceResponse,\n  SportType,\n  LeagueType,\n  CacheOptions,\n  RealtimeSubscriptionOptions\n} from '@/lib/types/database.types';\n\nexport interface StatsFilters {\n  sportType?: SportType;\n  leagueType?: LeagueType;\n  seasonYear?: number;\n  minGames?: number;\n  position?: string;\n  ageGroup?: 'under_18' | 'under_21' | 'under_25' | 'over_25' | 'all';\n}\n\nexport interface PlayerPerformanceAnalysis {\n  playerId: string;\n  playerName: string;\n  avatarUrl?: string;\n  overallRating: number;\n  strengths: string[];\n  improvements: string[];\n  trends: {\n    goals: PerformanceTrend[];\n    assists: PerformanceTrend[];\n    overall: PerformanceTrend[];\n  };\n  comparisons: {\n    vsLeagueAverage: {\n      goals: number;\n      assists: number;\n      performance: number;\n    };\n    vsPositionAverage: {\n      goals: number;\n      assists: number;\n      performance: number;\n    };\n    improvement: {\n      last30Days: number;\n      last3Months: number;\n      season: number;\n    };\n  };\n  predictions: {\n    seasonEndGoals: number;\n    seasonEndAssists: number;\n    confidenceLevel: number;\n  };\n}\n\nexport interface LeagueAnalytics {\n  leagueId: string;\n  leagueName: string;\n  sportType: SportType;\n  totalPlayers: number;\n  totalTeams: number;\n  totalMatches: number;\n  averageGoalsPerGame: number;\n  competitiveness: {\n    score: number;\n    description: string;\n  };\n  topPerformers: {\n    goals: GlobalRanking[];\n    assists: GlobalRanking[];\n    overall: GlobalRanking[];\n  };\n  trends: {\n    playerGrowth: number;\n    matchActivity: number;\n    competitiveBalance: number;\n  };\n  insights: string[];\n}\n\nexport interface CrossLeagueComparison {\n  playerId: string;\n  playerName: string;\n  leagues: Array<{\n    league: Database['public']['Tables']['leagues']['Row'];\n    stats: PlayerStats;\n    rank: {\n      goals: number;\n      assists: number;\n      overall: number;\n    };\n    performance: {\n      goalsPerGame: number;\n      assistsPerGame: number;\n      consistency: number;\n      improvement: number;\n    };\n    adaptability: {\n      score: number;\n      factors: string[];\n    };\n  }>;\n  overallAnalysis: {\n    versatility: number;\n    consistency: number;\n    adaptability: number;\n    growthPotential: number;\n  };\n  recommendations: string[];\n}\n\nexport class StatsService {\n  private static instance: StatsService;\n  private supabase: SupabaseClient<Database>;\n  private cache = new Map<string, { data: unknown; timestamp: number; ttl: number }>();\n\n  private constructor(supabaseClient: SupabaseClient<Database>) {\n    this.supabase = supabaseClient;\n  }\n\n  static getInstance(supabaseClient?: SupabaseClient<Database>): StatsService {\n    if (!StatsService.instance) {\n      if (!supabaseClient) {\n        throw new Error('SupabaseClient required for first initialization');\n      }\n      StatsService.instance = new StatsService(supabaseClient);\n    }\n    return StatsService.instance;\n  }\n\n  /**\n   * Handle service errors consistently\n   */\n  private handleError(error: unknown, operation: string): ServiceError {\n    console.error(`StatsService.${operation}:`, {\n      error,\n      errorType: typeof error,\n      errorKeys: error ? Object.keys(error) : [],\n      errorCode: error?.code,\n      errorMessage: error?.message,\n      stack: error?.stack\n    });\n    \n    // Handle specific database errors\n    if (error?.code === 'PGRST116') {\n      return {\n        code: 'NOT_FOUND',\n        message: 'No data found for the requested user',\n        details: { originalError: error, operation },\n        timestamp: new Date().toISOString()\n      };\n    }\n    \n    // Handle empty error objects\n    if (!error || (typeof error === 'object' && Object.keys(error).length === 0)) {\n      return {\n        code: 'EMPTY_ERROR',\n        message: 'An unknown error occurred with no error details',\n        details: { operation, receivedError: error },\n        timestamp: new Date().toISOString()\n      };\n    }\n    \n    return {\n      code: error?.code || 'UNKNOWN_ERROR',\n      message: error?.message || 'An unexpected error occurred',\n      details: error?.details || error,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Cache management utilities\n   */\n  private getCacheKey(operation: string, params: unknown): string {\n    return `stats_service:${operation}:${JSON.stringify(params)}`;\n  }\n\n  private getFromCache<T>(key: string): T | null {\n    const cached = this.cache.get(key);\n    if (!cached) return null;\n    \n    if (Date.now() - cached.timestamp > cached.ttl * 1000) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return cached.data as T;\n  }\n\n  private setCache<T>(key: string, data: T, ttl = 900): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl\n    });\n  }\n\n  /**\n   * Get comprehensive player performance analysis\n   */\n  async getPlayerPerformanceAnalysis(\n    userId: string,\n    options: {\n      seasonYear?: number;\n      includeComparisons?: boolean;\n      includePredictions?: boolean;\n    } = {}\n  ): Promise<ServiceResponse<PlayerPerformanceAnalysis>> {\n    try {\n      const cacheKey = this.getCacheKey('getPlayerPerformanceAnalysis', { userId, options });\n      const cached = this.getFromCache<PlayerPerformanceAnalysis>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      const seasonYear = options.seasonYear || new Date().getFullYear();\n\n      // Get player profile\n      const { data: profile, error: profileError } = await this.supabase\n        .from('users')\n        .select('display_name, avatar_url, preferred_position')\n        .eq('id', userId)\n        .single();\n\n      if (profileError && profileError.code !== 'PGRST116') throw profileError;\n      \n      // If no profile exists, create a default one for the analysis\n      const playerProfile = profile || {\n        display_name: 'Unknown Player',\n        avatar_url: null,\n        preferred_position: null\n      };\n\n      // Try to get cross-league stats (table may not exist yet)\n      let crossLeagueStats = null;\n      try {\n        const { data: stats, error: statsError } = await this.supabase\n          .from('player_cross_league_stats')\n          .select('*')\n          .eq('player_id', userId)\n          .eq('season_year', seasonYear)\n          .single();\n\n        if (statsError && statsError.code !== 'PGRST116') {\n          console.warn('player_cross_league_stats table not found, will generate stats from player_stats');\n        } else {\n          crossLeagueStats = stats;\n        }\n      } catch (error) {\n        console.warn('player_cross_league_stats table not available, using fallback approach');\n      }\n\n      // Get individual league stats for detailed analysis\n      const { data: leagueStats, error: leagueError } = await this.supabase\n        .from('player_stats')\n        .select(`\n          *,\n          league:leagues!inner(*),\n          team:teams!inner(*)\n        `)\n        .eq('player_id', userId)\n        .eq('season_year', seasonYear);\n\n      if (leagueError) throw leagueError;\n\n      // If no cross-league stats, generate them from individual league stats\n      if (!crossLeagueStats && leagueStats && leagueStats.length > 0) {\n        crossLeagueStats = this.generateCrossLeagueStatsFromPlayerStats(leagueStats);\n      }\n\n      // Calculate performance trends (with error handling)\n      let trends;\n      try {\n        trends = await this.calculatePerformanceTrends(userId, seasonYear);\n      } catch (trendsError) {\n        console.warn('Failed to calculate performance trends:', trendsError);\n        trends = { data: { goals: [], assists: [], overall: [] }, error: null, success: false };\n      }\n\n      // Calculate overall rating\n      const overallRating = this.calculateOverallRating(crossLeagueStats, leagueStats || []);\n\n      // Analyze strengths and improvements\n      const { strengths, improvements } = this.analyzePlayerStrengthsAndWeaknesses(\n        crossLeagueStats,\n        leagueStats || []\n      );\n\n      // Calculate comparisons if requested\n      let comparisons;\n      if (options.includeComparisons) {\n        comparisons = await this.calculatePlayerComparisons(\n          userId,\n          playerProfile.preferred_position,\n          crossLeagueStats,\n          seasonYear\n        );\n      }\n\n      // Calculate predictions if requested\n      let predictions;\n      if (options.includePredictions) {\n        predictions = await this.calculateSeasonPredictions(userId, crossLeagueStats, trends.data);\n      }\n\n      const analysis: PlayerPerformanceAnalysis = {\n        playerId: userId,\n        playerName: playerProfile.display_name,\n        avatarUrl: playerProfile.avatar_url,\n        overallRating,\n        strengths,\n        improvements,\n        trends: trends.data || {\n          goals: [],\n          assists: [],\n          overall: []\n        },\n        comparisons: comparisons || {\n          vsLeagueAverage: { goals: 0, assists: 0, performance: 0 },\n          vsPositionAverage: { goals: 0, assists: 0, performance: 0 },\n          improvement: { last30Days: 0, last3Months: 0, season: 0 }\n        },\n        predictions: predictions || {\n          seasonEndGoals: crossLeagueStats?.total_goals || 0,\n          seasonEndAssists: crossLeagueStats?.total_assists || 0,\n          confidenceLevel: 50\n        }\n      };\n\n      // Cache for 15 minutes\n      this.setCache(cacheKey, analysis, 900);\n\n      return { data: analysis, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerPerformanceAnalysis'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get global player rankings across different stats\n   */\n  async getGlobalRankings(\n    statType: 'goals' | 'assists' | 'matches' | 'performance',\n    filters: StatsFilters = {},\n    options: { limit?: number; offset?: number } = {}\n  ): Promise<PaginatedServiceResponse<GlobalRanking>> {\n    try {\n      const cacheKey = this.getCacheKey('getGlobalRankings', { statType, filters, options });\n      const cached = this.getFromCache<GlobalRanking[]>(cacheKey);\n      \n      if (cached) {\n        return {\n          data: cached,\n          error: null,\n          success: true,\n          pagination: {\n            page: Math.floor((options.offset || 0) / (options.limit || 50)) + 1,\n            limit: options.limit || 50,\n            total: cached.length,\n            totalPages: Math.ceil(cached.length / (options.limit || 50)),\n            hasNext: false,\n            hasPrevious: false\n          }\n        };\n      }\n\n      // Use RPC function for complex ranking calculation\n      const { data: rankings, error } = await this.supabase\n        .rpc('get_global_rankings', {\n          stat_type: statType,\n          sport_type_filter: filters.sportType || null,\n          league_type_filter: filters.leagueType || null,\n          season_year_filter: filters.seasonYear || new Date().getFullYear(),\n          min_games_filter: filters.minGames || 1,\n          position_filter: filters.position || null,\n          limit_count: options.limit || 50,\n          offset_count: options.offset || 0\n        });\n\n      if (error) throw error;\n\n      const globalRankings: GlobalRanking[] = (rankings || []).map((entry, index) => ({\n        playerId: entry.player_id,\n        displayName: entry.display_name,\n        avatarUrl: entry.avatar_url,\n        rank: (options.offset || 0) + index + 1,\n        statValue: entry.stat_value,\n        trend: 'stable', // Would need historical data to calculate trend\n        previousRank: entry.previous_rank\n      }));\n\n      // Cache for 30 minutes\n      this.setCache(cacheKey, globalRankings, 1800);\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 50)) + 1,\n        limit: options.limit || 50,\n        total: globalRankings.length,\n        totalPages: Math.ceil(globalRankings.length / (options.limit || 50)),\n        hasNext: globalRankings.length === (options.limit || 50),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: globalRankings,\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getGlobalRankings'),\n        success: false,\n        pagination: {\n          page: 1,\n          limit: options.limit || 50,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrevious: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Get cross-league performance comparison for a player\n   */\n  async getCrossLeagueComparison(\n    userId: string,\n    options: { seasonYear?: number; includeAnalysis?: boolean } = {}\n  ): Promise<ServiceResponse<CrossLeagueComparison>> {\n    try {\n      const cacheKey = this.getCacheKey('getCrossLeagueComparison', { userId, options });\n      const cached = this.getFromCache<CrossLeagueComparison>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      const seasonYear = options.seasonYear || new Date().getFullYear();\n\n      // Get player profile\n      const { data: profile, error: profileError } = await this.supabase\n        .from('users')\n        .select('display_name')\n        .eq('id', userId)\n        .single();\n\n      if (profileError) throw profileError;\n\n      // Get player's stats across leagues\n      const { data: playerStats, error: statsError } = await this.supabase\n        .from('player_stats')\n        .select(`\n          *,\n          league:leagues!inner(*),\n          team:teams!inner(*)\n        `)\n        .eq('player_id', userId)\n        .eq('season_year', seasonYear);\n\n      if (statsError) throw statsError;\n\n      // Process league comparisons\n      const leagues = await Promise.all(\n        (playerStats || []).map(async (stat) => {\n          // Get league rankings for this player\n          const rank = await this.getPlayerLeagueRank(userId, stat.league_id, seasonYear);\n          \n          // Calculate performance metrics\n          const performance = {\n            goalsPerGame: stat.games_played > 0 ? (stat.goals || 0) / stat.games_played : 0,\n            assistsPerGame: stat.games_played > 0 ? (stat.assists || 0) / stat.games_played : 0,\n            consistency: this.calculateConsistency(stat),\n            improvement: 0 // Would need historical data\n          };\n\n          // Calculate adaptability\n          const adaptability = this.calculateAdaptability(stat, stat.league);\n\n          return {\n            league: stat.league,\n            stats: stat,\n            rank: rank.data || { goals: 999, assists: 999, overall: 999 },\n            performance,\n            adaptability\n          };\n        })\n      );\n\n      // Calculate overall analysis\n      const overallAnalysis = this.calculateOverallCrossLeagueAnalysis(leagues);\n      \n      // Generate recommendations\n      const recommendations = this.generateCrossLeagueRecommendations(leagues, overallAnalysis);\n\n      const comparison: CrossLeagueComparison = {\n        playerId: userId,\n        playerName: profile.display_name,\n        leagues,\n        overallAnalysis,\n        recommendations\n      };\n\n      // Cache for 20 minutes\n      this.setCache(cacheKey, comparison, 1200);\n\n      return { data: comparison, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getCrossLeagueComparison'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get comprehensive league analytics\n   */\n  async getLeagueAnalytics(\n    leagueId: string,\n    options: { seasonYear?: number; includeInsights?: boolean } = {}\n  ): Promise<ServiceResponse<LeagueAnalytics>> {\n    try {\n      const cacheKey = this.getCacheKey('getLeagueAnalytics', { leagueId, options });\n      const cached = this.getFromCache<LeagueAnalytics>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      const seasonYear = options.seasonYear || new Date().getFullYear();\n\n      // Get league details\n      const { data: league, error: leagueError } = await this.supabase\n        .from('leagues')\n        .select('*')\n        .eq('id', leagueId)\n        .single();\n\n      if (leagueError) throw leagueError;\n\n      // Get league statistics using RPC\n      const { data: leagueStats, error: statsError } = await this.supabase\n        .rpc('get_league_analytics', {\n          league_id: leagueId,\n          season_year: seasonYear\n        });\n\n      if (statsError) throw statsError;\n\n      // Get top performers\n      const topPerformers = await this.getLeagueTopPerformers(leagueId, seasonYear);\n\n      // Calculate trends\n      const trends = await this.calculateLeagueTrends(leagueId, seasonYear);\n\n      // Generate insights\n      let insights: string[] = [];\n      if (options.includeInsights) {\n        insights = this.generateLeagueInsights(leagueStats, topPerformers.data, trends.data);\n      }\n\n      const analytics: LeagueAnalytics = {\n        leagueId,\n        leagueName: league.name,\n        sportType: league.sport_type as SportType,\n        totalPlayers: leagueStats?.total_players || 0,\n        totalTeams: leagueStats?.total_teams || 0,\n        totalMatches: leagueStats?.total_matches || 0,\n        averageGoalsPerGame: leagueStats?.average_goals_per_game || 0,\n        competitiveness: {\n          score: leagueStats?.competitiveness_score || 50,\n          description: this.getCompetitivenessDescription(leagueStats?.competitiveness_score || 50)\n        },\n        topPerformers: topPerformers.data || {\n          goals: [],\n          assists: [],\n          overall: []\n        },\n        trends: trends.data || {\n          playerGrowth: 0,\n          matchActivity: 0,\n          competitiveBalance: 0\n        },\n        insights\n      };\n\n      // Cache for 1 hour\n      this.setCache(cacheKey, analytics, 3600);\n\n      return { data: analytics, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getLeagueAnalytics'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get performance trends for a player over time\n   */\n  async getPerformanceTrends(\n    userId: string,\n    options: {\n      period: 'weekly' | 'monthly' | 'quarterly';\n      statTypes: Array<'goals' | 'assists' | 'matches' | 'performance'>;\n      seasonYear?: number;\n    }\n  ): Promise<ServiceResponse<{ [key: string]: PerformanceTrend[] }>> {\n    try {\n      const cacheKey = this.getCacheKey('getPerformanceTrends', { userId, options });\n      const cached = this.getFromCache<{ [key: string]: PerformanceTrend[] }>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      const trends = await this.calculatePerformanceTrends(\n        userId,\n        options.seasonYear || new Date().getFullYear(),\n        options.period,\n        options.statTypes\n      );\n\n      return trends;\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPerformanceTrends'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n  private generateCrossLeagueStatsFromPlayerStats(playerStats: PlayerStats[]): any {\n    const totalGoals = playerStats.reduce((sum, stat) => sum + (stat.goals || 0), 0);\n    const totalAssists = playerStats.reduce((sum, stat) => sum + (stat.assists || 0), 0);\n    const totalGames = playerStats.reduce((sum, stat) => sum + (stat.games_played || 0), 0);\n    const leaguesPlayed = new Set(playerStats.map(stat => stat.league_id)).size;\n    const teamsPlayed = new Set(playerStats.map(stat => stat.team_id)).size;\n\n    return {\n      player_id: playerStats[0]?.player_id || '',\n      display_name: 'Generated Stats',\n      avatar_url: null,\n      preferred_position: null,\n      season_year: new Date().getFullYear(),\n      leagues_played: leaguesPlayed,\n      teams_played: teamsPlayed,\n      total_games_played: totalGames,\n      total_goals: totalGoals,\n      total_assists: totalAssists,\n      total_yellow_cards: playerStats.reduce((sum, stat) => sum + (stat.yellow_cards || 0), 0),\n      total_red_cards: playerStats.reduce((sum, stat) => sum + (stat.red_cards || 0), 0),\n      avg_goals_per_game: totalGames > 0 ? totalGoals / totalGames : 0,\n      avg_contributions_per_game: totalGames > 0 ? (totalGoals + totalAssists) / totalGames : 0,\n      goals_consistency: totalGames > 0 ? this.calculateGoalsConsistency(playerStats) : null,\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString()\n    };\n  }\n\n  private calculateGoalsConsistency(playerStats: PlayerStats[]): number {\n    if (playerStats.length === 0) return 0;\n    \n    const goalRates = playerStats.map(stat => \n      (stat.games_played || 0) > 0 ? (stat.goals || 0) / (stat.games_played || 1) : 0\n    );\n    \n    const avgRate = goalRates.reduce((sum, rate) => sum + rate, 0) / goalRates.length;\n    const variance = goalRates.reduce((sum, rate) => sum + Math.pow(rate - avgRate, 2), 0) / goalRates.length;\n    \n    return Math.sqrt(variance);\n  }\n  private async calculatePerformanceTrends(\n    userId: string,\n    seasonYear: number,\n    period: 'weekly' | 'monthly' | 'quarterly' = 'monthly',\n    statTypes: Array<'goals' | 'assists' | 'matches' | 'performance'> = ['goals', 'assists', 'performance']\n  ): Promise<ServiceResponse<{ [key: string]: PerformanceTrend[] }>> {\n    try {\n      // Check if the RPC function exists first, if not return empty trends\n      const { data: trendsData, error } = await this.supabase\n        .rpc('calculate_performance_trends', {\n          player_id: userId,\n          season_year: seasonYear,\n          period_type: period,\n          stat_types: statTypes\n        });\n\n      // If RPC function doesn't exist or has error, return empty trends\n      if (error) {\n        console.warn('Performance trends RPC function not available:', error);\n        const emptyTrends: { [key: string]: PerformanceTrend[] } = {};\n        statTypes.forEach(statType => {\n          emptyTrends[statType] = [];\n        });\n        return { data: emptyTrends, error: null, success: true };\n      }\n\n      // Process the trends data\n      const trends: { [key: string]: PerformanceTrend[] } = {};\n      statTypes.forEach(statType => {\n        trends[statType] = trendsData?.filter((t: { stat_type: string }) => t.stat_type === statType).map((t: { period: string; goals?: number; assists?: number; matches?: number; performance?: number }) => ({\n          period: t.period,\n          goals: t.goals || 0,\n          assists: t.assists || 0,\n          matches: t.matches || 0,\n          performance: t.performance || 0\n        })) || [];\n      });\n\n      return { data: trends, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'calculatePerformanceTrends'),\n        success: false\n      };\n    }\n  }\n\n  private calculateOverallRating(\n    crossLeagueStats: PlayerCrossLeagueStats | null,\n    leagueStats: PlayerStats[]\n  ): number {\n    if (!crossLeagueStats || !leagueStats.length) return 50;\n\n    // Simple rating calculation based on multiple factors\n    const avgGoalsPerGame = crossLeagueStats.avg_goals_per_game || 0;\n    const avgAssistsPerGame = crossLeagueStats.avg_contributions_per_game \n      ? crossLeagueStats.avg_contributions_per_game - avgGoalsPerGame \n      : 0;\n    const consistency = crossLeagueStats.goals_consistency ? 100 - (crossLeagueStats.goals_consistency * 10) : 50;\n    const leagueVariety = crossLeagueStats.leagues_played || 1;\n\n    const rating = Math.min(100, Math.max(0,\n      (avgGoalsPerGame * 20) +\n      (avgAssistsPerGame * 15) +\n      (consistency * 0.3) +\n      (leagueVariety * 2) +\n      30 // Base rating\n    ));\n\n    return Math.round(rating);\n  }\n\n  private analyzePlayerStrengthsAndWeaknesses(\n    crossLeagueStats: PlayerCrossLeagueStats | null,\n    leagueStats: PlayerStats[]\n  ): { strengths: string[]; improvements: string[] } {\n    const strengths: string[] = [];\n    const improvements: string[] = [];\n\n    if (!crossLeagueStats) {\n      return { strengths: ['New player - building experience'], improvements: ['Play more matches to build statistics'] };\n    }\n\n    // Analyze strengths\n    if (crossLeagueStats.avg_goals_per_game > 0.5) {\n      strengths.push('Excellent goal scoring ability');\n    }\n    if (crossLeagueStats.avg_contributions_per_game > 0.7) {\n      strengths.push('High overall contribution to team');\n    }\n    if (crossLeagueStats.leagues_played > 2) {\n      strengths.push('Versatile across different leagues');\n    }\n    if (crossLeagueStats.total_games_played > 20) {\n      strengths.push('Experienced and consistent player');\n    }\n\n    // Analyze improvements\n    if (crossLeagueStats.avg_goals_per_game < 0.2) {\n      improvements.push('Focus on creating more scoring opportunities');\n    }\n    if (crossLeagueStats.goals_consistency && crossLeagueStats.goals_consistency > 0.5) {\n      improvements.push('Work on consistency in performance');\n    }\n    if (crossLeagueStats.leagues_played === 1) {\n      improvements.push('Consider exploring different leagues for variety');\n    }\n\n    // Ensure we have at least some content\n    if (strengths.length === 0) {\n      strengths.push('Building experience and skills');\n    }\n    if (improvements.length === 0) {\n      improvements.push('Continue developing match experience');\n    }\n\n    return { strengths, improvements };\n  }\n\n  private async calculatePlayerComparisons(\n    userId: string,\n    position: string | null,\n    crossLeagueStats: PlayerCrossLeagueStats | null,\n    seasonYear: number\n  ) {\n    // This would involve complex calculations comparing against league and position averages\n    // Simplified implementation\n    return {\n      vsLeagueAverage: {\n        goals: crossLeagueStats?.avg_goals_per_game || 0,\n        assists: (crossLeagueStats?.avg_contributions_per_game || 0) - (crossLeagueStats?.avg_goals_per_game || 0),\n        performance: 0\n      },\n      vsPositionAverage: {\n        goals: crossLeagueStats?.avg_goals_per_game || 0,\n        assists: (crossLeagueStats?.avg_contributions_per_game || 0) - (crossLeagueStats?.avg_goals_per_game || 0),\n        performance: 0\n      },\n      improvement: {\n        last30Days: 0,\n        last3Months: 0,\n        season: 0\n      }\n    };\n  }\n\n  private async calculateSeasonPredictions(\n    userId: string,\n    crossLeagueStats: PlayerCrossLeagueStats | null,\n    trends: any\n  ) {\n    if (!crossLeagueStats) {\n      return {\n        seasonEndGoals: 0,\n        seasonEndAssists: 0,\n        confidenceLevel: 0\n      };\n    }\n\n    // Simple prediction based on current performance\n    const remainingWeeks = Math.max(0, 52 - new Date().getWeek());\n    const currentRate = crossLeagueStats.avg_goals_per_game || 0;\n    \n    return {\n      seasonEndGoals: Math.round((crossLeagueStats.total_goals || 0) + (currentRate * remainingWeeks * 0.5)),\n      seasonEndAssists: Math.round((crossLeagueStats.total_assists || 0) + (currentRate * 0.7 * remainingWeeks * 0.5)),\n      confidenceLevel: crossLeagueStats.total_games_played > 10 ? 75 : 45\n    };\n  }\n\n  private async getPlayerLeagueRank(userId: string, leagueId: string, seasonYear: number): Promise<ServiceResponse<{\n    goals: number;\n    assists: number;\n    overall: number;\n  }>> {\n    try {\n      const { data, error } = await this.supabase\n        .rpc('get_player_league_rank', {\n          player_id: userId,\n          league_id: leagueId,\n          season_year: seasonYear\n        });\n\n      if (error) throw error;\n\n      return {\n        data: data || { goals: 999, assists: 999, overall: 999 },\n        error: null,\n        success: true\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerLeagueRank'),\n        success: false\n      };\n    }\n  }\n\n  private calculateConsistency(stats: PlayerStats): number {\n    // Simplified consistency calculation\n    if (!stats.games_played || stats.games_played === 0) return 0;\n    \n    const goalConsistency = stats.goals ? (stats.goals / stats.games_played) * 100 : 0;\n    const participationConsistency = stats.games_started ? (stats.games_started / stats.games_played) * 100 : 50;\n    \n    return Math.round((goalConsistency + participationConsistency) / 2);\n  }\n\n  private calculateAdaptability(stats: PlayerStats, league: any) {\n    const factors: string[] = [];\n    let score = 50;\n\n    if (stats.games_played > 5) {\n      score += 20;\n      factors.push('Good match participation');\n    }\n\n    if (league.league_type === 'competitive' && (stats.goals || 0) > 0) {\n      score += 15;\n      factors.push('Performs well in competitive environment');\n    }\n\n    return {\n      score: Math.min(100, score),\n      factors\n    };\n  }\n\n  private calculateOverallCrossLeagueAnalysis(leagues: any[]) {\n    const numLeagues = leagues.length;\n    \n    return {\n      versatility: Math.min(100, numLeagues * 25),\n      consistency: numLeagues > 0 \n        ? Math.round(leagues.reduce((sum, l) => sum + l.performance.consistency, 0) / numLeagues)\n        : 0,\n      adaptability: numLeagues > 0\n        ? Math.round(leagues.reduce((sum, l) => sum + l.adaptability.score, 0) / numLeagues)\n        : 0,\n      growthPotential: 75 // Simplified calculation\n    };\n  }\n\n  private generateCrossLeagueRecommendations(leagues: any[], overallAnalysis: any): string[] {\n    const recommendations: string[] = [];\n\n    if (leagues.length === 1) {\n      recommendations.push('Consider joining additional leagues to showcase versatility');\n    }\n\n    if (overallAnalysis.consistency < 60) {\n      recommendations.push('Focus on maintaining consistent performance across leagues');\n    }\n\n    if (overallAnalysis.adaptability < 70) {\n      recommendations.push('Work on adapting your play style to different league formats');\n    }\n\n    return recommendations;\n  }\n\n  private async getLeagueTopPerformers(leagueId: string, seasonYear: number): Promise<ServiceResponse<{\n    goals: GlobalRanking[];\n    assists: GlobalRanking[];\n    overall: GlobalRanking[];\n  }>> {\n    try {\n      // Get top goal scorers\n      const { data: goalScorers, error: goalError } = await this.supabase\n        .from('player_leaderboard')\n        .select('*')\n        .eq('league_id', leagueId)\n        .eq('season_year', seasonYear)\n        .order('goals', { ascending: false })\n        .limit(10);\n\n      if (goalError) throw goalError;\n\n      // Get top assists\n      const { data: assistLeaders, error: assistError } = await this.supabase\n        .from('player_leaderboard')\n        .select('*')\n        .eq('league_id', leagueId)\n        .eq('season_year', seasonYear)\n        .order('assists', { ascending: false })\n        .limit(10);\n\n      if (assistError) throw assistError;\n\n      // Get overall performers (based on goals + assists)\n      const { data: overallPerformers, error: overallError } = await this.supabase\n        .from('player_leaderboard')\n        .select('*')\n        .eq('league_id', leagueId)\n        .eq('season_year', seasonYear)\n        .order('goal_contributions_per_game', { ascending: false })\n        .limit(10);\n\n      if (overallError) throw overallError;\n\n      const data = {\n        goals: (goalScorers || []).map((player, index) => ({\n          playerId: player.player_id,\n          displayName: player.display_name,\n          avatarUrl: player.avatar_url,\n          rank: index + 1,\n          statValue: player.goals,\n          trend: 'stable' as const\n        })),\n        assists: (assistLeaders || []).map((player, index) => ({\n          playerId: player.player_id,\n          displayName: player.display_name,\n          avatarUrl: player.avatar_url,\n          rank: index + 1,\n          statValue: player.assists,\n          trend: 'stable' as const\n        })),\n        overall: (overallPerformers || []).map((player, index) => ({\n          playerId: player.player_id,\n          displayName: player.display_name,\n          avatarUrl: player.avatar_url,\n          rank: index + 1,\n          statValue: player.goals + player.assists,\n          trend: 'stable' as const\n        }))\n      };\n\n      return { data, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getLeagueTopPerformers'),\n        success: false\n      };\n    }\n  }\n\n  private async calculateLeagueTrends(leagueId: string, seasonYear: number): Promise<ServiceResponse<{\n    playerGrowth: number;\n    matchActivity: number;\n    competitiveBalance: number;\n  }>> {\n    try {\n      // Get league statistics for trends calculation\n      const { data: currentStats, error: currentError } = await this.supabase\n        .from('league_standings')\n        .select('*')\n        .eq('league_id', leagueId)\n        .eq('season_year', seasonYear);\n\n      if (currentError) throw currentError;\n\n      // Get previous year for comparison (if available)\n      const { data: previousStats, error: previousError } = await this.supabase\n        .from('league_standings')\n        .select('*')\n        .eq('league_id', leagueId)\n        .eq('season_year', seasonYear - 1);\n\n      // Calculate trends\n      const currentPlayerCount = currentStats?.length || 0;\n      const previousPlayerCount = previousStats?.length || 0;\n      const playerGrowth = previousPlayerCount > 0 \n        ? Math.round(((currentPlayerCount - previousPlayerCount) / previousPlayerCount) * 100)\n        : 0;\n\n      // Calculate match activity based on games played\n      const totalGames = currentStats?.reduce((sum, team) => sum + (team.games_played || 0), 0) || 0;\n      const expectedGames = currentPlayerCount * 10; // Assuming ~10 games per season\n      const matchActivity = expectedGames > 0 \n        ? Math.min(100, Math.round((totalGames / expectedGames) * 100))\n        : 0;\n\n      // Calculate competitive balance based on points distribution\n      const points = currentStats?.map(team => team.points || 0) || [];\n      const avgPoints = points.length > 0 ? points.reduce((a, b) => a + b, 0) / points.length : 0;\n      const pointsVariance = points.length > 0 \n        ? points.reduce((sum, points) => sum + Math.pow(points - avgPoints, 2), 0) / points.length\n        : 0;\n      const competitiveBalance = points.length > 0 \n        ? Math.max(0, Math.min(100, 100 - (Math.sqrt(pointsVariance) / avgPoints * 100)))\n        : 50;\n\n      const data = {\n        playerGrowth: Math.max(-100, Math.min(100, playerGrowth)),\n        matchActivity: Math.max(0, Math.min(100, matchActivity)),\n        competitiveBalance: Math.max(0, Math.min(100, Math.round(competitiveBalance)))\n      };\n\n      return { data, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: {\n          playerGrowth: 0,\n          matchActivity: 0,\n          competitiveBalance: 50\n        },\n        error: this.handleError(error, 'calculateLeagueTrends'),\n        success: false\n      };\n    }\n  }\n\n  private generateLeagueInsights(leagueStats: any, topPerformers: any, trends: any): string[] {\n    const insights: string[] = [];\n\n    if (leagueStats?.competitiveness_score > 80) {\n      insights.push('Highly competitive league with balanced teams');\n    } else if (leagueStats?.competitiveness_score < 40) {\n      insights.push('Consider strategies to improve competitive balance');\n    }\n\n    if (trends?.playerGrowth > 20) {\n      insights.push('Strong player growth indicating healthy league development');\n    }\n\n    if (leagueStats?.average_goals_per_game > 3) {\n      insights.push('High-scoring league with attacking play style');\n    } else if (leagueStats?.average_goals_per_game < 1.5) {\n      insights.push('Defensive-minded league with tight matches');\n    }\n\n    return insights;\n  }\n\n  private getCompetitivenessDescription(score: number): string {\n    if (score >= 80) return 'Highly competitive with balanced teams';\n    if (score >= 60) return 'Good competitive balance';\n    if (score >= 40) return 'Moderate competitiveness';\n    return 'Needs improvement in competitive balance';\n  }\n\n  /**\n   * Subscribe to real-time stats updates\n   */\n  subscribeToStatsUpdates(\n    userId: string,\n    callback: (payload: any) => void,\n    options: RealtimeSubscriptionOptions = { table: 'player_stats', event: '*' }\n  ) {\n    return this.supabase\n      .channel(`stats-${userId}-updates`)\n      .on(\n        'postgres_changes',\n        {\n          event: options.event,\n          schema: options.schema || 'public',\n          table: options.table,\n          filter: options.filter || `player_id=eq.${userId}`\n        },\n        callback\n      )\n      .subscribe();\n  }\n\n  /**\n   * Clear cache\n   */\n  clearCache(pattern?: string): void {\n    if (!pattern) {\n      this.cache.clear();\n      return;\n    }\n\n    const keys = Array.from(this.cache.keys());\n    keys.forEach(key => {\n      if (key.includes(pattern)) {\n        this.cache.delete(key);\n      }\n    });\n  }\n}\n\n// Extend Date prototype for week calculation (helper for predictions)\ndeclare global {\n  interface Date {\n    getWeek(): number;\n  }\n}\n\nDate.prototype.getWeek = function() {\n  const date = new Date(this.getTime());\n  date.setHours(0, 0, 0, 0);\n  date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);\n  const week1 = new Date(date.getFullYear(), 0, 4);\n  return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);\n};"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4445, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/analytics.service.ts"],"sourcesContent":["/**\n * Analytics Service for MatchDay\n * \n * Handles cross-league comparisons and advanced statistics that make amateur\n * players feel professional. Provides comprehensive analytics across all leagues.\n * \n * @example\n * ```typescript\n * const ranking = await AnalyticsService.getInstance().getGlobalPlayerRanking(userId);\n * const comparison = await AnalyticsService.getInstance().comparePlayerAcrossLeagues(userId);\n * ```\n * \n * This service should be used for ALL analytics and comparison operations.\n */\n\nimport { Database } from '../types/database.types';\n\ntype PlayerStats = Database['public']['Tables']['player_stats']['Row'];\ntype TeamStats = Database['public']['Tables']['team_stats']['Row'];\n\nexport interface GlobalPlayerRanking {\n  playerId: string;\n  displayName: string;\n  avatarUrl?: string;\n  totalGoals: number;\n  totalAssists: number;\n  totalGames: number;\n  totalMinutes: number;\n  globalRank: number;\n  percentileRank: number;\n  leaguesPlayed: number;\n  topLeague: string;\n  achievements: number;\n}\n\nexport interface CrossLeagueComparison {\n  playerId: string;\n  playerStats: {\n    totalGoals: number;\n    totalAssists: number;\n    totalGames: number;\n    averageGoalsPerGame: number;\n    totalMinutes: number;\n  };\n  leagueBreakdown: Array<{\n    leagueId: string;\n    leagueName: string;\n    sportType: string;\n    goals: number;\n    assists: number;\n    games: number;\n    rank: number;\n    percentile: number;\n  }>;\n  globalComparison: {\n    betterThanPercent: number;\n    similarPlayers: Array<{\n      playerId: string;\n      displayName: string;\n      goals: number;\n      assists: number;\n    }>;\n  };\n}\n\nexport interface GlobalLeaderboard {\n  category: string;\n  timeframe: string;\n  sportType?: string;\n  players: Array<{\n    rank: number;\n    playerId: string;\n    displayName: string;\n    avatarUrl?: string;\n    value: number;\n    leagues: string[];\n    trend: 'up' | 'down' | 'same';\n  }>;\n}\n\nexport class AnalyticsService {\n  private static instance: AnalyticsService;\n  private supabase: any;\n  \n  private constructor() {}\n  \n  static getInstance(): AnalyticsService {\n    if (!AnalyticsService.instance) {\n      AnalyticsService.instance = new AnalyticsService();\n    }\n    return AnalyticsService.instance;\n  }\n  \n  setSupabaseClient(client: any) {\n    this.supabase = client;\n  }\n  \n  /**\n   * Get global player ranking across all leagues\n   */\n  async getGlobalPlayerRanking(playerId: string): Promise<GlobalPlayerRanking | null> {\n    const { data, error } = await this.supabase.rpc('get_global_player_ranking', {\n      player_id: playerId\n    });\n    \n    if (error) throw error;\n    return data;\n  }\n  \n  /**\n   * Compare player performance across different leagues\n   */\n  async comparePlayerAcrossLeagues(playerId: string): Promise<CrossLeagueComparison> {\n    // Get player stats across all leagues\n    const { data: playerStats, error: statsError } = await this.supabase\n      .from('player_stats')\n      .select(`\n        *,\n        leagues(id, name, sport_type),\n        teams(name)\n      `)\n      .eq('player_id', playerId);\n    \n    if (statsError) throw statsError;\n    \n    // Calculate aggregated stats\n    const totalStats = playerStats.reduce((acc, stat) => ({\n      totalGoals: acc.totalGoals + (stat.goals || 0),\n      totalAssists: acc.totalAssists + (stat.assists || 0),\n      totalGames: acc.totalGames + (stat.games_played || 0),\n      totalMinutes: acc.totalMinutes + (stat.minutes_played || 0)\n    }), { totalGoals: 0, totalAssists: 0, totalGames: 0, totalMinutes: 0 });\n    \n    // Get league-specific rankings\n    const leagueBreakdown = await Promise.all(\n      playerStats.map(async (stat) => {\n        const { data: ranking } = await this.supabase.rpc('get_league_player_ranking', {\n          league_id: stat.league_id,\n          player_id: playerId\n        });\n        \n        return {\n          leagueId: stat.league_id,\n          leagueName: stat.leagues.name,\n          sportType: stat.leagues.sport_type,\n          goals: stat.goals || 0,\n          assists: stat.assists || 0,\n          games: stat.games_played || 0,\n          rank: ranking?.rank || 0,\n          percentile: ranking?.percentile || 0\n        };\n      })\n    );\n    \n    // Get global comparison data\n    const { data: globalData } = await this.supabase.rpc('get_player_global_comparison', {\n      player_id: playerId,\n      total_goals: totalStats.totalGoals\n    });\n    \n    return {\n      playerId,\n      playerStats: {\n        ...totalStats,\n        averageGoalsPerGame: totalStats.totalGames > 0 \n          ? totalStats.totalGoals / totalStats.totalGames \n          : 0\n      },\n      leagueBreakdown,\n      globalComparison: globalData || {\n        betterThanPercent: 0,\n        similarPlayers: []\n      }\n    };\n  }\n  \n  /**\n   * Get global leaderboards with various filters\n   */\n  async getGlobalLeaderboards(options: {\n    category: 'goals' | 'assists' | 'games_played' | 'goals_per_game';\n    timeframe: 'current_season' | 'all_time' | 'last_30_days';\n    sportType?: string;\n    limit?: number;\n  }): Promise<GlobalLeaderboard> {\n    const { data, error } = await this.supabase.rpc('get_global_leaderboard', {\n      stat_category: options.category,\n      time_frame: options.timeframe,\n      sport_filter: options.sportType,\n      result_limit: options.limit || 50\n    });\n    \n    if (error) throw error;\n    \n    return {\n      category: options.category,\n      timeframe: options.timeframe,\n      sportType: options.sportType,\n      players: data || []\n    };\n  }\n  \n  /**\n   * Get player performance trends over time\n   */\n  async getPlayerTrends(playerId: string, timeframe: 'season' | 'career' = 'season'): Promise<{\n    goals: Array<{ period: string; value: number }>;\n    assists: Array<{ period: string; value: number }>;\n    gamesPlayed: Array<{ period: string; value: number }>;\n  }> {\n    const { data, error } = await this.supabase.rpc('get_player_trends', {\n      player_id: playerId,\n      time_frame: timeframe\n    });\n    \n    if (error) throw error;\n    return data || { goals: [], assists: [], gamesPlayed: [] };\n  }\n  \n  /**\n   * Compare teams across leagues\n   */\n  async compareTeamsAcrossLeagues(teamIds: string[]): Promise<Array<{\n    teamId: string;\n    teamName: string;\n    leagueName: string;\n    sportType: string;\n    points: number;\n    wins: number;\n    draws: number;\n    losses: number;\n    goalsFor: number;\n    goalsAgainst: number;\n    leagueRank: number;\n    globalRank: number;\n  }>> {\n    const { data, error } = await this.supabase.rpc('compare_teams_across_leagues', {\n      team_ids: teamIds\n    });\n    \n    if (error) throw error;\n    return data || [];\n  }\n  \n  /**\n   * Get league strength rankings\n   */\n  async getLeagueStrengthRankings(sportType?: string): Promise<Array<{\n    leagueId: string;\n    leagueName: string;\n    sportType: string;\n    strengthScore: number;\n    avgGoalsPerGame: number;\n    competitivenessIndex: number;\n    totalPlayers: number;\n    totalTeams: number;\n  }>> {\n    const { data, error } = await this.supabase.rpc('get_league_strength_rankings', {\n      sport_filter: sportType\n    });\n    \n    if (error) throw error;\n    return data || [];\n  }\n  \n  /**\n   * Get player's achievement progress compared to others\n   */\n  async getAchievementComparison(playerId: string): Promise<{\n    totalAchievements: number;\n    globalRank: number;\n    percentileRank: number;\n    recentAchievements: Array<{\n      achievementId: string;\n      name: string;\n      earnedAt: string;\n      rarity: number; // Percentage of players who have this\n    }>;\n    recommendedAchievements: Array<{\n      achievementId: string;\n      name: string;\n      description: string;\n      progress: number; // 0-100\n      requirements: any;\n    }>;\n  }> {\n    const { data, error } = await this.supabase.rpc('get_achievement_comparison', {\n      player_id: playerId\n    });\n    \n    if (error) throw error;\n    return data || {\n      totalAchievements: 0,\n      globalRank: 0,\n      percentileRank: 0,\n      recentAchievements: [],\n      recommendedAchievements: []\n    };\n  }\n  \n  /**\n   * Get comprehensive player profile for cross-league display\n   */\n  async getPlayerGlobalProfile(playerId: string): Promise<{\n    basicInfo: {\n      displayName: string;\n      avatarUrl?: string;\n      preferredPosition?: string;\n      location?: string;\n    };\n    globalStats: {\n      totalGoals: number;\n      totalAssists: number;\n      totalGames: number;\n      totalMinutes: number;\n      leaguesPlayed: number;\n      achievementsEarned: number;\n    };\n    rankings: {\n      globalGoalsRank: number;\n      globalAssistsRank: number;\n      globalGamesRank: number;\n      overallRank: number;\n    };\n    leagueHistory: Array<{\n      leagueId: string;\n      leagueName: string;\n      sportType: string;\n      season: string;\n      teamName: string;\n      stats: {\n        goals: number;\n        assists: number;\n        games: number;\n        rank: number;\n      };\n    }>;\n    similarPlayers: Array<{\n      playerId: string;\n      displayName: string;\n      similarityScore: number;\n      commonLeagues: string[];\n    }>;\n  }> {\n    const { data, error } = await this.supabase.rpc('get_player_global_profile', {\n      player_id: playerId\n    });\n    \n    if (error) throw error;\n    return data;\n  }\n  \n  /**\n   * Search and filter players across all leagues\n   */\n  async searchPlayersGlobally(options: {\n    query?: string;\n    sportType?: string;\n    position?: string;\n    minGoals?: number;\n    minGames?: number;\n    leagueIds?: string[];\n    limit?: number;\n  }): Promise<Array<{\n    playerId: string;\n    displayName: string;\n    avatarUrl?: string;\n    position?: string;\n    totalGoals: number;\n    totalAssists: number;\n    totalGames: number;\n    currentLeagues: string[];\n    globalRank: number;\n  }>> {\n    const { data, error } = await this.supabase.rpc('search_players_globally', options);\n    \n    if (error) throw error;\n    return data || [];\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4625, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/apps/player/src/lib/types/database.types.ts"],"sourcesContent":["/**\n * Database Types for MatchDay\n * \n * Generated TypeScript types for the database schema.\n * These types ensure type safety across the application.\n */\n\nexport interface Database {\n  public: {\n    Tables: {\n      user_profiles: {\n        Row: {\n          id: string;\n          full_name: string | null;\n          display_name: string | null;\n          avatar_url: string | null;\n          bio: string | null;\n          phone: string | null;\n          date_of_birth: string | null;\n          preferred_position: string | null;\n          location: string | null;\n          created_at: string;\n          updated_at: string;\n        };\n        Insert: {\n          id: string;\n          full_name?: string | null;\n          display_name?: string | null;\n          avatar_url?: string | null;\n          bio?: string | null;\n          phone?: string | null;\n          date_of_birth?: string | null;\n          preferred_position?: string | null;\n          location?: string | null;\n          created_at?: string;\n          updated_at?: string;\n        };\n        Update: {\n          id?: string;\n          full_name?: string | null;\n          display_name?: string | null;\n          avatar_url?: string | null;\n          bio?: string | null;\n          phone?: string | null;\n          date_of_birth?: string | null;\n          preferred_position?: string | null;\n          location?: string | null;\n          created_at?: string;\n          updated_at?: string;\n        };\n      };\n      leagues: {\n        Row: {\n          id: string;\n          name: string;\n          description: string | null;\n          sport_type: string;\n          league_type: string;\n          location: string | null;\n          season_start: string | null;\n          season_end: string | null;\n          max_teams: number | null;\n          entry_fee: number | null;\n          created_by: string | null;\n          is_active: boolean | null;\n          is_public: boolean | null;\n          season: string | null;\n          created_at: string;\n          updated_at: string;\n        };\n        Insert: {\n          id?: string;\n          name: string;\n          description?: string | null;\n          sport_type: string;\n          league_type: string;\n          location?: string | null;\n          season_start?: string | null;\n          season_end?: string | null;\n          max_teams?: number | null;\n          entry_fee?: number | null;\n          created_by?: string | null;\n          is_active?: boolean | null;\n          is_public?: boolean | null;\n          season?: string | null;\n          created_at?: string;\n          updated_at?: string;\n        };\n        Update: {\n          id?: string;\n          name?: string;\n          description?: string | null;\n          sport_type?: string;\n          league_type?: string;\n          location?: string | null;\n          season_start?: string | null;\n          season_end?: string | null;\n          max_teams?: number | null;\n          entry_fee?: number | null;\n          created_by?: string | null;\n          is_active?: boolean | null;\n          is_public?: boolean | null;\n          season?: string | null;\n          created_at?: string;\n          updated_at?: string;\n        };\n      };\n      teams: {\n        Row: {\n          id: string;\n          league_id: string | null;\n          name: string;\n          logo_url: string | null;\n          team_color: string | null;\n          captain_id: string | null;\n          max_players: number | null;\n          min_players: number | null;\n          is_recruiting: boolean | null;\n          team_bio: string | null;\n          is_archived: boolean | null;\n          previous_league_name: string | null;\n          created_at: string;\n          updated_at: string;\n        };\n        Insert: {\n          id?: string;\n          league_id?: string | null;\n          name: string;\n          logo_url?: string | null;\n          team_color?: string | null;\n          captain_id?: string | null;\n          max_players?: number | null;\n          min_players?: number | null;\n          is_recruiting?: boolean | null;\n          team_bio?: string | null;\n          is_archived?: boolean | null;\n          previous_league_name?: string | null;\n          created_at?: string;\n          updated_at?: string;\n        };\n        Update: {\n          id?: string;\n          league_id?: string | null;\n          name?: string;\n          logo_url?: string | null;\n          team_color?: string | null;\n          captain_id?: string | null;\n          max_players?: number | null;\n          min_players?: number | null;\n          is_recruiting?: boolean | null;\n          team_bio?: string | null;\n          is_archived?: boolean | null;\n          previous_league_name?: string | null;\n          created_at?: string;\n          updated_at?: string;\n        };\n      };\n      team_members: {\n        Row: {\n          id: string;\n          team_id: string;\n          user_id: string;\n          position: string | null;\n          jersey_number: number | null;\n          is_active: boolean | null;\n          joined_at: string;\n        };\n        Insert: {\n          id?: string;\n          team_id: string;\n          user_id: string;\n          position?: string | null;\n          jersey_number?: number | null;\n          is_active?: boolean | null;\n          joined_at?: string;\n        };\n        Update: {\n          id?: string;\n          team_id?: string;\n          user_id?: string;\n          position?: string | null;\n          jersey_number?: number | null;\n          is_active?: boolean | null;\n          joined_at?: string;\n        };\n      };\n      matches: {\n        Row: {\n          id: string;\n          league_id: string;\n          home_team_id: string;\n          away_team_id: string;\n          scheduled_date: string;\n          venue: string | null;\n          match_day: number | null;\n          status: string | null;\n          home_score: number | null;\n          away_score: number | null;\n          created_at: string;\n          updated_at: string;\n        };\n        Insert: {\n          id?: string;\n          league_id: string;\n          home_team_id: string;\n          away_team_id: string;\n          scheduled_date: string;\n          venue?: string | null;\n          match_day?: number | null;\n          status?: string | null;\n          home_score?: number | null;\n          away_score?: number | null;\n          created_at?: string;\n          updated_at?: string;\n        };\n        Update: {\n          id?: string;\n          league_id?: string;\n          home_team_id?: string;\n          away_team_id?: string;\n          scheduled_date?: string;\n          venue?: string | null;\n          match_day?: number | null;\n          status?: string | null;\n          home_score?: number | null;\n          away_score?: number | null;\n          created_at?: string;\n          updated_at?: string;\n        };\n      };\n      match_events: {\n        Row: {\n          id: string;\n          match_id: string;\n          team_id: string | null;\n          player_id: string | null;\n          event_type: string;\n          event_time: number | null;\n          description: string | null;\n          created_at: string;\n        };\n        Insert: {\n          id?: string;\n          match_id: string;\n          team_id?: string | null;\n          player_id?: string | null;\n          event_type: string;\n          event_time?: number | null;\n          description?: string | null;\n          created_at?: string;\n        };\n        Update: {\n          id?: string;\n          match_id?: string;\n          team_id?: string | null;\n          player_id?: string | null;\n          event_type?: string;\n          event_time?: number | null;\n          description?: string | null;\n          created_at?: string;\n        };\n      };\n      player_stats: {\n        Row: {\n          id: string;\n          player_id: string;\n          league_id: string;\n          team_id: string;\n          games_played: number | null;\n          goals: number | null;\n          assists: number | null;\n          yellow_cards: number | null;\n          red_cards: number | null;\n          minutes_played: number | null;\n          additional_stats: any | null;\n          updated_at: string;\n        };\n        Insert: {\n          id?: string;\n          player_id: string;\n          league_id: string;\n          team_id: string;\n          games_played?: number | null;\n          goals?: number | null;\n          assists?: number | null;\n          yellow_cards?: number | null;\n          red_cards?: number | null;\n          minutes_played?: number | null;\n          additional_stats?: any | null;\n          updated_at?: string;\n        };\n        Update: {\n          id?: string;\n          player_id?: string;\n          league_id?: string;\n          team_id?: string;\n          games_played?: number | null;\n          goals?: number | null;\n          assists?: number | null;\n          yellow_cards?: number | null;\n          red_cards?: number | null;\n          minutes_played?: number | null;\n          additional_stats?: any | null;\n          updated_at?: string;\n        };\n      };\n      team_stats: {\n        Row: {\n          id: string;\n          team_id: string;\n          league_id: string;\n          games_played: number | null;\n          wins: number | null;\n          draws: number | null;\n          losses: number | null;\n          goals_for: number | null;\n          goals_against: number | null;\n          points: number | null;\n          updated_at: string;\n        };\n        Insert: {\n          id?: string;\n          team_id: string;\n          league_id: string;\n          games_played?: number | null;\n          wins?: number | null;\n          draws?: number | null;\n          losses?: number | null;\n          goals_for?: number | null;\n          goals_against?: number | null;\n          points?: number | null;\n          updated_at?: string;\n        };\n        Update: {\n          id?: string;\n          team_id?: string;\n          league_id?: string;\n          games_played?: number | null;\n          wins?: number | null;\n          draws?: number | null;\n          losses?: number | null;\n          goals_for?: number | null;\n          goals_against?: number | null;\n          points?: number | null;\n          updated_at?: string;\n        };\n      };\n      achievements: {\n        Row: {\n          id: string;\n          name: string;\n          description: string | null;\n          icon: string | null;\n          category: string;\n          difficulty: string;\n          requirements: any;\n          points_value: number;\n          is_active: boolean;\n          is_repeatable: boolean;\n          sort_order: number;\n          created_at: string;\n        };\n        Insert: {\n          id?: string;\n          name: string;\n          description?: string | null;\n          icon?: string | null;\n          category: string;\n          difficulty?: string;\n          requirements: any;\n          points_value?: number;\n          is_active?: boolean;\n          is_repeatable?: boolean;\n          sort_order?: number;\n          created_at?: string;\n        };\n        Update: {\n          id?: string;\n          name?: string;\n          description?: string | null;\n          icon?: string | null;\n          category?: string;\n          difficulty?: string;\n          requirements?: any;\n          points_value?: number;\n          is_active?: boolean;\n          is_repeatable?: boolean;\n          sort_order?: number;\n          created_at?: string;\n        };\n      };\n      user_achievements: {\n        Row: {\n          id: string;\n          user_id: string;\n          achievement_id: string;\n          earned_at: string;\n          context: any | null;\n          league_id: string | null;\n          match_id: string | null;\n        };\n        Insert: {\n          id?: string;\n          user_id: string;\n          achievement_id: string;\n          earned_at?: string;\n          context?: any | null;\n          league_id?: string | null;\n          match_id?: string | null;\n        };\n        Update: {\n          id?: string;\n          user_id?: string;\n          achievement_id?: string;\n          earned_at?: string;\n          context?: any | null;\n          league_id?: string | null;\n          match_id?: string | null;\n        };\n      };\n      team_join_requests: {\n        Row: {\n          id: string;\n          team_id: string;\n          user_id: string;\n          message: string | null;\n          preferred_position: string | null;\n          requested_jersey_number: number | null;\n          status: string;\n          reviewed_by: string | null;\n          reviewed_at: string | null;\n          response_message: string | null;\n          created_at: string;\n          expires_at: string;\n        };\n        Insert: {\n          id?: string;\n          team_id: string;\n          user_id: string;\n          message?: string | null;\n          preferred_position?: string | null;\n          requested_jersey_number?: number | null;\n          status?: string;\n          reviewed_by?: string | null;\n          reviewed_at?: string | null;\n          response_message?: string | null;\n          created_at?: string;\n          expires_at?: string;\n        };\n        Update: {\n          id?: string;\n          team_id?: string;\n          user_id?: string;\n          message?: string | null;\n          preferred_position?: string | null;\n          requested_jersey_number?: number | null;\n          status?: string;\n          reviewed_by?: string | null;\n          reviewed_at?: string | null;\n          response_message?: string | null;\n          created_at?: string;\n          expires_at?: string;\n        };\n      };\n      app_configurations: {\n        Row: {\n          id: string;\n          value: any;\n          description: string | null;\n          is_public: boolean;\n          updated_at: string;\n          updated_by: string | null;\n        };\n        Insert: {\n          id: string;\n          value: any;\n          description?: string | null;\n          is_public?: boolean;\n          updated_at?: string;\n          updated_by?: string | null;\n        };\n        Update: {\n          id?: string;\n          value?: any;\n          description?: string | null;\n          is_public?: boolean;\n          updated_at?: string;\n          updated_by?: string | null;\n        };\n      };\n      team_invitations: {\n        Row: {\n          id: string;\n          team_id: string;\n          invited_by: string;\n          email: string | null;\n          position: string | null;\n          jersey_number: number | null;\n          message: string | null;\n          token: string;\n          status: 'pending' | 'accepted' | 'expired';\n          expires_at: string;\n          created_at: string;\n          updated_at: string;\n        };\n        Insert: {\n          id?: string;\n          team_id: string;\n          invited_by: string;\n          email?: string | null;\n          position?: string | null;\n          jersey_number?: number | null;\n          message?: string | null;\n          token?: string;\n          status?: 'pending' | 'accepted' | 'expired';\n          expires_at?: string;\n          created_at?: string;\n          updated_at?: string;\n        };\n        Update: {\n          id?: string;\n          team_id?: string;\n          invited_by?: string;\n          email?: string | null;\n          position?: string | null;\n          jersey_number?: number | null;\n          message?: string | null;\n          token?: string;\n          status?: 'pending' | 'accepted' | 'expired';\n          expires_at?: string;\n          created_at?: string;\n          updated_at?: string;\n        };\n      };\n    };\n    Views: {\n      league_standings: {\n        Row: {\n          id: string;\n          team_id: string;\n          league_id: string;\n          season_year: number;\n          games_played: number;\n          wins: number;\n          draws: number;\n          losses: number;\n          goals_for: number;\n          goals_against: number;\n          points: number;\n          clean_sheets: number;\n          team_name: string;\n          logo_url: string | null;\n          team_color: string | null;\n          league_name: string;\n          sport_type: string;\n          goal_difference: number;\n          points_percentage: number;\n          position: number;\n        };\n      };\n      player_leaderboard: {\n        Row: {\n          id: string;\n          player_id: string;\n          league_id: string;\n          team_id: string;\n          season_year: number;\n          games_played: number;\n          games_started: number;\n          goals: number;\n          assists: number;\n          yellow_cards: number;\n          red_cards: number;\n          minutes_played: number;\n          shots_on_target: number;\n          passes_completed: number;\n          passes_attempted: number;\n          tackles_won: number;\n          display_name: string;\n          avatar_url: string | null;\n          preferred_position: string | null;\n          team_name: string;\n          team_logo: string | null;\n          team_color: string | null;\n          league_name: string;\n          sport_type: string;\n          goals_per_game: number;\n          goal_contributions_per_game: number;\n          goals_per_90_minutes: number;\n          pass_accuracy: number;\n        };\n      };\n      player_cross_league_stats: {\n        Row: {\n          player_id: string;\n          display_name: string;\n          avatar_url: string | null;\n          preferred_position: string | null;\n          season_year: number;\n          leagues_played: number;\n          teams_played: number;\n          total_games_played: number;\n          total_goals: number;\n          total_assists: number;\n          total_minutes_played: number;\n          avg_goals_per_game: number;\n          avg_contributions_per_game: number;\n          best_goals_in_league: number;\n          best_assists_in_league: number;\n          goals_consistency: number | null;\n        };\n      };\n      active_matches: {\n        Row: {\n          id: string;\n          league_id: string;\n          scheduled_date: string;\n          venue: string | null;\n          status: string;\n          home_score: number;\n          away_score: number;\n          match_duration: number | null;\n          league_name: string;\n          sport_type: string;\n          home_team_id: string;\n          home_team_name: string;\n          home_team_logo: string | null;\n          home_team_color: string | null;\n          away_team_id: string;\n          away_team_name: string;\n          away_team_logo: string | null;\n          away_team_color: string | null;\n          total_events: number;\n          latest_event_type: string | null;\n          latest_event_time: number | null;\n        };\n      };\n    };\n  };\n}\n\n// Utility types for common operations\nexport type UserProfile = Database['public']['Tables']['user_profiles']['Row'];\nexport type League = Database['public']['Tables']['leagues']['Row'];\nexport type Team = Database['public']['Tables']['teams']['Row'];\nexport type TeamMember = Database['public']['Tables']['team_members']['Row'];\nexport type Match = Database['public']['Tables']['matches']['Row'];\nexport type MatchEvent = Database['public']['Tables']['match_events']['Row'];\nexport type PlayerStats = Database['public']['Tables']['player_stats']['Row'];\nexport type TeamStats = Database['public']['Tables']['team_stats']['Row'];\nexport type Achievement = Database['public']['Tables']['achievements']['Row'];\nexport type UserAchievement = Database['public']['Tables']['user_achievements']['Row'];\nexport type TeamJoinRequest = Database['public']['Tables']['team_join_requests']['Row'];\nexport type TeamInvitation = Database['public']['Tables']['team_invitations']['Row'];\nexport type AppConfiguration = Database['public']['Tables']['app_configurations']['Row'];\n\n// Insert types\nexport type InsertLeague = Database['public']['Tables']['leagues']['Insert'];\nexport type InsertTeam = Database['public']['Tables']['teams']['Insert'];\nexport type InsertMatch = Database['public']['Tables']['matches']['Insert'];\n\n// Update types\nexport type UpdateLeague = Database['public']['Tables']['leagues']['Update'];\nexport type UpdateTeam = Database['public']['Tables']['teams']['Update'];\nexport type UpdateMatch = Database['public']['Tables']['matches']['Update'];\nexport type UpdateUserProfile = Database['public']['Tables']['user_profiles']['Update'];\nexport type UpdatePlayerStats = Database['public']['Tables']['player_stats']['Update'];\n\n// View types\nexport type LeagueStanding = Database['public']['Views']['league_standings']['Row'];\nexport type PlayerLeaderboard = Database['public']['Views']['player_leaderboard']['Row'];\nexport type PlayerCrossLeagueStats = Database['public']['Views']['player_cross_league_stats']['Row'];\nexport type ActiveMatch = Database['public']['Views']['active_matches']['Row'];\n\n// Enums for type safety\nexport enum SportType {\n  FOOTBALL = 'football'\n}\n\nexport enum LeagueType {\n  COMPETITIVE = 'competitive',\n  CASUAL = 'casual',\n  TOURNAMENT = 'tournament',\n  FRIENDLY = 'friendly'\n}\n\nexport enum MatchStatus {\n  SCHEDULED = 'scheduled',\n  LIVE = 'live',\n  COMPLETED = 'completed',\n  POSTPONED = 'postponed',\n  CANCELLED = 'cancelled'\n}\n\nexport enum EventType {\n  GOAL = 'goal',\n  ASSIST = 'assist',\n  YELLOW_CARD = 'yellow_card',\n  RED_CARD = 'red_card',\n  SUBSTITUTION = 'substitution',\n  INJURY = 'injury',\n  TIMEOUT = 'timeout'\n}\n\nexport enum AchievementCategory {\n  GOALS = 'goals',\n  ASSISTS = 'assists',\n  MATCHES = 'matches',\n  TEAM_PLAY = 'team_play',\n  CONSISTENCY = 'consistency',\n  MILESTONES = 'milestones',\n  LEADERSHIP = 'leadership'\n}\n\nexport enum AchievementDifficulty {\n  BRONZE = 'bronze',\n  SILVER = 'silver',\n  GOLD = 'gold',\n  PLATINUM = 'platinum'\n}\n\nexport enum JoinRequestStatus {\n  PENDING = 'pending',\n  APPROVED = 'approved',\n  REJECTED = 'rejected',\n  WITHDRAWN = 'withdrawn'\n}\n\nexport enum InvitationStatus {\n  PENDING = 'pending',\n  ACCEPTED = 'accepted',\n  EXPIRED = 'expired'\n}\n\n// Complex types for forms and API responses\nexport interface PlayerProfile extends UserProfile {\n  teams?: Array<{\n    team: Team;\n    league: League;\n    position?: string;\n    jersey_number?: number;\n    is_active?: boolean;\n  }>;\n  stats?: PlayerStats[];\n  achievements?: Array<{\n    achievement: Achievement;\n    earned_at: string;\n    context?: any;\n  }>;\n}\n\nexport interface LeagueWithDetails extends League {\n  teams?: Team[];\n  matches?: Match[];\n  creator?: UserProfile;\n  stats?: {\n    total_teams: number;\n    total_players: number;\n    total_matches: number;\n    completed_matches: number;\n  };\n}\n\nexport interface MatchWithDetails extends Match {\n  home_team: Team;\n  away_team: Team;\n  league: League;\n  events?: MatchEvent[];\n  players?: {\n    home_players: UserProfile[];\n    away_players: UserProfile[];\n  };\n}\n\n// Form validation schemas (for use with react-hook-form + zod)\nexport interface CreateLeagueForm {\n  name: string;\n  description?: string;\n  sport_type: SportType;\n  league_type: LeagueType;\n  location?: string;\n  season_start?: string;\n  season_end?: string;\n  max_teams?: number;\n  entry_fee?: number;\n}\n\nexport interface CreateTeamForm {\n  name: string;\n  league_id: string;\n  sport: string;\n  league: string;\n  description?: string;\n  max_players?: number;\n  min_players?: number;\n  location?: string;\n  team_color?: string;\n}\n\nexport interface JoinTeamForm {\n  team_id: string;\n  position?: string;\n  jersey_number?: number;\n}\n\nexport interface UpdateProfileForm {\n  display_name: string;\n  bio?: string;\n  preferred_position?: string;\n  location?: string;\n  date_of_birth?: string;\n}\n\nexport interface SendInvitationForm {\n  email: string;\n  position?: string;\n  jersey_number?: number;\n  message?: string;\n}\n\n// API Response types\nexport interface ApiResponse<T = any> {\n  data: T;\n  error?: string;\n  message?: string;\n}\n\nexport interface PaginatedResponse<T = any> {\n  data: T[];\n  count: number;\n  page: number;\n  per_page: number;\n  total_pages: number;\n}\n\n// Real-time types for live features\nexport interface LiveMatchUpdate {\n  match_id: string;\n  event_type: EventType;\n  event_time: number;\n  player_id?: string;\n  team_id?: string;\n  description?: string;\n  score_update?: {\n    home_score: number;\n    away_score: number;\n  };\n}\n\nexport interface PlayerStatsSummary {\n  player_id: string;\n  total_goals: number;\n  total_assists: number;\n  total_matches: number;\n  total_minutes: number;\n  goals_per_game: number;\n  current_league_stats?: PlayerStats;\n}\n\n// Cross-league comparison types\nexport interface CrossLeaguePlayerStats {\n  player_id: string;\n  player_name: string;\n  leagues: Array<{\n    league: League;\n    stats: PlayerStats;\n    team: Team;\n  }>;\n  overall_stats: PlayerStatsSummary;\n}\n\n// Service Response Types\nexport interface ServiceResponse<T = any> {\n  data: T | null;\n  error: ServiceError | null;\n  success: boolean;\n  message?: string;\n}\n\nexport interface ServiceError {\n  code: string;\n  message: string;\n  details?: any;\n  timestamp: string;\n}\n\nexport interface PaginatedServiceResponse<T = any> extends ServiceResponse<T[]> {\n  pagination?: {\n    page: number;\n    limit: number;\n    total: number;\n    totalPages: number;\n    hasNext: boolean;\n    hasPrevious: boolean;\n  };\n}\n\n// Player Service Types\nexport interface PlayerProfileExtended extends UserProfile {\n  teams: Array<{\n    team: Team & { league: League };\n    membership: TeamMember;\n  }>;\n  achievements: Array<{\n    achievement: Achievement;\n    userAchievement: UserAchievement;\n  }>;\n  crossLeagueStats: PlayerCrossLeagueStats | null;\n  globalRankings: {\n    goals: { rank: number; total: number; percentile: number } | null;\n    assists: { rank: number; total: number; percentile: number } | null;\n    matches: { rank: number; total: number; percentile: number } | null;\n  };\n}\n\n// League Service Types\nexport interface LeagueDiscovery extends League {\n  teams: Team[];\n  teamCount: number;\n  playerCount: number;\n  availableSpots: number;\n  joinRequests?: TeamJoinRequest[];\n  isUserMember: boolean;\n  compatibilityScore?: number;\n}\n\nexport interface LeagueFilters {\n  sportType?: SportType;\n  leagueType?: LeagueType;\n  location?: string;\n  maxDistance?: number;\n  entryFeeMax?: number;\n  hasAvailableSpots?: boolean;\n  seasonActive?: boolean;\n  search?: string;\n}\n\n// Match Service Types\nexport interface MatchWithDetails extends Match {\n  homeTeam: Team;\n  awayTeam: Team;\n  league: League;\n  events: MatchEvent[];\n  homeTeamPlayers: UserProfile[];\n  awayTeamPlayers: UserProfile[];\n  playerStats?: Array<{\n    player: UserProfile;\n    stats: {\n      goals: number;\n      assists: number;\n      cards: number;\n      minutesPlayed: number;\n    };\n  }>;\n}\n\nexport interface LiveMatchData {\n  match: MatchWithDetails;\n  recentEvents: MatchEvent[];\n  liveStats: {\n    homeTeamStats: { [key: string]: number };\n    awayTeamStats: { [key: string]: number };\n    playerStats: { [playerId: string]: any };\n  };\n}\n\n// Achievement Service Types\nexport interface PlayerAchievementProgress {\n  achievement: Achievement;\n  currentProgress: number;\n  targetValue: number;\n  progressPercentage: number;\n  isCompleted: boolean;\n  estimatedCompletion?: string;\n  nextMilestone?: number;\n}\n\nexport interface AchievementBadge {\n  id: string;\n  name: string;\n  description: string;\n  icon: string;\n  category: AchievementCategory;\n  difficulty: AchievementDifficulty;\n  earnedAt?: string;\n  context?: any;\n  rarity: {\n    totalEarned: number;\n    totalPlayers: number;\n    rarityPercentage: number;\n  };\n}\n\n// Stats Service Types\nexport interface PerformanceTrend {\n  period: string; // YYYY-MM or YYYY-WW\n  goals: number;\n  assists: number;\n  matches: number;\n  performance: number;\n}\n\nexport interface GlobalRanking {\n  playerId: string;\n  displayName: string;\n  avatarUrl?: string;\n  rank: number;\n  statValue: number;\n  trend: 'up' | 'down' | 'stable';\n  previousRank?: number;\n}\n\nexport interface LeagueComparison {\n  league: League;\n  playerStats: PlayerStats;\n  teamRank: number;\n  leagueRank: number;\n  performance: {\n    goalsPerGame: number;\n    assistsPerGame: number;\n    winRate: number;\n    consistency: number;\n  };\n}\n\n// Real-time Subscription Types\nexport interface RealtimeSubscriptionOptions {\n  table: string;\n  filter?: string;\n  event?: 'INSERT' | 'UPDATE' | 'DELETE' | '*';\n  schema?: string;\n}\n\nexport interface CacheOptions {\n  ttl?: number; // Time to live in seconds\n  key?: string;\n  tags?: string[];\n  revalidateOnBackground?: boolean;\n}"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;;;;;AA8pBM,IAAA,AAAK,mCAAA;;WAAA;;AAIL,IAAA,AAAK,oCAAA;;;;;WAAA;;AAOL,IAAA,AAAK,qCAAA;;;;;;WAAA;;AAQL,IAAA,AAAK,mCAAA;;;;;;;;WAAA;;AAUL,IAAA,AAAK,6CAAA;;;;;;;;WAAA;;AAUL,IAAA,AAAK,+CAAA;;;;;WAAA;;AAOL,IAAA,AAAK,2CAAA;;;;;WAAA;;AAOL,IAAA,AAAK,0CAAA;;;;WAAA","debugId":null}},
    {"offset": {"line": 4703, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/achievement.service.ts"],"sourcesContent":["/**\n * Achievement Service for MatchDay\n * \n * Handles comprehensive achievement and gamification operations with focus on:\n * - Player achievements and progress tracking\n * - Badge system and rarity calculations\n * - Cross-league milestone tracking\n * - Achievement recommendation system\n * \n * Optimized for motivating player engagement through gamification\n */\n\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport {\n  Database,\n  Achievement,\n  UserAchievement,\n  AchievementBadge,\n  PlayerAchievementProgress,\n  ServiceResponse,\n  ServiceError,\n  PaginatedServiceResponse,\n  AchievementCategory,\n  AchievementDifficulty,\n  CacheOptions,\n  RealtimeSubscriptionOptions\n} from '@/lib/types/database.types';\n\nexport interface AchievementFilters {\n  category?: AchievementCategory;\n  difficulty?: AchievementDifficulty;\n  isActive?: boolean;\n  earned?: boolean;\n  inProgress?: boolean;\n  search?: string;\n}\n\nexport interface AchievementStats {\n  totalAchievements: number;\n  earnedAchievements: number;\n  totalPoints: number;\n  earnedPoints: number;\n  completionPercentage: number;\n  categoryProgress: {\n    [key in AchievementCategory]: {\n      total: number;\n      earned: number;\n      points: number;\n      percentage: number;\n    };\n  };\n  difficultyProgress: {\n    [key in AchievementDifficulty]: {\n      total: number;\n      earned: number;\n      points: number;\n    };\n  };\n  recentAchievements: UserAchievement[];\n  nextMilestones: PlayerAchievementProgress[];\n}\n\nexport interface AchievementRecommendation {\n  achievement: Achievement;\n  priority: number;\n  reasonCode: 'close_to_completion' | 'category_focus' | 'difficulty_progression' | 'seasonal_bonus';\n  reason: string;\n  estimatedEffort: 'low' | 'medium' | 'high';\n  estimatedTimeToComplete: string;\n  tips: string[];\n}\n\nexport interface LeaderboardEntry {\n  playerId: string;\n  playerName: string;\n  avatarUrl?: string;\n  totalPoints: number;\n  totalAchievements: number;\n  recentAchievements: number;\n  rank: number;\n  trend: 'up' | 'down' | 'stable';\n}\n\nexport class AchievementService {\n  private static instance: AchievementService;\n  private supabase: SupabaseClient<Database>;\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n\n  private constructor(supabaseClient: SupabaseClient<Database>) {\n    this.supabase = supabaseClient;\n  }\n\n  static getInstance(supabaseClient?: SupabaseClient<Database>): AchievementService {\n    if (!AchievementService.instance) {\n      if (!supabaseClient) {\n        throw new Error('SupabaseClient required for first initialization');\n      }\n      AchievementService.instance = new AchievementService(supabaseClient);\n    }\n    return AchievementService.instance;\n  }\n\n  /**\n   * Handle service errors consistently\n   */\n  private handleError(error: any, operation: string): ServiceError {\n    console.error(`AchievementService.${operation}:`, error);\n    return {\n      code: error.code || 'UNKNOWN_ERROR',\n      message: error.message || 'An unexpected error occurred',\n      details: error.details || error,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Cache management utilities\n   */\n  private getCacheKey(operation: string, params: any): string {\n    return `achievement_service:${operation}:${JSON.stringify(params)}`;\n  }\n\n  private getFromCache<T>(key: string): T | null {\n    const cached = this.cache.get(key);\n    if (!cached) return null;\n    \n    if (Date.now() - cached.timestamp > cached.ttl * 1000) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return cached.data as T;\n  }\n\n  private setCache<T>(key: string, data: T, ttl = 600): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl\n    });\n  }\n\n  /**\n   * Get comprehensive achievement statistics for a player\n   */\n  async getPlayerAchievementStats(\n    userId: string,\n    options: CacheOptions = {}\n  ): Promise<ServiceResponse<AchievementStats>> {\n    try {\n      const cacheKey = this.getCacheKey('getPlayerAchievementStats', { userId });\n      const cached = this.getFromCache<AchievementStats>(cacheKey);\n      \n      if (cached && !options.revalidateOnBackground) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Get all achievements\n      const { data: allAchievements, error: achievementsError } = await this.supabase\n        .from('achievements')\n        .select('*')\n        .eq('is_active', true)\n        .order('sort_order');\n\n      if (achievementsError) throw achievementsError;\n\n      // Get user's earned achievements\n      const { data: userAchievements, error: userError } = await this.supabase\n        .from('user_achievements')\n        .select(`\n          *,\n          achievement:achievements!inner(*)\n        `)\n        .eq('user_id', userId)\n        .order('earned_at', { ascending: false });\n\n      if (userError) throw userError;\n\n      // Get player stats for progress calculation\n      const { data: playerStats } = await this.supabase\n        .from('player_cross_league_stats')\n        .select('*')\n        .eq('player_id', userId)\n        .eq('season_year', new Date().getFullYear())\n        .single();\n\n      const totalAchievements = allAchievements?.length || 0;\n      const earnedAchievements = userAchievements?.length || 0;\n      const totalPoints = allAchievements?.reduce((sum, a) => sum + a.points_value, 0) || 0;\n      const earnedPoints = userAchievements?.reduce((sum, ua) => sum + ua.achievement.points_value, 0) || 0;\n\n      // Calculate category progress\n      const categoryProgress = this.calculateCategoryProgress(allAchievements || [], userAchievements || []);\n      \n      // Calculate difficulty progress\n      const difficultyProgress = this.calculateDifficultyProgress(allAchievements || [], userAchievements || []);\n\n      // Get recent achievements (last 30 days)\n      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n      const recentAchievements = userAchievements?.filter(\n        ua => new Date(ua.earned_at) >= thirtyDaysAgo\n      ) || [];\n\n      // Calculate next milestones\n      const nextMilestones = this.calculateNextMilestones(\n        allAchievements || [],\n        userAchievements || [],\n        playerStats\n      );\n\n      const stats: AchievementStats = {\n        totalAchievements,\n        earnedAchievements,\n        totalPoints,\n        earnedPoints,\n        completionPercentage: totalAchievements > 0 ? Math.round((earnedAchievements / totalAchievements) * 100) : 0,\n        categoryProgress,\n        difficultyProgress,\n        recentAchievements,\n        nextMilestones\n      };\n\n      // Cache for 5 minutes\n      this.setCache(cacheKey, stats, options.ttl || 300);\n\n      return { data: stats, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerAchievementStats'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get player's achievement badges with rarity information\n   */\n  async getPlayerAchievementBadges(\n    userId: string,\n    filters: AchievementFilters = {},\n    options: { limit?: number; offset?: number } = {}\n  ): Promise<PaginatedServiceResponse<AchievementBadge>> {\n    try {\n      // Build query for user achievements\n      let query = this.supabase\n        .from('user_achievements')\n        .select(`\n          *,\n          achievement:achievements!inner(*)\n        `, { count: 'exact' })\n        .eq('user_id', userId);\n\n      if (filters.category) {\n        query = query.eq('achievement.category', filters.category);\n      }\n\n      if (filters.difficulty) {\n        query = query.eq('achievement.difficulty', filters.difficulty);\n      }\n\n      if (filters.search) {\n        query = query.ilike('achievement.name', `%${filters.search}%`);\n      }\n\n      const { data: userAchievements, error, count } = await query\n        .order('earned_at', { ascending: false })\n        .range(options.offset || 0, (options.offset || 0) + (options.limit || 20) - 1);\n\n      if (error) throw error;\n\n      // Calculate rarity for each achievement\n      const badges: AchievementBadge[] = await Promise.all(\n        (userAchievements || []).map(async (ua) => {\n          const rarity = await this.calculateAchievementRarity(ua.achievement_id);\n          \n          return {\n            id: ua.achievement.id,\n            name: ua.achievement.name,\n            description: ua.achievement.description || '',\n            icon: ua.achievement.icon || '',\n            category: ua.achievement.category as AchievementCategory,\n            difficulty: ua.achievement.difficulty as AchievementDifficulty,\n            earnedAt: ua.earned_at,\n            context: ua.context,\n            rarity: rarity.data || {\n              totalEarned: 0,\n              totalPlayers: 1,\n              rarityPercentage: 100\n            }\n          };\n        })\n      );\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n        limit: options.limit || 20,\n        total: count || 0,\n        totalPages: Math.ceil((count || 0) / (options.limit || 20)),\n        hasNext: ((options.offset || 0) + (options.limit || 20)) < (count || 0),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: badges,\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerAchievementBadges'),\n        success: false,\n        pagination: {\n          page: 1,\n          limit: options.limit || 20,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrevious: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Get achievement progress tracking with detailed metrics\n   */\n  async getAchievementProgress(\n    userId: string,\n    filters: AchievementFilters = {},\n    options: { limit?: number; offset?: number } = {}\n  ): Promise<PaginatedServiceResponse<PlayerAchievementProgress>> {\n    try {\n      // Get all available achievements\n      let query = this.supabase\n        .from('achievements')\n        .select('*', { count: 'exact' })\n        .eq('is_active', true);\n\n      if (filters.category) {\n        query = query.eq('category', filters.category);\n      }\n\n      if (filters.difficulty) {\n        query = query.eq('difficulty', filters.difficulty);\n      }\n\n      if (filters.search) {\n        query = query.ilike('name', `%${filters.search}%`);\n      }\n\n      const { data: achievements, error, count } = await query\n        .order('sort_order')\n        .range(options.offset || 0, (options.offset || 0) + (options.limit || 50) - 1);\n\n      if (error) throw error;\n\n      // Get user's earned achievements\n      const { data: userAchievements, error: userError } = await this.supabase\n        .from('user_achievements')\n        .select('achievement_id, earned_at')\n        .eq('user_id', userId);\n\n      if (userError) throw userError;\n\n      // Get player stats for progress calculation\n      const { data: playerStats } = await this.supabase\n        .from('player_cross_league_stats')\n        .select('*')\n        .eq('player_id', userId)\n        .eq('season_year', new Date().getFullYear())\n        .single();\n\n      const earnedAchievementIds = new Set(userAchievements?.map(ua => ua.achievement_id) || []);\n\n      // Calculate progress for each achievement\n      const achievementProgress: PlayerAchievementProgress[] = (achievements || [])\n        .map(achievement => {\n          const isCompleted = earnedAchievementIds.has(achievement.id);\n          \n          if (isCompleted) {\n            return {\n              achievement,\n              currentProgress: 1,\n              targetValue: 1,\n              progressPercentage: 100,\n              isCompleted: true\n            };\n          }\n\n          // Calculate progress based on requirements\n          const progress = this.calculateAchievementProgress(achievement, playerStats);\n          return {\n            achievement,\n            currentProgress: progress.current,\n            targetValue: progress.target,\n            progressPercentage: progress.percentage,\n            isCompleted: false,\n            estimatedCompletion: progress.estimatedCompletion,\n            nextMilestone: progress.nextMilestone\n          };\n        });\n\n      // Apply filters\n      let filteredProgress = achievementProgress;\n      \n      if (filters.earned === true) {\n        filteredProgress = filteredProgress.filter(ap => ap.isCompleted);\n      } else if (filters.earned === false) {\n        filteredProgress = filteredProgress.filter(ap => !ap.isCompleted);\n      }\n\n      if (filters.inProgress === true) {\n        filteredProgress = filteredProgress.filter(ap => \n          !ap.isCompleted && ap.progressPercentage > 0\n        );\n      }\n\n      // Sort by progress percentage (closest to completion first)\n      filteredProgress.sort((a, b) => {\n        if (a.isCompleted && !b.isCompleted) return 1;\n        if (!a.isCompleted && b.isCompleted) return -1;\n        return b.progressPercentage - a.progressPercentage;\n      });\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 50)) + 1,\n        limit: options.limit || 50,\n        total: count || 0,\n        totalPages: Math.ceil((count || 0) / (options.limit || 50)),\n        hasNext: ((options.offset || 0) + (options.limit || 50)) < (count || 0),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: filteredProgress,\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getAchievementProgress'),\n        success: false,\n        pagination: {\n          page: 1,\n          limit: options.limit || 50,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrevious: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Get personalized achievement recommendations\n   */\n  async getAchievementRecommendations(\n    userId: string,\n    options: { limit?: number; focusCategory?: AchievementCategory } = {}\n  ): Promise<ServiceResponse<AchievementRecommendation[]>> {\n    try {\n      const cacheKey = this.getCacheKey('getAchievementRecommendations', { userId, options });\n      const cached = this.getFromCache<AchievementRecommendation[]>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Get player's achievement progress\n      const progressResponse = await this.getAchievementProgress(userId, {\n        earned: false\n      });\n\n      if (!progressResponse.success || !progressResponse.data) {\n        throw new Error('Failed to get achievement progress');\n      }\n\n      const progress = progressResponse.data;\n      \n      // Get player stats for context\n      const { data: playerStats } = await this.supabase\n        .from('player_cross_league_stats')\n        .select('*')\n        .eq('player_id', userId)\n        .eq('season_year', new Date().getFullYear())\n        .single();\n\n      // Generate recommendations\n      const recommendations: AchievementRecommendation[] = progress\n        .filter(ap => !ap.isCompleted)\n        .map(ap => this.generateRecommendation(ap, playerStats))\n        .sort((a, b) => b.priority - a.priority)\n        .slice(0, options.limit || 10);\n\n      // Cache for 30 minutes\n      this.setCache(cacheKey, recommendations, 1800);\n\n      return { data: recommendations, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getAchievementRecommendations'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get achievement leaderboard\n   */\n  async getAchievementLeaderboard(\n    options: {\n      period?: 'all_time' | 'monthly' | 'weekly';\n      category?: AchievementCategory;\n      limit?: number;\n      offset?: number;\n    } = {}\n  ): Promise<PaginatedServiceResponse<LeaderboardEntry>> {\n    try {\n      const cacheKey = this.getCacheKey('getAchievementLeaderboard', { options });\n      const cached = this.getFromCache<LeaderboardEntry[]>(cacheKey);\n      \n      if (cached) {\n        return {\n          data: cached,\n          error: null,\n          success: true,\n          pagination: {\n            page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n            limit: options.limit || 20,\n            total: cached.length,\n            totalPages: Math.ceil(cached.length / (options.limit || 20)),\n            hasNext: false,\n            hasPrevious: false\n          }\n        };\n      }\n\n      // Build query based on period\n      let dateFilter = '';\n      if (options.period === 'monthly') {\n        const monthAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n        dateFilter = `and earned_at >= '${monthAgo.toISOString()}'`;\n      } else if (options.period === 'weekly') {\n        const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);\n        dateFilter = `and earned_at >= '${weekAgo.toISOString()}'`;\n      }\n\n      // Use RPC function for complex leaderboard calculation\n      const { data: leaderboard, error } = await this.supabase\n        .rpc('get_achievement_leaderboard', {\n          date_filter: dateFilter,\n          category_filter: options.category || null,\n          limit_count: options.limit || 50,\n          offset_count: options.offset || 0\n        });\n\n      if (error) throw error;\n\n      const leaderboardEntries: LeaderboardEntry[] = (leaderboard || []).map((entry, index) => ({\n        playerId: entry.player_id,\n        playerName: entry.player_name,\n        avatarUrl: entry.avatar_url,\n        totalPoints: entry.total_points,\n        totalAchievements: entry.total_achievements,\n        recentAchievements: entry.recent_achievements || 0,\n        rank: (options.offset || 0) + index + 1,\n        trend: 'stable' as const // Would need historical data to calculate trend\n      }));\n\n      // Cache for 10 minutes\n      this.setCache(cacheKey, leaderboardEntries, 600);\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n        limit: options.limit || 20,\n        total: leaderboardEntries.length,\n        totalPages: Math.ceil(leaderboardEntries.length / (options.limit || 20)),\n        hasNext: leaderboardEntries.length === (options.limit || 20),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: leaderboardEntries,\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getAchievementLeaderboard'),\n        success: false,\n        pagination: {\n          page: 1,\n          limit: options.limit || 20,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrevious: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Calculate achievement rarity\n   */\n  async calculateAchievementRarity(\n    achievementId: string\n  ): Promise<ServiceResponse<{\n    totalEarned: number;\n    totalPlayers: number;\n    rarityPercentage: number;\n  }>> {\n    try {\n      const { data, error } = await this.supabase\n        .rpc('calculate_achievement_rarity', { achievement_id: achievementId });\n\n      if (error) throw error;\n\n      return {\n        data: data || { totalEarned: 0, totalPlayers: 1, rarityPercentage: 100 },\n        error: null,\n        success: true\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'calculateAchievementRarity'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n  private calculateCategoryProgress(\n    allAchievements: Achievement[],\n    userAchievements: Array<{ achievement: Achievement }>\n  ) {\n    const categories = Object.values(AchievementCategory);\n    const result: any = {};\n\n    categories.forEach(category => {\n      const categoryAchievements = allAchievements.filter(a => a.category === category);\n      const earnedCategoryAchievements = userAchievements.filter(ua => ua.achievement.category === category);\n      \n      result[category] = {\n        total: categoryAchievements.length,\n        earned: earnedCategoryAchievements.length,\n        points: earnedCategoryAchievements.reduce((sum, ua) => sum + ua.achievement.points_value, 0),\n        percentage: categoryAchievements.length > 0 \n          ? Math.round((earnedCategoryAchievements.length / categoryAchievements.length) * 100) \n          : 0\n      };\n    });\n\n    return result;\n  }\n\n  private calculateDifficultyProgress(\n    allAchievements: Achievement[],\n    userAchievements: Array<{ achievement: Achievement }>\n  ) {\n    const difficulties = Object.values(AchievementDifficulty);\n    const result: any = {};\n\n    difficulties.forEach(difficulty => {\n      const difficultyAchievements = allAchievements.filter(a => a.difficulty === difficulty);\n      const earnedDifficultyAchievements = userAchievements.filter(ua => ua.achievement.difficulty === difficulty);\n      \n      result[difficulty] = {\n        total: difficultyAchievements.length,\n        earned: earnedDifficultyAchievements.length,\n        points: earnedDifficultyAchievements.reduce((sum, ua) => sum + ua.achievement.points_value, 0)\n      };\n    });\n\n    return result;\n  }\n\n  private calculateNextMilestones(\n    allAchievements: Achievement[],\n    userAchievements: Array<{ achievement: Achievement }>,\n    playerStats: any\n  ): PlayerAchievementProgress[] {\n    const earnedIds = new Set(userAchievements.map(ua => ua.achievement.id));\n    \n    return allAchievements\n      .filter(a => !earnedIds.has(a.id))\n      .map(achievement => {\n        const progress = this.calculateAchievementProgress(achievement, playerStats);\n        return {\n          achievement,\n          currentProgress: progress.current,\n          targetValue: progress.target,\n          progressPercentage: progress.percentage,\n          isCompleted: false,\n          estimatedCompletion: progress.estimatedCompletion,\n          nextMilestone: progress.nextMilestone\n        };\n      })\n      .filter(ap => ap.progressPercentage > 0)\n      .sort((a, b) => b.progressPercentage - a.progressPercentage)\n      .slice(0, 5);\n  }\n\n  private calculateAchievementProgress(achievement: Achievement, playerStats: any) {\n    const requirements = achievement.requirements as any;\n    let current = 0;\n    let target = 1;\n\n    if (requirements.goals && playerStats) {\n      current = playerStats.total_goals || 0;\n      target = requirements.goals;\n    } else if (requirements.assists && playerStats) {\n      current = playerStats.total_assists || 0;\n      target = requirements.assists;\n    } else if (requirements.matches_played && playerStats) {\n      current = playerStats.total_games_played || 0;\n      target = requirements.matches_played;\n    } else if (requirements.leagues_played && playerStats) {\n      current = playerStats.leagues_played || 0;\n      target = requirements.leagues_played;\n    }\n\n    const percentage = target > 0 ? Math.min(100, Math.round((current / target) * 100)) : 0;\n    \n    // Estimate completion time based on current progress\n    let estimatedCompletion: string | undefined;\n    if (current > 0 && percentage < 100) {\n      const remaining = target - current;\n      const rate = current / Math.max(playerStats?.total_games_played || 1, 1);\n      const estimatedGames = remaining / Math.max(rate, 0.1);\n      \n      if (estimatedGames <= 5) {\n        estimatedCompletion = 'Within 5 games';\n      } else if (estimatedGames <= 10) {\n        estimatedCompletion = 'Within 10 games';\n      } else {\n        estimatedCompletion = 'Long term goal';\n      }\n    }\n\n    return {\n      current,\n      target,\n      percentage,\n      estimatedCompletion,\n      nextMilestone: current > 0 ? Math.ceil(current * 1.2) : Math.ceil(target * 0.2)\n    };\n  }\n\n  private generateRecommendation(\n    progress: PlayerAchievementProgress,\n    playerStats: any\n  ): AchievementRecommendation {\n    let priority = 0;\n    let reasonCode: AchievementRecommendation['reasonCode'] = 'category_focus';\n    let reason = '';\n    let estimatedEffort: AchievementRecommendation['estimatedEffort'] = 'medium';\n    let estimatedTimeToComplete = 'Unknown';\n    const tips: string[] = [];\n\n    // Calculate priority based on progress percentage\n    if (progress.progressPercentage >= 80) {\n      priority = 90;\n      reasonCode = 'close_to_completion';\n      reason = 'You\\'re very close to earning this achievement!';\n      estimatedEffort = 'low';\n      estimatedTimeToComplete = 'Very soon';\n    } else if (progress.progressPercentage >= 50) {\n      priority = 70;\n      reasonCode = 'close_to_completion';\n      reason = 'You\\'re halfway there - keep it up!';\n      estimatedEffort = 'medium';\n      estimatedTimeToComplete = 'Medium term';\n    } else if (progress.progressPercentage >= 25) {\n      priority = 50;\n      reasonCode = 'category_focus';\n      reason = 'Good progress in this category';\n      estimatedEffort = 'medium';\n      estimatedTimeToComplete = 'Medium term';\n    } else {\n      priority = 30;\n      reasonCode = 'difficulty_progression';\n      reason = 'A good challenge to work towards';\n      estimatedEffort = 'high';\n      estimatedTimeToComplete = 'Long term';\n    }\n\n    // Add difficulty bonus\n    switch (progress.achievement.difficulty) {\n      case 'bronze':\n        priority += 10;\n        break;\n      case 'silver':\n        priority += 5;\n        break;\n      case 'gold':\n        priority -= 5;\n        break;\n      case 'platinum':\n        priority -= 10;\n        break;\n    }\n\n    // Generate tips based on achievement requirements\n    const requirements = progress.achievement.requirements as any;\n    if (requirements.goals) {\n      tips.push('Focus on creating scoring opportunities');\n      tips.push('Practice shooting accuracy in training');\n    } else if (requirements.assists) {\n      tips.push('Look for teammates in better positions');\n      tips.push('Improve your passing accuracy');\n    } else if (requirements.matches_played) {\n      tips.push('Stay active in your leagues');\n      tips.push('Consistency is key for this achievement');\n    }\n\n    return {\n      achievement: progress.achievement,\n      priority: Math.max(0, Math.min(100, priority)),\n      reasonCode,\n      reason,\n      estimatedEffort,\n      estimatedTimeToComplete,\n      tips\n    };\n  }\n\n  /**\n   * Subscribe to real-time achievement updates\n   */\n  subscribeToAchievementUpdates(\n    userId: string,\n    callback: (payload: any) => void,\n    options: RealtimeSubscriptionOptions = { table: 'user_achievements', event: '*' }\n  ) {\n    return this.supabase\n      .channel(`achievements-${userId}-updates`)\n      .on(\n        'postgres_changes',\n        {\n          event: options.event,\n          schema: options.schema || 'public',\n          table: options.table,\n          filter: options.filter || `user_id=eq.${userId}`\n        },\n        callback\n      )\n      .subscribe();\n  }\n\n  /**\n   * Clear cache\n   */\n  clearCache(pattern?: string): void {\n    if (!pattern) {\n      this.cache.clear();\n      return;\n    }\n\n    const keys = Array.from(this.cache.keys());\n    keys.forEach(key => {\n      if (key.includes(pattern)) {\n        this.cache.delete(key);\n      }\n    });\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 5339, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/edge-functions.service.ts"],"sourcesContent":["/**\n * Edge Functions Service for MatchDay\n * \n * Handles ALL server communication following the LEVER principle of server-side authority.\n * ALL business logic operations MUST go through Edge Functions to maintain data integrity,\n * security, and proper audit logging.\n * \n * @example\n * ```typescript\n * const result = await EdgeFunctionsService.getInstance().createLeague(leagueData);\n * const match = await EdgeFunctionsService.getInstance().recordMatchResult(matchData);\n * ```\n * \n * This service should be used for ALL write operations and complex business logic.\n */\n\nexport interface EdgeFunctionResponse<T = any> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  auditLogId?: string;\n}\n\nexport class EdgeFunctionsService {\n  private static instance: EdgeFunctionsService;\n  private supabase: any; // Will be injected\n  \n  private constructor() {}\n  \n  static getInstance(): EdgeFunctionsService {\n    if (!EdgeFunctionsService.instance) {\n      EdgeFunctionsService.instance = new EdgeFunctionsService();\n    }\n    return EdgeFunctionsService.instance;\n  }\n  \n  setSupabaseClient(client: any) {\n    this.supabase = client;\n  }\n  \n  private async invokeFunction<T>(\n    functionName: string, \n    payload: any\n  ): Promise<EdgeFunctionResponse<T>> {\n    try {\n      const { data, error } = await this.supabase.functions.invoke(functionName, {\n        body: payload\n      });\n      \n      if (error) {\n        throw error;\n      }\n      \n      return data;\n    } catch (error) {\n      console.error(`Edge function ${functionName} failed:`, error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred'\n      };\n    }\n  }\n  \n  // League Management\n  async createLeague(leagueData: {\n    name: string;\n    description?: string;\n    sport_type: string;\n    league_type: string;\n    location?: string;\n    season_start: string;\n    season_end: string;\n    max_teams: number;\n    entry_fee?: number;\n  }): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('create-league', leagueData);\n  }\n  \n  async updateLeague(leagueId: string, updates: any): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('update-league', { leagueId, updates });\n  }\n  \n  async deleteLeague(leagueId: string): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('delete-league', { leagueId });\n  }\n  \n  // Team Management\n  async createTeam(teamData: {\n    league_id: string;\n    name: string;\n    logo_url?: string;\n    team_color?: string;\n  }): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('create-team', teamData);\n  }\n  \n  async joinTeam(teamId: string, playerData: {\n    position?: string;\n    jersey_number?: number;\n  }): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('join-team', { teamId, ...playerData });\n  }\n  \n  async leaveTeam(teamId: string): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('leave-team', { teamId });\n  }\n  \n  async updateTeamMember(teamId: string, userId: string, updates: {\n    position?: string;\n    jersey_number?: number;\n    is_active?: boolean;\n  }): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('update-team-member', { teamId, userId, updates });\n  }\n  \n  // Match Management\n  async createMatch(matchData: {\n    league_id: string;\n    home_team_id: string;\n    away_team_id: string;\n    scheduled_date: string;\n    venue?: string;\n    match_day?: number;\n  }): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('create-match', matchData);\n  }\n  \n  async recordMatchResult(matchId: string, result: {\n    home_score: number;\n    away_score: number;\n    events?: Array<{\n      team_id: string;\n      player_id: string;\n      event_type: string;\n      event_time: number;\n      description?: string;\n    }>;\n  }): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('record-match-result', { matchId, ...result });\n  }\n  \n  async updateMatchStatus(matchId: string, status: string): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('update-match-status', { matchId, status });\n  }\n  \n  // Statistics & Achievements\n  async recalculatePlayerStats(playerId: string, leagueId?: string): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('recalculate-player-stats', { playerId, leagueId });\n  }\n  \n  async recalculateTeamStats(teamId: string): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('recalculate-team-stats', { teamId });\n  }\n  \n  async checkAchievements(userId: string, context?: any): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('check-achievements', { userId, context });\n  }\n  \n  // Schedule Generation\n  async generateLeagueSchedule(leagueId: string, options?: {\n    rounds?: number;\n    start_date?: string;\n    days_between_matches?: number;\n  }): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('generate-schedule', { leagueId, options });\n  }\n  \n  // Batch Operations\n  async importPlayers(teamId: string, players: Array<{\n    email: string;\n    display_name: string;\n    position?: string;\n    jersey_number?: number;\n  }>): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('import-players', { teamId, players });\n  }\n  \n  async bulkCreateMatches(matches: Array<{\n    league_id: string;\n    home_team_id: string;\n    away_team_id: string;\n    scheduled_date: string;\n    venue?: string;\n    match_day?: number;\n  }>): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('bulk-create-matches', { matches });\n  }\n  \n  // User Profile\n  async updateUserProfile(updates: {\n    display_name?: string;\n    avatar_url?: string;\n    preferred_position?: string;\n    bio?: string;\n    date_of_birth?: string;\n    location?: string;\n  }): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('update-user-profile', updates);\n  }\n  \n  // Cross-League Analytics\n  async getCrossLeagueStats(userId: string): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('get-cross-league-stats', { userId });\n  }\n  \n  async getGlobalLeaderboards(options?: {\n    stat_type?: string; // 'goals', 'assists', 'games_played'\n    sport_type?: string;\n    time_period?: string; // 'current_season', 'all_time'\n    limit?: number;\n  }): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('get-global-leaderboards', options || {});\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 5494, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/config.service.ts"],"sourcesContent":["/**\n * Configuration Service for MatchDay\n * \n * Manages all application configuration following the LEVER principle of\n * centralized configuration management. Provides hierarchical config loading:\n * 1. Memory cache\n * 2. Local storage\n * 3. Supabase database\n * 4. Default fallbacks\n * \n * @example\n * ```typescript\n * const config = await ConfigService.getInstance().getScoringRules();\n * const maxTeams = await ConfigService.getInstance().getLeagueSettings();\n * ```\n * \n * This service should be used for ALL configuration access.\n */\nexport class ConfigService {\n  private static instance: ConfigService;\n  private memoryCache = new Map();\n  private supabase: any; // Will be injected\n  \n  private constructor() {}\n  \n  static getInstance(): ConfigService {\n    if (!ConfigService.instance) {\n      ConfigService.instance = new ConfigService();\n    }\n    return ConfigService.instance;\n  }\n  \n  setSupabaseClient(client: any) {\n    this.supabase = client;\n  }\n  \n  async getConfig<T>(key: string): Promise<T> {\n    // 1. Check memory cache\n    if (this.memoryCache.has(key)) {\n      return this.memoryCache.get(key);\n    }\n    \n    // 2. Check local storage\n    if (typeof window !== 'undefined') {\n      const local = localStorage.getItem(`matchday_config_${key}`);\n      if (local) {\n        const parsed = JSON.parse(local);\n        this.memoryCache.set(key, parsed);\n        return parsed;\n      }\n    }\n    \n    // 3. Fetch from Supabase\n    if (this.supabase) {\n      try {\n        const { data } = await this.supabase\n          .from('app_configurations')\n          .select('value')\n          .eq('id', key)\n          .single();\n        \n        if (data) {\n          const value = data.value;\n          if (typeof window !== 'undefined') {\n            localStorage.setItem(`matchday_config_${key}`, JSON.stringify(value));\n          }\n          this.memoryCache.set(key, value);\n          return value;\n        }\n      } catch (error) {\n        console.warn(`Failed to fetch config for ${key}:`, error);\n      }\n    }\n    \n    // 4. Fall back to defaults\n    return this.getDefault(key);\n  }\n  \n  private getDefault<T>(key: string): T {\n    const defaults: Record<string, any> = {\n      scoring_rules: { win: 3, draw: 1, loss: 0 },\n      achievement_rules: {\n        first_goal: { points: 10 },\n        hat_trick: { points: 50 },\n        clean_sheet: { points: 25 },\n        mvp_game: { points: 30 },\n        perfect_attendance: { points: 100 }\n      },\n      league_settings: {\n        max_teams_per_league: 16,\n        matches_per_season: 30,\n        min_players_per_team: 11,\n        max_players_per_team: 25\n      },\n      notification_settings: {\n        match_reminders: true,\n        score_updates: true,\n        achievement_notifications: true\n      }\n    };\n    \n    return defaults[key] || null;\n  }\n  \n  // Specific getters for commonly used configs\n  async getScoringRules(): Promise<{ win: number; draw: number; loss: number }> {\n    return this.getConfig('scoring_rules');\n  }\n  \n  async getAchievementRules(): Promise<Record<string, { points: number }>> {\n    return this.getConfig('achievement_rules');\n  }\n  \n  async getLeagueSettings(): Promise<{\n    max_teams_per_league: number;\n    matches_per_season: number;\n    min_players_per_team: number;\n    max_players_per_team: number;\n  }> {\n    return this.getConfig('league_settings');\n  }\n  \n  // Clear cache when config is updated\n  invalidateConfig(key?: string) {\n    if (key) {\n      this.memoryCache.delete(key);\n      if (typeof window !== 'undefined') {\n        localStorage.removeItem(`matchday_config_${key}`);\n      }\n    } else {\n      this.memoryCache.clear();\n      if (typeof window !== 'undefined') {\n        Object.keys(localStorage)\n          .filter(k => k.startsWith('matchday_config_'))\n          .forEach(k => localStorage.removeItem(k));\n      }\n    }\n  }\n}\n\n// Export singleton instance\nexport const configService = ConfigService.getInstance();"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;CAiBC;;;;AACM,MAAM;IACX,OAAe,SAAwB;IAC/B,cAAc,IAAI,MAAM;IACxB,SAAc;IAEtB,aAAsB,CAAC;IAEvB,OAAO,cAA6B;QAClC,IAAI,CAAC,cAAc,QAAQ,EAAE;YAC3B,cAAc,QAAQ,GAAG,IAAI;QAC/B;QACA,OAAO,cAAc,QAAQ;IAC/B;IAEA,kBAAkB,MAAW,EAAE;QAC7B,IAAI,CAAC,QAAQ,GAAG;IAClB;IAEA,MAAM,UAAa,GAAW,EAAc;QAC1C,wBAAwB;QACxB,IAAI,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,MAAM;YAC7B,OAAO,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC;QAC9B;QAEA,yBAAyB;QACzB;;QASA,yBAAyB;QACzB,IAAI,IAAI,CAAC,QAAQ,EAAE;YACjB,IAAI;gBACF,MAAM,EAAE,IAAI,EAAE,GAAG,MAAM,IAAI,CAAC,QAAQ,CACjC,IAAI,CAAC,sBACL,MAAM,CAAC,SACP,EAAE,CAAC,MAAM,KACT,MAAM;gBAET,IAAI,MAAM;oBACR,MAAM,QAAQ,KAAK,KAAK;oBACxB;;oBAGA,IAAI,CAAC,WAAW,CAAC,GAAG,CAAC,KAAK;oBAC1B,OAAO;gBACT;YACF,EAAE,OAAO,OAAO;gBACd,QAAQ,IAAI,CAAC,CAAC,2BAA2B,EAAE,IAAI,CAAC,CAAC,EAAE;YACrD;QACF;QAEA,2BAA2B;QAC3B,OAAO,IAAI,CAAC,UAAU,CAAC;IACzB;IAEQ,WAAc,GAAW,EAAK;QACpC,MAAM,WAAgC;YACpC,eAAe;gBAAE,KAAK;gBAAG,MAAM;gBAAG,MAAM;YAAE;YAC1C,mBAAmB;gBACjB,YAAY;oBAAE,QAAQ;gBAAG;gBACzB,WAAW;oBAAE,QAAQ;gBAAG;gBACxB,aAAa;oBAAE,QAAQ;gBAAG;gBAC1B,UAAU;oBAAE,QAAQ;gBAAG;gBACvB,oBAAoB;oBAAE,QAAQ;gBAAI;YACpC;YACA,iBAAiB;gBACf,sBAAsB;gBACtB,oBAAoB;gBACpB,sBAAsB;gBACtB,sBAAsB;YACxB;YACA,uBAAuB;gBACrB,iBAAiB;gBACjB,eAAe;gBACf,2BAA2B;YAC7B;QACF;QAEA,OAAO,QAAQ,CAAC,IAAI,IAAI;IAC1B;IAEA,6CAA6C;IAC7C,MAAM,kBAAwE;QAC5E,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB;IAEA,MAAM,sBAAmE;QACvE,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB;IAEA,MAAM,oBAKH;QACD,OAAO,IAAI,CAAC,SAAS,CAAC;IACxB;IAEA,qCAAqC;IACrC,iBAAiB,GAAY,EAAE;QAC7B,IAAI,KAAK;YACP,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC;YACxB;;QAGF,OAAO;YACL,IAAI,CAAC,WAAW,CAAC,KAAK;YACtB;;QAKF;IACF;AACF;AAGO,MAAM,gBAAgB,cAAc,WAAW","debugId":null}},
    {"offset": {"line": 5621, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/index.ts"],"sourcesContent":["/**\n * @matchday/services\n *\n * Shared service layer for MatchDay monorepo\n */\n\nexport * from './league.service';\nexport * from './team.service';\nexport * from './match.service';\nexport * from './season.service';\nexport * from './player.service';\nexport * from './user.service';\nexport * from './stats.service';\nexport * from './analytics.service';\nexport * from './achievement.service';\nexport * from './edge-functions.service';\nexport * from './config.service';\n"],"names":[],"mappings":"AAAA;;;;CAIC;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","debugId":null}}]
}