{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/shared/src/utils.ts"],"sourcesContent":["import { type ClassValue, clsx } from \"clsx\"\nimport { twMerge } from \"tailwind-merge\"\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs))\n}"],"names":[],"mappings":";;;AAAA;AACA;;;AAEO,SAAS;IAAG,IAAA,IAAA,OAAA,UAAA,QAAA,AAAG,SAAH,UAAA,OAAA,OAAA,GAAA,OAAA,MAAA;QAAG,OAAH,QAAA,SAAA,CAAA,KAAuB;;IACxC,OAAO,CAAA,GAAA,4NAAA,CAAA,UAAO,AAAD,EAAE,CAAA,GAAA,yLAAA,CAAA,OAAI,AAAD,EAAE;AACtB","debugId":null}},
    {"offset": {"line": 29, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/shared/src/environment/validation.ts"],"sourcesContent":["/**\n * Environment Validation Utility for MatchDay\n * \n * Prevents database confusion by validating and clearly indicating\n * which environment (local/production) is currently active.\n */\n\nexport type Environment = 'development' | 'production' | 'test'\n\nexport interface EnvironmentConfig {\n  env: Environment\n  supabaseUrl: string\n  supabaseAnonKey: string\n  siteUrl: string\n  isDevelopment: boolean\n  isProduction: boolean\n  isLocal: boolean\n  isRemote: boolean\n  databaseType: 'local' | 'production'\n  adminAppUrl?: string\n}\n\nexport interface ValidationResult {\n  isValid: boolean\n  errors: string[]\n  warnings: string[]\n  config: EnvironmentConfig | null\n}\n\n/**\n * Validates environment configuration and returns detailed analysis\n */\nexport function validateEnvironment(): ValidationResult {\n  const errors: string[] = []\n  const warnings: string[] = []\n  \n  // Get environment variables\n  const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL\n  const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY\n  const siteUrl = process.env.NEXT_PUBLIC_SITE_URL\n  const adminAppUrl = process.env.NEXT_PUBLIC_ADMIN_APP_URL\n  const nodeEnv = process.env.NODE_ENV as Environment || 'development'\n  \n  // Validate required variables\n  if (!supabaseUrl) {\n    errors.push('Missing NEXT_PUBLIC_SUPABASE_URL environment variable')\n  }\n  \n  if (!supabaseAnonKey) {\n    errors.push('Missing NEXT_PUBLIC_SUPABASE_ANON_KEY environment variable')\n  }\n  \n  if (!siteUrl) {\n    errors.push('Missing NEXT_PUBLIC_SITE_URL environment variable')\n  }\n  \n  // Early return if critical variables missing\n  if (errors.length > 0) {\n    return {\n      isValid: false,\n      errors,\n      warnings,\n      config: null\n    }\n  }\n  \n  // Determine database type and environment characteristics\n  const isLocal = supabaseUrl?.includes('localhost') || supabaseUrl?.includes('127.0.0.1') || false\n  const isRemote = !isLocal\n  const isDevelopment = nodeEnv === 'development'\n  const isProduction = nodeEnv === 'production'\n  const databaseType: 'local' | 'production' = isLocal ? 'local' : 'production'\n  \n  // Validate URL format\n  try {\n    new URL(supabaseUrl!)\n  } catch {\n    errors.push(`Invalid NEXT_PUBLIC_SUPABASE_URL format: ${supabaseUrl}`)\n  }\n  \n  try {\n    new URL(siteUrl!)\n  } catch {\n    errors.push(`Invalid NEXT_PUBLIC_SITE_URL format: ${siteUrl}`)\n  }\n  \n  // Environment consistency checks\n  if (isDevelopment && isRemote) {\n    warnings.push('‚ö†Ô∏è  DEVELOPMENT mode is using PRODUCTION database - this may be intentional but verify!')\n  }\n  \n  if (isProduction && isLocal) {\n    errors.push('‚ùå PRODUCTION mode cannot use LOCAL database')\n  }\n  \n  // Database URL validation\n  if (isLocal) {\n    if (!supabaseUrl?.match(/localhost:5432\\d/)) {\n      warnings.push(`Local database URL doesn't match expected pattern (localhost:5432x): ${supabaseUrl}`)\n    }\n  } else {\n    if (!supabaseUrl?.includes('.supabase.co')) {\n      warnings.push(`Production database URL doesn't match expected Supabase pattern: ${supabaseUrl}`)\n    }\n  }\n  \n  // Create config object\n  const config: EnvironmentConfig = {\n    env: nodeEnv,\n    supabaseUrl: supabaseUrl!,\n    supabaseAnonKey: supabaseAnonKey!,\n    siteUrl: siteUrl!,\n    isDevelopment,\n    isProduction,\n    isLocal,\n    isRemote,\n    databaseType,\n    adminAppUrl\n  }\n  \n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings,\n    config\n  }\n}\n\n/**\n * Get current environment configuration (throws if invalid)\n */\nexport function getEnvironmentConfig(): EnvironmentConfig {\n  const result = validateEnvironment()\n  \n  if (!result.isValid || !result.config) {\n    throw new Error(`Invalid environment configuration:\\n${result.errors.join('\\n')}`)\n  }\n  \n  return result.config\n}\n\n/**\n * Check if current environment is safe for destructive operations\n */\nexport function isSafeForDestructiveOperations(): boolean {\n  try {\n    const config = getEnvironmentConfig()\n    return config.isDevelopment || config.isLocal\n  } catch {\n    return false\n  }\n}\n\n/**\n * Get environment display name with visual indicators\n */\nexport function getEnvironmentDisplayName(): string {\n  try {\n    const config = getEnvironmentConfig()\n    \n    if (config.isLocal) {\n      return `üü¢ LOCAL (${config.env})`\n    } else {\n      return `üî¥ PRODUCTION (${config.env})`\n    }\n  } catch {\n    return '‚ùì UNKNOWN'\n  }\n}\n\n/**\n * Get database display name with clear indicators\n */\nexport function getDatabaseDisplayName(): string {\n  try {\n    const config = getEnvironmentConfig()\n    const url = new URL(config.supabaseUrl)\n    \n    if (config.isLocal) {\n      return `üè† Local Database (${url.host})`\n    } else {\n      return `‚òÅÔ∏è  Production Database (${url.hostname})`\n    }\n  } catch {\n    return '‚ùì Unknown Database'\n  }\n}\n\n/**\n * Log environment status to console with visual formatting\n */\nexport function logEnvironmentStatus(): void {\n  const result = validateEnvironment()\n  \n  console.group('üîß Environment Configuration')\n  \n  if (result.config) {\n    const config = result.config\n    \n    console.log(`Environment: ${getEnvironmentDisplayName()}`)\n    console.log(`Database: ${getDatabaseDisplayName()}`)\n    console.log(`Site URL: ${config.siteUrl}`)\n    \n    if (config.adminAppUrl) {\n      console.log(`Admin URL: ${config.adminAppUrl}`)\n    }\n    \n    if (result.warnings.length > 0) {\n      console.group('‚ö†Ô∏è  Warnings')\n      result.warnings.forEach(warning => console.warn(warning))\n      console.groupEnd()\n    }\n  }\n  \n  if (result.errors.length > 0) {\n    console.group('‚ùå Errors')\n    result.errors.forEach(error => console.error(error))\n    console.groupEnd()\n  }\n  \n  console.groupEnd()\n}\n\n/**\n * Create environment validation middleware for Next.js\n */\nexport function createEnvironmentMiddleware() {\n  return () => {\n    const result = validateEnvironment()\n    \n    if (!result.isValid) {\n      throw new Error(`Environment validation failed:\\n${result.errors.join('\\n')}`)\n    }\n    \n    // Log environment status in development\n    if (result.config?.isDevelopment) {\n      logEnvironmentStatus()\n    }\n  }\n}\n\n/**\n * Runtime environment validation (call this at app startup)\n */\nexport function validateEnvironmentAtStartup(): void {\n  try {\n    const middleware = createEnvironmentMiddleware()\n    middleware()\n    \n    const config = getEnvironmentConfig()\n    \n    // Show prominent warning for production database usage\n    if (config.isRemote && config.isDevelopment) {\n      console.warn('\\n' + '='.repeat(60))\n      console.warn('‚ö†Ô∏è  WARNING: USING PRODUCTION DATABASE IN DEVELOPMENT!')\n      console.warn(`Database: ${getDatabaseDisplayName()}`)\n      console.warn('Make sure this is intentional!')\n      console.warn('='.repeat(60) + '\\n')\n    }\n    \n  } catch (error) {\n    console.error('\\n' + '='.repeat(60))\n    console.error('‚ùå ENVIRONMENT VALIDATION FAILED!')\n    console.error(error instanceof Error ? error.message : String(error))\n    console.error('='.repeat(60) + '\\n')\n    throw error\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 230, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/shared/src/index.ts"],"sourcesContent":["/**\n * @matchday/shared\n *\n * Shared utilities and helpers for MatchDay monorepo\n */\n\nexport * from './utils';\nexport * from './environment/validation';\n"],"names":[],"mappings":"AAAA;;;;CAIC;AAED;AACA","debugId":null}},
    {"offset": {"line": 256, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/apps/player/src/lib/supabase/client.ts"],"sourcesContent":["/**\n * Supabase Client Configuration for MatchDay\n * \n * Proper Next.js 15 App Router + Supabase Cloud integration using @supabase/ssr\n * Handles client-side, server-side, and SSR authentication consistently\n * \n * Includes environment validation to prevent database confusion\n */\n\nimport { createBrowserClient } from '@supabase/ssr'\nimport { Database } from '@matchday/database'\nimport { validateEnvironmentAtStartup, getEnvironmentConfig } from '@matchday/shared'\n\n// Validate environment at startup to prevent database confusion\nvalidateEnvironmentAtStartup()\n\n// Get validated environment configuration\nconst envConfig = getEnvironmentConfig()\nconst { supabaseUrl, supabaseAnonKey } = envConfig\n\n/**\n * Supabase client for Client Components\n * \n * Uses @supabase/ssr for proper SSR support and Supabase Cloud compatibility.\n * Automatically handles authentication state with cookies for SSR consistency.\n */\nexport const supabase = createBrowserClient<Database>(\n  supabaseUrl,\n  supabaseAnonKey,\n  {\n    cookieOptions: {\n      name: 'matchday-auth',\n      lifetime: 60 * 60 * 24 * 7, // 7 days\n      domain: undefined,\n      path: '/',\n      sameSite: 'lax',\n    },\n  }\n)\n\n/**\n * Type-safe helper for getting the current user\n */\nexport async function getCurrentUser() {\n  try {\n    const { data: { user }, error } = await supabase.auth.getUser()\n    \n    if (error) {\n      console.error('Error getting current user:', error)\n      return null\n    }\n    \n    return user\n  } catch (error) {\n    console.error('Unexpected error getting current user:', error)\n    return null\n  }\n}\n\n/**\n * Type-safe helper for getting the current session\n */\nexport async function getCurrentSession() {\n  try {\n    const { data: { session }, error } = await supabase.auth.getSession()\n    \n    if (error) {\n      console.error('Error getting current session:', error)\n      return null\n    }\n    \n    return session\n  } catch (error) {\n    console.error('Unexpected error getting current session:', error)\n    return null\n  }\n}\n\n/**\n * Utility function to handle Supabase auth redirects\n */\nexport function getAuthRedirectUrl(path: string = '/dashboard') {\n  const baseUrl = process.env.NEXT_PUBLIC_SITE_URL || 'http://localhost:3000'\n  return `${baseUrl}${path}`\n}\n\n/**\n * Cookie management utilities for authentication recovery\n */\nexport function clearAuthCookies() {\n  if (typeof document === 'undefined') return\n\n  // Clear all Supabase auth cookies\n  const cookieNames = [\n    'matchday-auth',\n    'sb-access-token',\n    'sb-refresh-token',\n    'supabase-auth-token',\n    'supabase.auth.token'\n  ]\n\n  cookieNames.forEach(cookieName => {\n    // Clear cookie with various path and domain combinations\n    const clearCookie = (domain?: string, path: string = '/') => {\n      let cookieString = `${cookieName}=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=${path};`\n      if (domain) cookieString += ` domain=${domain};`\n      document.cookie = cookieString\n    }\n\n    // Clear with different path/domain combinations\n    clearCookie()\n    clearCookie(undefined, '/')\n    clearCookie(window.location.hostname)\n    clearCookie(`.${window.location.hostname}`)\n  })\n\n  // Also clear localStorage auth items\n  if (typeof localStorage !== 'undefined') {\n    const keys = Object.keys(localStorage)\n    keys.forEach(key => {\n      if (key.includes('supabase') || key.includes('auth')) {\n        localStorage.removeItem(key)\n      }\n    })\n  }\n\n  console.log('üßπ Cleared all authentication cookies and localStorage')\n}\n\n/**\n * Detect if a session has an invalid JWT token\n */\nexport function isInvalidJWTError(error: any): boolean {\n  if (!error) return false\n  \n  const message = error.message || error.toString()\n  return message.includes('invalid JWT') || \n         message.includes('signature is invalid') ||\n         message.includes('unable to parse or verify signature')\n}\n\n/**\n * Validate session health - checks if the session is usable\n */\nexport async function validateSessionHealth(session: any): Promise<boolean> {\n  if (!session?.access_token) return false\n  \n  try {\n    // Try a simple authenticated request to validate the token\n    const { data, error } = await supabase.auth.getUser()\n    \n    if (error && isInvalidJWTError(error)) {\n      console.log('üö® Session health check failed: Invalid JWT detected')\n      return false\n    }\n    \n    return !error && !!data.user\n  } catch (error) {\n    if (isInvalidJWTError(error)) {\n      console.log('üö® Session health check failed: Invalid JWT detected')\n      return false\n    }\n    return false\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 391, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/league.service.ts"],"sourcesContent":["/**\n * League Service for MatchDay\n * \n * Handles league discovery and joining operations with focus on:\n * - League discovery and filtering (read-only, no league creation)\n * - Advanced search and compatibility matching\n * - Join request management for teams within leagues\n * - Player's league membership tracking\n * \n * Optimized for player-centric amateur sports league experience\n */\n\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport {\n  Database,\n  League,\n  Team,\n  LeagueDiscovery,\n  LeagueFilters,\n  ServiceResponse,\n  ServiceError,\n  PaginatedServiceResponse,\n  TeamJoinRequest,\n  JoinRequestStatus,\n  SportType,\n  LeagueType,\n  CacheOptions,\n  RealtimeSubscriptionOptions\n} from '@/lib/types/database.types';\n\nexport interface LeagueCompatibilityScore {\n  leagueId: string;\n  score: number;\n  factors: {\n    skillMatch: number;\n    locationProximity: number;\n    scheduleCompatibility: number;\n    teamAvailability: number;\n    entryAffordability: number;\n  };\n  recommendations: string[];\n}\n\nexport interface TeamAvailability {\n  teamId: string;\n  teamName: string;\n  currentPlayers: number;\n  maxPlayers: number;\n  availableSpots: number;\n  isRecruiting: boolean;\n  requiredPositions: string[];\n  captainContact?: {\n    name: string;\n    id: string;\n  };\n}\n\nexport class LeagueService {\n  private static instance: LeagueService;\n  private supabase: SupabaseClient<Database>;\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n\n  private constructor(supabaseClient: SupabaseClient<Database>) {\n    this.supabase = supabaseClient;\n  }\n\n  static getInstance(supabaseClient?: SupabaseClient<Database>): LeagueService {\n    if (!LeagueService.instance) {\n      if (!supabaseClient) {\n        throw new Error('SupabaseClient required for first initialization');\n      }\n      LeagueService.instance = new LeagueService(supabaseClient);\n    }\n    return LeagueService.instance;\n  }\n\n  /**\n   * Handle service errors consistently\n   */\n  private handleError(error: any, operation: string): ServiceError {\n    console.error(`LeagueService.${operation}:`, {\n      error,\n      code: error?.code,\n      message: error?.message,\n      stack: error?.stack,\n      type: typeof error,\n      keys: Object.keys(error || {})\n    });\n    return {\n      code: error?.code || 'UNKNOWN_ERROR',\n      message: error?.message || 'An unexpected error occurred',\n      details: error.details || error,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Cache management utilities\n   */\n  private getCacheKey(operation: string, params: any): string {\n    return `league_service:${operation}:${JSON.stringify(params)}`;\n  }\n\n  private getFromCache<T>(key: string): T | null {\n    const cached = this.cache.get(key);\n    if (!cached) return null;\n    \n    if (Date.now() - cached.timestamp > cached.ttl * 1000) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return cached.data as T;\n  }\n\n  private setCache<T>(key: string, data: T, ttl = 600): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl\n    });\n  }\n\n  /**\n   * Discover available leagues with advanced filtering\n   */\n  async discoverLeagues(\n    filters: LeagueFilters = {},\n    options: {\n      userId?: string;\n      includeCompatibilityScore?: boolean;\n      limit?: number;\n      offset?: number;\n    } = {}\n  ): Promise<PaginatedServiceResponse<LeagueDiscovery>> {\n    try {\n      const cacheKey = this.getCacheKey('discoverLeagues', { filters, options: { ...options, userId: undefined } });\n      const cached = this.getFromCache<LeagueDiscovery[]>(cacheKey);\n      \n      if (cached && !options.userId) {\n        return { \n          data: cached, \n          error: null, \n          success: true,\n          pagination: {\n            page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n            limit: options.limit || 20,\n            total: cached.length,\n            totalPages: Math.ceil(cached.length / (options.limit || 20)),\n            hasNext: false,\n            hasPrevious: false\n          }\n        };\n      }\n\n      // Build query with filters\n      let query = this.supabase\n        .from('leagues')\n        .select(`\n          *,\n          teams (\n            id,\n            name,\n            team_color,\n            captain_id,\n            max_players,\n            min_players,\n            is_recruiting\n          )\n        `, { count: 'exact' })\n        .eq('is_active', true)\n        .eq('is_public', true);\n\n      if (filters.sportType) {\n        query = query.eq('sport_type', filters.sportType);\n      }\n\n      if (filters.leagueType) {\n        query = query.eq('league_type', filters.leagueType);\n      }\n\n      if (filters.location) {\n        query = query.ilike('location', `%${filters.location}%`);\n      }\n\n      if (filters.entryFeeMax !== undefined) {\n        query = query.lte('entry_fee', filters.entryFeeMax);\n      }\n\n      if (filters.seasonActive) {\n        const now = new Date().toISOString();\n        // Include leagues where season_end is null (ongoing/no end date) OR season_end is in the future\n        query = query.or(`season_end.gte.${now},season_end.is.null`);\n      }\n\n      if (filters.search) {\n        query = query.or(`name.ilike.%${filters.search}%,description.ilike.%${filters.search}%`);\n      }\n\n      const { data: leagues, error, count } = await query\n        .order('created_at', { ascending: false })\n        .range(options.offset || 0, (options.offset || 0) + (options.limit || 20) - 1);\n\n      if (error) throw error;\n\n      // Get user's current memberships if userId provided\n      let userMemberships: string[] = [];\n      if (options.userId) {\n        const { data: memberships } = await this.supabase\n          .from('team_members')\n          .select(`\n            team:teams!inner(league_id)\n          `)\n          .eq('user_id', options.userId)\n          .eq('is_active', true);\n\n        userMemberships = memberships?.map(m => m.team.league_id) || [];\n      }\n\n      // Process leagues into discovery format\n      const discoveryLeagues: LeagueDiscovery[] = await Promise.all(\n        (leagues || []).map(async (league) => {\n          const teams = league.teams || [];\n          const playerCount = await this.getLeaguePlayerCount(league.id);\n          const availableSpots = await this.getLeagueAvailableSpots(league.id);\n          \n          let compatibilityScore;\n          if (options.includeCompatibilityScore && options.userId) {\n            const compatibility = await this.calculateCompatibilityScore(league.id, options.userId);\n            compatibilityScore = compatibility.data?.score;\n          }\n\n          return {\n            ...league,\n            teams,\n            teamCount: teams.length,\n            playerCount: playerCount.data || 0,\n            availableSpots: availableSpots.data || 0,\n            isUserMember: userMemberships.includes(league.id),\n            compatibilityScore\n          };\n        })\n      );\n\n      // Sort by compatibility score if available\n      if (options.includeCompatibilityScore) {\n        discoveryLeagues.sort((a, b) => (b.compatibilityScore || 0) - (a.compatibilityScore || 0));\n      }\n\n      // Cache results (without user-specific data)\n      if (!options.userId) {\n        this.setCache(cacheKey, discoveryLeagues, 600);\n      }\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n        limit: options.limit || 20,\n        total: count || 0,\n        totalPages: Math.ceil((count || 0) / (options.limit || 20)),\n        hasNext: ((options.offset || 0) + (options.limit || 20)) < (count || 0),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: discoveryLeagues,\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'discoverLeagues'),\n        success: false,\n        pagination: {\n          page: 1,\n          limit: options.limit || 20,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrevious: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Get detailed league information\n   */\n  async getLeagueDetails(\n    leagueId: string,\n    options: { userId?: string } = {}\n  ): Promise<ServiceResponse<LeagueDiscovery>> {\n    try {\n      console.log('LeagueService.getLeagueDetails - Starting:', { leagueId, options });\n      const cacheKey = this.getCacheKey('getLeagueDetails', { leagueId });\n      const cached = this.getFromCache<LeagueDiscovery>(cacheKey);\n      \n      if (cached && !options.userId) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Use API endpoint instead of direct Supabase query to avoid RLS issues\n      let league;\n      try {\n        const response = await fetch(`/api/leagues/${leagueId}`);\n        const result = await response.json();\n        \n        if (!response.ok || !result.success) {\n          if (response.status === 404) {\n            return {\n              data: null,\n              error: { code: 'LEAGUE_NOT_FOUND', message: 'League not found', timestamp: new Date().toISOString() },\n              success: false\n            };\n          }\n          throw new Error(result.error || `HTTP ${response.status}: ${response.statusText}`);\n        }\n        \n        league = result.data;\n      } catch (error) {\n        console.error('LeagueService.getLeagueDetails - API request error:', error);\n        return {\n          data: null,\n          error: { \n            code: 'API_ERROR', \n            message: error instanceof Error ? error.message : 'Failed to fetch league details via API', \n            timestamp: new Date().toISOString() \n          },\n          success: false\n        };\n      }\n\n      // Process the league data to include statistics\n      console.log('LeagueService.getLeagueDetails - Processing league:', { leagueId, hasTeams: !!league.teams, teamsCount: league.teams?.length });\n      const teams = league.teams || [];\n      const teamCount = teams.length;\n      \n      // Calculate total active players across all teams\n      const playerCount = teams.reduce((total, team) => {\n        const activeMembers = team.team_members?.filter(member => member.is_active) || [];\n        return total + activeMembers.length;\n      }, 0);\n\n      // Calculate available spots across all teams\n      const availableSpots = teams.reduce((total, team) => {\n        const activeMembers = team.team_members?.filter(member => member.is_active) || [];\n        const maxPlayers = team.max_players || 22;\n        return total + Math.max(0, maxPlayers - activeMembers.length);\n      }, 0);\n\n      // Clean up team member data for response\n      const processedTeams = teams.map(team => ({\n        ...team,\n        currentPlayers: team.team_members?.filter(member => member.is_active).length || 0,\n        members: team.team_members?.filter(member => member.is_active).map(member => ({\n          id: member.id,\n          user_id: member.user_id,\n          position: member.position,\n          jersey_number: member.jersey_number,\n          joined_at: member.joined_at,\n          user_name: null, // User details not available in this query\n          user_email: null // User details not available in this query\n        })) || []\n      }));\n\n      // Remove the raw team_members data\n      processedTeams.forEach(team => delete team.team_members);\n      \n      // Check if user is member (if userId provided)\n      let isUserMember = false;\n      let joinRequests: TeamJoinRequest[] = [];\n      \n      if (options.userId && teams.length > 0) {\n        // Check if user is a member of any team in this league\n        const userTeams = teams.filter(team => \n          team.team_members?.some(member => \n            member.user_id === options.userId && member.is_active\n          )\n        );\n        isUserMember = userTeams.length > 0;\n      }\n\n      const leagueDiscovery: LeagueDiscovery = {\n        ...league,\n        teams: processedTeams,\n        teamCount,\n        playerCount,\n        availableSpots,\n        isUserMember,\n        joinRequests: options.userId ? joinRequests : undefined,\n        // Add derived stats\n        isOpenForTeams: teamCount < (league.max_teams || 16),\n        hasActiveTeams: teamCount > 0,\n        averagePlayersPerTeam: teamCount > 0 ? Math.round(playerCount / teamCount * 10) / 10 : 0\n      };\n\n      // Cache if not user-specific\n      if (!options.userId) {\n        this.setCache(cacheKey, leagueDiscovery, 300);\n      }\n\n      return { data: leagueDiscovery, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getLeagueDetails'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Calculate compatibility score between user and league\n   */\n  async calculateCompatibilityScore(\n    leagueId: string,\n    userId: string\n  ): Promise<ServiceResponse<LeagueCompatibilityScore>> {\n    try {\n      const cacheKey = this.getCacheKey('calculateCompatibilityScore', { leagueId, userId });\n      const cached = this.getFromCache<LeagueCompatibilityScore>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Get league details\n      const leagueResponse = await this.getLeagueDetails(leagueId);\n      if (!leagueResponse.success || !leagueResponse.data) {\n        throw new Error('League not found');\n      }\n\n      const league = leagueResponse.data;\n\n      // Get user profile and stats\n      const { data: userProfile, error: profileError } = await this.supabase\n        .from('users')\n        .select('*')\n        .eq('id', userId)\n        .single();\n\n      if (profileError) throw profileError;\n\n      // Get user's cross-league stats\n      const { data: userStats } = await this.supabase\n        .from('player_cross_league_stats')\n        .select('*')\n        .eq('player_id', userId)\n        .eq('season_year', new Date().getFullYear())\n        .single();\n\n      // Calculate compatibility factors\n      const factors = {\n        skillMatch: this.calculateSkillMatch(league, userStats),\n        locationProximity: this.calculateLocationProximity(league, userProfile),\n        scheduleCompatibility: this.calculateScheduleCompatibility(league),\n        teamAvailability: this.calculateTeamAvailability(league),\n        entryAffordability: this.calculateEntryAffordability(league, userProfile)\n      };\n\n      // Calculate overall score (weighted average)\n      const weights = {\n        skillMatch: 0.3,\n        locationProximity: 0.2,\n        scheduleCompatibility: 0.2,\n        teamAvailability: 0.2,\n        entryAffordability: 0.1\n      };\n\n      const score = Math.round(\n        factors.skillMatch * weights.skillMatch +\n        factors.locationProximity * weights.locationProximity +\n        factors.scheduleCompatibility * weights.scheduleCompatibility +\n        factors.teamAvailability * weights.teamAvailability +\n        factors.entryAffordability * weights.entryAffordability\n      );\n\n      // Generate recommendations\n      const recommendations = this.generateRecommendations(factors, league);\n\n      const compatibility: LeagueCompatibilityScore = {\n        leagueId,\n        score,\n        factors,\n        recommendations\n      };\n\n      // Cache for 30 minutes\n      this.setCache(cacheKey, compatibility, 1800);\n\n      return { data: compatibility, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'calculateCompatibilityScore'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get available teams in a league for joining\n   */\n  async getAvailableTeams(\n    leagueId: string,\n    options: { userId?: string } = {}\n  ): Promise<ServiceResponse<TeamAvailability[]>> {\n    try {\n      const { data: teams, error } = await this.supabase\n        .from('teams')\n        .select(`\n          *,\n          team_members!inner (\n            id,\n            user_id,\n            position,\n            is_active\n          )\n        `)\n        .eq('league_id', leagueId)\n        .eq('is_recruiting', true);\n\n      if (error) throw error;\n\n      // Get captain details\n      const captainIds = teams?.map(t => t.captain_id).filter(Boolean) || [];\n      const { data: captains } = captainIds.length > 0 ? await this.supabase\n        .from('users')\n        .select('id, display_name')\n        .in('id', captainIds) : { data: [] };\n\n      const teamAvailabilities: TeamAvailability[] = (teams || []).map(team => {\n        const activeMembers = team.team_members?.filter(m => m.is_active) || [];\n        const captain = captains?.find(c => c.id === team.captain_id);\n        \n        // Calculate required positions (simplified - would need more complex logic)\n        const requiredPositions = this.getRequiredPositions(team, activeMembers);\n\n        return {\n          teamId: team.id,\n          teamName: team.name,\n          currentPlayers: activeMembers.length,\n          maxPlayers: team.max_players || 11,\n          availableSpots: Math.max(0, (team.max_players || 11) - activeMembers.length),\n          isRecruiting: team.is_recruiting,\n          requiredPositions,\n          captainContact: captain ? {\n            name: captain.display_name,\n            id: captain.id\n          } : undefined\n        };\n      });\n\n      // Filter out full teams\n      const availableTeams = teamAvailabilities.filter(team => team.availableSpots > 0);\n\n      return { data: availableTeams, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getAvailableTeams'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get player's league memberships\n   */\n  async getPlayerLeagueMemberships(\n    userId: string\n  ): Promise<ServiceResponse<Array<LeagueDiscovery & {\n    teamMembership: {\n      teamId: string;\n      teamName: string;\n      position?: string;\n      jerseyNumber?: number;\n      joinedAt: string;\n    };\n  }>>> {\n    try {\n      const cacheKey = this.getCacheKey('getPlayerLeagueMemberships', { userId });\n      const cached = this.getFromCache<any>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      const { data: memberships, error } = await this.supabase\n        .from('team_members')\n        .select(`\n          *,\n          team:teams!inner (\n            *,\n            league:leagues!inner (*)\n          )\n        `)\n        .eq('user_id', userId)\n        .eq('is_active', true);\n\n      if (error) throw error;\n\n      // Process into league discovery format with membership details\n      const leagueMemberships = await Promise.all(\n        (memberships || []).map(async (membership) => {\n          const league = membership.team.league;\n          const playerCount = await this.getLeaguePlayerCount(league.id);\n          const availableSpots = await this.getLeagueAvailableSpots(league.id);\n\n          // Get all teams in the league\n          const { data: allTeams } = await this.supabase\n            .from('teams')\n            .select('*')\n            .eq('league_id', league.id);\n\n          return {\n            ...league,\n            teams: allTeams || [],\n            teamCount: allTeams?.length || 0,\n            playerCount: playerCount.data || 0,\n            availableSpots: availableSpots.data || 0,\n            isUserMember: true,\n            teamMembership: {\n              teamId: membership.team_id,\n              teamName: membership.team.name,\n              position: membership.position,\n              jerseyNumber: membership.jersey_number,\n              joinedAt: membership.joined_at\n            }\n          };\n        })\n      );\n\n      // Cache for 5 minutes\n      this.setCache(cacheKey, leagueMemberships, 300);\n\n      return { data: leagueMemberships, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerLeagueMemberships'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n  private async getLeaguePlayerCount(leagueId: string): Promise<ServiceResponse<number>> {\n    try {\n      // Get all teams in the league first\n      const { data: teams, error: teamsError } = await this.supabase\n        .from('teams')\n        .select('id')\n        .eq('league_id', leagueId);\n\n      if (teamsError) throw teamsError;\n      \n      if (!teams || teams.length === 0) {\n        return { data: 0, error: null, success: true };\n      }\n\n      // Get count of active team members for those teams\n      const { count, error } = await this.supabase\n        .from('team_members')\n        .select('*', { count: 'exact', head: true })\n        .eq('is_active', true)\n        .in('team_id', teams.map(t => t.id));\n\n      if (error) throw error;\n      return { data: count || 0, error: null, success: true };\n    } catch (error) {\n      return { data: 0, error: this.handleError(error, 'getLeaguePlayerCount'), success: false };\n    }\n  }\n\n  private async getLeagueAvailableSpots(leagueId: string): Promise<ServiceResponse<number>> {\n    try {\n      // Get all teams in the league with their member counts\n      const { data: teams, error } = await this.supabase\n        .from('teams')\n        .select(`\n          id,\n          max_players,\n          team_members(id, is_active)\n        `)\n        .eq('league_id', leagueId);\n\n      if (error) throw error;\n      \n      if (!teams || teams.length === 0) {\n        return { data: 0, error: null, success: true };\n      }\n\n      // Calculate available spots across all teams\n      const availableSpots = teams.reduce((total, team) => {\n        const activeMembers = team.team_members?.filter(member => member.is_active).length || 0;\n        const maxPlayers = team.max_players || 11;\n        return total + Math.max(0, maxPlayers - activeMembers);\n      }, 0);\n\n      return { data: availableSpots, error: null, success: true };\n    } catch (error) {\n      return { data: 0, error: this.handleError(error, 'getLeagueAvailableSpots'), success: false };\n    }\n  }\n\n  private calculateSkillMatch(league: LeagueDiscovery, userStats: any): number {\n    if (!userStats) return 50; // Neutral score for new players\n\n    const avgGoalsPerGame = userStats.avg_goals_per_game || 0;\n    const totalGames = userStats.total_games_played || 0;\n\n    // Simple skill matching logic\n    if (league.league_type === 'casual' && totalGames < 10) return 85;\n    if (league.league_type === 'competitive' && avgGoalsPerGame > 0.5) return 80;\n    if (league.league_type === 'friendly') return 75;\n    \n    return 60;\n  }\n\n  private calculateLocationProximity(league: LeagueDiscovery, userProfile: any): number {\n    // Simplified location matching - would need geolocation in real implementation\n    if (!league.location || !userProfile.location) return 50;\n    \n    const leagueLocation = league.location.toLowerCase();\n    const userLocation = userProfile.location.toLowerCase();\n    \n    if (leagueLocation.includes(userLocation) || userLocation.includes(leagueLocation)) {\n      return 90;\n    }\n    \n    return 40;\n  }\n\n  private calculateScheduleCompatibility(league: LeagueDiscovery): number {\n    const now = new Date();\n    const seasonStart = new Date(league.season_start || now);\n    const seasonEnd = new Date(league.season_end || now);\n    \n    // Check if season is upcoming or current\n    if (seasonStart > now) return 85; // Upcoming season\n    if (seasonEnd > now) return 70; // Current season\n    \n    return 30; // Past season\n  }\n\n  private calculateTeamAvailability(league: LeagueDiscovery): number {\n    if (league.availableSpots === 0) return 0;\n    if (league.availableSpots > 10) return 95;\n    if (league.availableSpots > 5) return 80;\n    return 60;\n  }\n\n  private calculateEntryAffordability(league: LeagueDiscovery, userProfile: any): number {\n    const entryFee = league.entry_fee || 0;\n    \n    // Simplified affordability calculation\n    if (entryFee === 0) return 100;\n    if (entryFee < 50) return 85;\n    if (entryFee < 100) return 70;\n    return 50;\n  }\n\n  private generateRecommendations(factors: any, league: LeagueDiscovery): string[] {\n    const recommendations: string[] = [];\n    \n    if (factors.skillMatch < 60) {\n      recommendations.push('Consider improving your skills before joining this competitive league');\n    }\n    \n    if (factors.locationProximity < 50) {\n      recommendations.push('This league might be far from your location');\n    }\n    \n    if (factors.teamAvailability < 50) {\n      recommendations.push('Limited team spots available - apply soon');\n    }\n    \n    if (factors.entryAffordability < 60) {\n      recommendations.push('Entry fee might be higher than average');\n    }\n    \n    return recommendations;\n  }\n\n  private getRequiredPositions(team: any, activeMembers: any[]): string[] {\n    // Simplified position requirement logic\n    const positions = ['Goalkeeper', 'Defender', 'Midfielder', 'Forward'];\n    const occupiedPositions = activeMembers.map(m => m.position).filter(Boolean);\n    \n    return positions.filter(pos => !occupiedPositions.includes(pos));\n  }\n\n  /**\n   * Subscribe to real-time league updates\n   */\n  subscribeToLeagueUpdates(\n    leagueId: string,\n    callback: (payload: any) => void,\n    options: RealtimeSubscriptionOptions = { table: 'leagues', event: '*' }\n  ) {\n    return this.supabase\n      .channel(`league-${leagueId}-updates`)\n      .on(\n        'postgres_changes',\n        {\n          event: options.event,\n          schema: options.schema || 'public',\n          table: options.table,\n          filter: options.filter || `id=eq.${leagueId}`\n        },\n        callback\n      )\n      .subscribe();\n  }\n\n  /**\n   * Clear cache\n   */\n  clearCache(pattern?: string): void {\n    if (!pattern) {\n      this.cache.clear();\n      return;\n    }\n\n    const keys = Array.from(this.cache.keys());\n    keys.forEach(key => {\n      if (key.includes(pattern)) {\n        this.cache.delete(key);\n      }\n    });\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1059, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/team.service.ts"],"sourcesContent":["/**\n * Team Service for MatchDay\n * \n * Handles comprehensive team-related operations with focus on:\n * - Team creation and management\n * - Team member management and join requests\n * - Team statistics and performance tracking\n * - Real-time team updates and notifications\n * \n * Optimized for amateur sports leagues with proper error handling,\n * caching strategies, and authentication integration.\n */\n\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport {\n  Database,\n  Team,\n  TeamMember,\n  InsertTeam,\n  UpdateTeam,\n  CreateTeamForm,\n  ServiceResponse,\n  ServiceError,\n  PaginatedServiceResponse,\n  TeamJoinRequest,\n  JoinRequestStatus,\n  UserProfile,\n  League,\n  CacheOptions,\n  RealtimeSubscriptionOptions\n} from '@/lib/types/database.types';\n\nexport interface TeamWithDetails extends Team {\n  league: League | null;\n  leagues: Array<{\n    id: string;\n    name: string;\n    seasons: number[];\n    isCurrent: boolean;\n  }>;\n  captain?: UserProfile;\n  members: Array<TeamMember & { user_profile: UserProfile }>;\n  memberCount: number;\n  availableSpots: number;\n  joinRequests?: TeamJoinRequest[];\n  stats?: {\n    wins: number;\n    draws: number;\n    losses: number;\n    goals_for: number;\n    goals_against: number;\n    points: number;\n    position: number;\n    total_teams: number;\n  };\n  isOrphaned?: boolean;\n  previousLeagueName?: string;\n}\n\nexport interface TeamCreationOptions {\n  auto_add_creator: boolean;\n  initial_position?: string;\n  initial_jersey_number?: number;\n}\n\nexport class TeamService {\n  private static instance: TeamService;\n  private supabase: SupabaseClient<Database>;\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n\n  private constructor(supabaseClient: SupabaseClient<Database>) {\n    this.supabase = supabaseClient;\n  }\n\n  static getInstance(supabaseClient?: SupabaseClient<Database>): TeamService {\n    if (!TeamService.instance) {\n      if (!supabaseClient) {\n        throw new Error('SupabaseClient required for first initialization');\n      }\n      TeamService.instance = new TeamService(supabaseClient);\n    } else if (supabaseClient) {\n      // Always update the supabase client to ensure fresh authentication context\n      TeamService.instance.supabase = supabaseClient;\n    }\n    return TeamService.instance;\n  }\n\n  /**\n   * Handle service errors consistently\n   */\n  private handleError(error: any, operation: string): ServiceError {\n    console.error(`TeamService.${operation}:`, error);\n    return {\n      code: error.code || 'UNKNOWN_ERROR',\n      message: error.message || 'An unexpected error occurred',\n      details: error.details || error,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Cache management utilities\n   */\n  private getCacheKey(operation: string, params: any): string {\n    return `team_service:${operation}:${JSON.stringify(params)}`;\n  }\n\n  private getFromCache<T>(key: string): T | null {\n    const cached = this.cache.get(key);\n    if (!cached) return null;\n    \n    if (Date.now() - cached.timestamp > cached.ttl * 1000) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return cached.data as T;\n  }\n\n  private setCache<T>(key: string, data: T, ttl = 300): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl\n    });\n  }\n\n  /**\n   * Create a new team\n   */\n  async createTeam(\n    captainId: string,\n    teamData: CreateTeamForm,\n    options: TeamCreationOptions = { auto_add_creator: true }\n  ): Promise<ServiceResponse<TeamWithDetails>> {\n    try {\n      // First, validate that the league exists and is active\n      const { data: league, error: leagueError } = await this.supabase\n        .from('leagues')\n        .select('*')\n        .eq('id', teamData.league_id)\n        .eq('is_active', true)\n        .single();\n\n      if (leagueError) {\n        if (leagueError.code === 'PGRST116') {\n          return {\n            data: null,\n            error: {\n              code: 'LEAGUE_NOT_FOUND',\n              message: 'Selected league not found or is not active',\n              timestamp: new Date().toISOString()\n            },\n            success: false\n          };\n        }\n        throw leagueError;\n      }\n\n      // Check if team name is unique within the league\n      const { data: existingTeam, error: nameCheckError } = await this.supabase\n        .from('teams')\n        .select('id')\n        .eq('league_id', teamData.league_id)\n        .eq('name', teamData.name)\n        .single();\n\n      if (nameCheckError && nameCheckError.code !== 'PGRST116') {\n        throw nameCheckError;\n      }\n\n      if (existingTeam) {\n        return {\n          data: null,\n          error: {\n            code: 'TEAM_NAME_EXISTS',\n            message: 'A team with this name already exists in the selected league',\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      // Use a transaction-like approach: create team without captain first, then add member, then update captain\n      // This avoids the chicken-and-egg problem with foreign key constraints\n      \n      // Step 1: Create team record without captain initially\n      const teamInsert: InsertTeam = {\n        league_id: teamData.league_id,\n        name: teamData.name,\n        team_color: teamData.team_color,\n        captain_id: null, // Initially null to avoid FK constraint issues\n        max_players: teamData.max_players || 22,\n        min_players: teamData.min_players || 7,\n        is_recruiting: true,\n        team_bio: teamData.description || null\n      };\n\n      const { data: newTeam, error: teamError } = await this.supabase\n        .from('teams')\n        .insert(teamInsert)\n        .select()\n        .single();\n\n      if (teamError) throw teamError;\n\n      try {\n        // Step 2: Add creator as team member\n        if (options.auto_add_creator) {\n          const { error: memberError } = await this.supabase\n            .from('team_members')\n            .insert({\n              team_id: newTeam.id,\n              user_id: captainId,\n              position: options.initial_position || 'midfielder',\n              jersey_number: options.initial_jersey_number || 1,\n              is_active: true\n            });\n\n          if (memberError) throw memberError;\n        }\n\n        // Step 3: Update team with captain_id now that member exists\n        const { error: updateError } = await this.supabase\n          .from('teams')\n          .update({ captain_id: captainId })\n          .eq('id', newTeam.id);\n\n        if (updateError) throw updateError;\n\n      } catch (error) {\n        // If any step fails, clean up the team\n        await this.supabase.from('teams').delete().eq('id', newTeam.id);\n        throw error;\n      }\n\n      // Return the created team data directly without complex details lookup\n      // to avoid potential infinite recursion during creation\n      const basicTeamData: TeamWithDetails = {\n        ...newTeam,\n        captain_id: captainId, // Use the updated captain_id\n        league: null, // Will be populated later if needed\n        captain: undefined,\n        members: [],\n        memberCount: options.auto_add_creator ? 1 : 0,\n        availableSpots: (teamData.max_players || 22) - (options.auto_add_creator ? 1 : 0),\n        isOrphaned: false,\n        previousLeagueName: undefined\n      };\n\n      // Clear relevant caches\n      this.clearCache('getUserTeams');\n\n      return {\n        data: basicTeamData,\n        error: null,\n        success: true\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'createTeam'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get season year for a team by checking their actual match dates\n   */\n  private async getTeamSeasonYear(teamId: string): Promise<number> {\n    // Check if team has completed matches and get their season year\n    const { data: matchYears } = await this.supabase\n      .from('matches')\n      .select('match_date')\n      .or(`home_team_id.eq.${teamId},away_team_id.eq.${teamId}`)\n      .eq('status', 'completed')\n      .limit(1);\n    \n    if (matchYears && matchYears.length > 0) {\n      const matchYear = new Date(matchYears[0].match_date).getFullYear();\n      return matchYear;\n    }\n    \n    // Fallback to current year if no completed matches\n    return new Date().getFullYear();\n  }\n\n  /**\n   * Get all leagues this team has participated in\n   */\n  private async getTeamLeagues(teamId: string): Promise<Array<{\n    id: string;\n    name: string;\n    seasons: number[];\n    isCurrent: boolean;\n  }>> {\n    try {\n      // Get all leagues from team_stats (historical participation)\n      const { data: leagueStats, error } = await this.supabase\n        .from('team_stats')\n        .select(`\n          league_id,\n          season_year,\n          leagues!inner(id, name)\n        `)\n        .eq('team_id', teamId);\n\n      if (error) {\n        console.error('Error fetching team leagues:', error);\n        return [];\n      }\n\n      if (!leagueStats || leagueStats.length === 0) {\n        return [];\n      }\n\n      // Group by league and collect seasons\n      const leaguesMap = new Map();\n      \n      leagueStats.forEach(stat => {\n        if (!stat.leagues) return;\n        \n        const leagueId = stat.leagues.id;\n        if (!leaguesMap.has(leagueId)) {\n          leaguesMap.set(leagueId, {\n            id: leagueId,\n            name: stat.leagues.name,\n            seasons: [],\n            isCurrent: false\n          });\n        }\n        \n        const league = leaguesMap.get(leagueId);\n        if (!league.seasons.includes(stat.season_year)) {\n          league.seasons.push(stat.season_year);\n        }\n      });\n\n      // Convert map to array and sort seasons\n      const leagues = Array.from(leaguesMap.values());\n      leagues.forEach(league => {\n        league.seasons.sort((a, b) => b - a); // Latest first\n        // Mark as current if it's the team's current league\n        // We'll determine this in the main method\n      });\n\n      return leagues.sort((a, b) => a.name.localeCompare(b.name));\n    } catch (error) {\n      console.error('Error in getTeamLeagues:', error);\n      return [];\n    }\n  }\n\n  /**\n   * Get detailed team information\n   */\n  async getTeamDetails(\n    teamId: string,\n    options: CacheOptions = {}\n  ): Promise<ServiceResponse<TeamWithDetails>> {\n    try {\n      const cacheKey = this.getCacheKey('getTeamDetails', { teamId });\n      const cached = this.getFromCache<TeamWithDetails>(cacheKey);\n      \n      if (cached && !options.revalidateOnBackground) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Get team with league and member details\n      // Use left join for leagues since team might be orphaned\n      const { data: team, error: teamError } = await this.supabase\n        .from('teams')\n        .select(`\n          *,\n          league:leagues(*),\n          team_members(\n            *,\n            user_profile:users(*)\n          )\n        `)\n        .eq('id', teamId)\n        .single();\n\n      if (teamError) {\n        if (teamError.code === 'PGRST116') {\n          return {\n            data: null,\n            error: {\n              code: 'TEAM_NOT_FOUND',\n              message: 'Team not found',\n              timestamp: new Date().toISOString()\n            },\n            success: false\n          };\n        }\n        throw teamError;\n      }\n\n      // Get captain profile if exists\n      let captain: UserProfile | undefined;\n      if (team.captain_id) {\n        const { data: captainProfile } = await this.supabase\n          .from('users')\n          .select('*')\n          .eq('id', team.captain_id)\n          .single();\n        \n        captain = captainProfile || undefined;\n      }\n\n      // Get season year for this team\n      const seasonYear = await this.getTeamSeasonYear(teamId);\n      \n      // Get all leagues this team has participated in\n      const teamLeagues = await this.getTeamLeagues(teamId);\n      \n      // Get team statistics\n      const { data: teamStats } = await this.supabase\n        .from('team_stats')\n        .select('*')\n        .eq('team_id', teamId)\n        .eq('season_year', seasonYear)\n        .single();\n\n      // Calculate team position if stats exist and team has a league\n      let stats;\n      if (teamStats && team.league_id) {\n        const { data: leagueTeams } = await this.supabase\n          .from('team_stats')\n          .select('team_id, points, goals_for, goals_against')\n          .eq('league_id', team.league_id)\n          .eq('season_year', seasonYear)\n          .order('points', { ascending: false });\n\n        const position = leagueTeams?.findIndex(t => t.team_id === teamId) + 1 || 1;\n        \n        stats = {\n          wins: teamStats.wins || 0,\n          draws: teamStats.draws || 0,\n          losses: teamStats.losses || 0,\n          goals: teamStats.goals_for || 0,\n          goalsAgainst: teamStats.goals_against || 0,\n          points: teamStats.points || 0,\n          position,\n          totalTeams: leagueTeams?.length || 1\n        };\n      } else if (teamStats) {\n        // Team has stats but no league (orphaned team)\n        stats = {\n          wins: teamStats.wins || 0,\n          draws: teamStats.draws || 0,\n          losses: teamStats.losses || 0,\n          goals: teamStats.goals_for || 0,\n          goalsAgainst: teamStats.goals_against || 0,\n          points: teamStats.points || 0,\n          position: 0,\n          totalTeams: 0\n        };\n      }\n\n      // Mark current league in the leagues array\n      const leagues = teamLeagues.map(league => ({\n        ...league,\n        isCurrent: league.id === team.league_id\n      }));\n\n      const activeMembers = team.team_members?.filter((m: any) => m.is_active) || [];\n      const teamWithDetails: TeamWithDetails = {\n        ...team,\n        league: team.league || null,\n        leagues: leagues,\n        captain,\n        members: activeMembers,\n        memberCount: activeMembers.length,\n        availableSpots: Math.max(0, (team.max_players || 22) - activeMembers.length),\n        stats,\n        isOrphaned: !team.league_id,\n        previousLeagueName: team.previous_league_name || undefined\n      };\n\n      // Cache for 5 minutes, but clear existing cache to ensure fresh data\n      this.clearCache('getTeamDetails');\n      this.setCache(cacheKey, teamWithDetails, options.ttl || 300);\n\n      return { data: teamWithDetails, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getTeamDetails'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get all teams for a user (where user is a member)\n   */\n  async getUserTeams(\n    userId: string,\n    options: { includeInactive?: boolean; limit?: number } = {}\n  ): Promise<ServiceResponse<TeamWithDetails[]>> {\n    try {\n      const cacheKey = this.getCacheKey('getUserTeams', { userId, options });\n      const cached = this.getFromCache<TeamWithDetails[]>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      console.log('üîç TeamService.getUserTeams - Querying for user:', userId);\n\n      let memberQuery = this.supabase\n        .from('team_members')\n        .select(`\n          *,\n          team:teams!inner(\n            *,\n            league:leagues(*)\n          )\n        `)\n        .eq('user_id', userId);\n\n      if (!options.includeInactive) {\n        memberQuery = memberQuery.eq('is_active', true);\n      }\n\n      console.log('üîç TeamService.getUserTeams - Executing query...');\n      const { data: memberships, error: memberError } = await memberQuery\n        .order('joined_at', { ascending: false })\n        .limit(options.limit || 50);\n\n      console.log('üîç TeamService.getUserTeams - Query result:', {\n        membershipsCount: memberships?.length || 0,\n        error: memberError?.message || null,\n        memberships: memberships\n      });\n\n      if (memberError) throw memberError;\n\n      // PERFORMANCE OPTIMIZATION: Use embedded team data directly instead of expensive getTeamDetails calls\n      console.log('üîç TeamService.getUserTeams - Processing', memberships?.length || 0, 'memberships');\n      console.log('üöÄ OPTIMIZATION: Using embedded team data to eliminate N+1 query problem');\n      \n      const teams = (memberships || []).map((membership, index) => {\n        console.log(`üîç TeamService.getUserTeams - Processing membership ${index + 1}:`, {\n          teamId: membership.team_id,\n          position: membership.position,\n          hasEmbeddedTeam: !!membership.team,\n          teamName: membership.team?.name\n        });\n        \n        if (!membership.team) {\n          console.warn(`‚ö†Ô∏è No embedded team data for membership ${membership.team_id}`);\n          return null;\n        }\n\n        // Create TeamWithDetails from embedded data - no additional queries needed\n        const teamWithDetails: TeamWithDetails = {\n          // Core team data (all available from the initial query)\n          id: membership.team.id,\n          name: membership.team.name,\n          description: membership.team.description || '',\n          team_color: membership.team.team_color,\n          max_players: membership.team.max_players || 22,\n          team_bio: membership.team.team_bio || '',\n          captain_id: membership.team.captain_id,\n          league_id: membership.team.league_id,\n          is_active: membership.team.is_active ?? true,\n          created_at: membership.team.created_at,\n          updated_at: membership.team.updated_at,\n          \n          // League information (already included in query via join)\n          league: membership.team.league,\n          \n          // Simplified member information for team listing (avoid expensive queries)\n          captain: null, // Skip captain lookup for performance\n          members: [], // Skip member list for team listing\n          memberCount: 1, // At least the current user is a member\n          availableSpots: Math.max(0, (membership.team.max_players || 22) - 1),\n          \n          // Status flags\n          isOrphaned: !membership.team.league_id,\n          \n          // Skip expensive aggregations for team listing\n          stats: undefined,\n          joinRequests: undefined\n        };\n\n        console.log(`‚úÖ Created optimized team data for ${membership.team.name} (no additional queries)`);\n        return teamWithDetails;\n      });\n      console.log('üîç TeamService.getUserTeams - Team processing results:', {\n        totalTeams: teams.length,\n        validTeams: teams.filter(t => t !== null).length,\n        nullTeams: teams.filter(t => t === null).length\n      });\n      \n      const validTeams = teams.filter((team): team is TeamWithDetails => team !== null);\n\n      // Cache for 5 minutes\n      this.setCache(cacheKey, validTeams, 300);\n\n      console.log('üéØ TeamService.getUserTeams - Final result:', {\n        success: true,\n        teamsCount: validTeams.length,\n        teamNames: validTeams.map(t => t.name)\n      });\n\n      return { data: validTeams, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getUserTeams'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Update team information\n   */\n  async updateTeam(\n    teamId: string,\n    captainId: string,\n    updates: UpdateTeam\n  ): Promise<ServiceResponse<Team>> {\n    try {\n      // Verify the user is the team captain\n      const { data: team, error: verifyError } = await this.supabase\n        .from('teams')\n        .select('captain_id')\n        .eq('id', teamId)\n        .single();\n\n      if (verifyError) throw verifyError;\n\n      if (team.captain_id !== captainId) {\n        return {\n          data: null,\n          error: {\n            code: 'UNAUTHORIZED',\n            message: 'Only team captains can update team information',\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      // Update team\n      const { data: updatedTeam, error: updateError } = await this.supabase\n        .from('teams')\n        .update({\n          ...updates,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', teamId)\n        .select()\n        .single();\n\n      if (updateError) throw updateError;\n\n      // Clear caches\n      this.clearCache('getTeamDetails');\n      this.clearCache('getUserTeams');\n\n      return { data: updatedTeam, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'updateTeam'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Find league by sport and location for team creation\n   */\n  async findLeagueByName(\n    sport: string,\n    leagueName: string\n  ): Promise<ServiceResponse<League>> {\n    try {\n      const { data: league, error } = await this.supabase\n        .from('leagues')\n        .select('*')\n        .eq('sport_type', sport.toLowerCase())\n        .eq('name', leagueName)\n        .eq('is_active', true)\n        .eq('is_public', true)\n        .single();\n\n      if (error) {\n        if (error.code === 'PGRST116') {\n          return {\n            data: null,\n            error: {\n              code: 'LEAGUE_NOT_FOUND',\n              message: 'No active league found with the specified name and sport',\n              timestamp: new Date().toISOString()\n            },\n            success: false\n          };\n        }\n        throw error;\n      }\n\n      return { data: league, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'findLeagueByName'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Search teams across leagues\n   */\n  async searchTeams(options: {\n    query?: string;\n    sport?: string;\n    location?: string;\n    hasAvailableSpots?: boolean;\n    limit?: number;\n    offset?: number;\n  } = {}): Promise<PaginatedServiceResponse<TeamWithDetails>> {\n    try {\n      let query = this.supabase\n        .from('teams')\n        .select(`\n          *,\n          league:leagues!inner(*)\n        `, { count: 'exact' })\n        .eq('league.is_active', true)\n        .eq('league.is_public', true);\n\n      if (options.query) {\n        query = query.or(`name.ilike.%${options.query}%,team_bio.ilike.%${options.query}%`);\n      }\n\n      if (options.sport) {\n        query = query.eq('league.sport_type', options.sport.toLowerCase());\n      }\n\n      if (options.location) {\n        query = query.ilike('league.location', `%${options.location}%`);\n      }\n\n      if (options.hasAvailableSpots) {\n        query = query.eq('is_recruiting', true);\n      }\n\n      const { data: teams, error, count } = await query\n        .order('created_at', { ascending: false })\n        .range(options.offset || 0, (options.offset || 0) + (options.limit || 20) - 1);\n\n      if (error) throw error;\n\n      // Get detailed information for each team\n      const teamPromises = (teams || []).map(async (team) => {\n        const teamDetails = await this.getTeamDetails(team.id);\n        return teamDetails.data;\n      });\n\n      const detailedTeams = await Promise.all(teamPromises);\n      const validTeams = detailedTeams.filter((team): team is TeamWithDetails => team !== null);\n\n      // Filter by available spots if requested\n      const filteredTeams = options.hasAvailableSpots \n        ? validTeams.filter(team => team.availableSpots > 0)\n        : validTeams;\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n        limit: options.limit || 20,\n        total: count || 0,\n        totalPages: Math.ceil((count || 0) / (options.limit || 20)),\n        hasNext: ((options.offset || 0) + (options.limit || 20)) < (count || 0),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: filteredTeams,\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'searchTeams'),\n        success: false,\n        pagination: {\n          page: 1,\n          limit: options.limit || 20,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrevious: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Subscribe to real-time team updates\n   */\n  subscribeToTeamUpdates(\n    teamId: string,\n    callback: (payload: any) => void,\n    options: RealtimeSubscriptionOptions = { table: 'teams', event: '*' }\n  ) {\n    return this.supabase\n      .channel(`team-${teamId}-updates`)\n      .on(\n        'postgres_changes',\n        {\n          event: options.event,\n          schema: options.schema || 'public',\n          table: options.table,\n          filter: options.filter || `id=eq.${teamId}`\n        },\n        callback\n      )\n      .subscribe();\n  }\n\n  /**\n   * Clear cache for specific operations or all cache\n   */\n  clearCache(pattern?: string): void {\n    if (!pattern) {\n      this.cache.clear();\n      return;\n    }\n\n    const keys = Array.from(this.cache.keys());\n    keys.forEach(key => {\n      if (key.includes(pattern)) {\n        this.cache.delete(key);\n      }\n    });\n  }\n\n  /**\n   * Get all orphaned teams (teams without a league)\n   */\n  async getOrphanedTeams(options: {\n    includeArchived?: boolean;\n    limit?: number;\n    offset?: number;\n  } = {}): Promise<PaginatedServiceResponse<TeamWithDetails>> {\n    try {\n      let query = this.supabase\n        .from('teams')\n        .select(`\n          *,\n          league:leagues(*),\n          team_members(\n            *,\n            user_profile:users(*)\n          )\n        `, { count: 'exact' })\n        .is('league_id', null);\n\n      if (!options.includeArchived) {\n        query = query.eq('is_archived', false);\n      }\n\n      const { data: teams, error, count } = await query\n        .order('updated_at', { ascending: false })\n        .range(options.offset || 0, (options.offset || 0) + (options.limit || 20) - 1);\n\n      if (error) throw error;\n\n      // Get detailed information for each team\n      const teamPromises = (teams || []).map(async (team) => {\n        const teamDetails = await this.getTeamDetails(team.id);\n        return teamDetails.data;\n      });\n\n      const detailedTeams = await Promise.all(teamPromises);\n      const validTeams = detailedTeams.filter((team): team is TeamWithDetails => team !== null);\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n        limit: options.limit || 20,\n        total: count || 0,\n        totalPages: Math.ceil((count || 0) / (options.limit || 20)),\n        hasNext: ((options.offset || 0) + (options.limit || 20)) < (count || 0),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: validTeams,\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getOrphanedTeams'),\n        success: false,\n        pagination: {\n          page: 1,\n          limit: options.limit || 20,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrevious: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Reassign an orphaned team to a new league\n   */\n  async reassignTeamToLeague(\n    teamId: string,\n    newLeagueId: string,\n    userId: string\n  ): Promise<ServiceResponse<TeamWithDetails>> {\n    try {\n      // Verify the user is the team captain\n      const { data: team, error: verifyError } = await this.supabase\n        .from('teams')\n        .select('captain_id, name, league_id')\n        .eq('id', teamId)\n        .single();\n\n      if (verifyError) throw verifyError;\n\n      if (team.captain_id !== userId) {\n        return {\n          data: null,\n          error: {\n            code: 'UNAUTHORIZED',\n            message: 'Only team captains can reassign their team to a new league',\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      // Verify the new league exists and is active\n      const { data: league, error: leagueError } = await this.supabase\n        .from('leagues')\n        .select('*')\n        .eq('id', newLeagueId)\n        .eq('is_active', true)\n        .single();\n\n      if (leagueError) {\n        if (leagueError.code === 'PGRST116') {\n          return {\n            data: null,\n            error: {\n              code: 'LEAGUE_NOT_FOUND',\n              message: 'Selected league not found or is not active',\n              timestamp: new Date().toISOString()\n            },\n            success: false\n          };\n        }\n        throw leagueError;\n      }\n\n      // Check if team name is unique in the new league\n      const { data: existingTeam, error: nameCheckError } = await this.supabase\n        .from('teams')\n        .select('id')\n        .eq('league_id', newLeagueId)\n        .eq('name', team.name)\n        .neq('id', teamId)\n        .single();\n\n      if (nameCheckError && nameCheckError.code !== 'PGRST116') {\n        throw nameCheckError;\n      }\n\n      if (existingTeam) {\n        return {\n          data: null,\n          error: {\n            code: 'TEAM_NAME_EXISTS',\n            message: 'A team with this name already exists in the selected league',\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      // Update the team\n      const { data: updatedTeam, error: updateError } = await this.supabase\n        .from('teams')\n        .update({\n          league_id: newLeagueId,\n          previous_league_name: null,\n          is_archived: false,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', teamId)\n        .select()\n        .single();\n\n      if (updateError) throw updateError;\n\n      // Get the complete team details\n      const teamDetails = await this.getTeamDetails(teamId);\n      \n      if (!teamDetails.success || !teamDetails.data) {\n        throw new Error('Failed to retrieve updated team details');\n      }\n\n      // Clear caches\n      this.clearCache('getTeamDetails');\n      this.clearCache('getUserTeams');\n      this.clearCache('getOrphanedTeams');\n\n      return {\n        data: teamDetails.data,\n        error: null,\n        success: true\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'reassignTeamToLeague'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Archive an orphaned team\n   */\n  async archiveTeam(\n    teamId: string,\n    userId: string\n  ): Promise<ServiceResponse<Team>> {\n    try {\n      // Verify the user is the team captain\n      const { data: team, error: verifyError } = await this.supabase\n        .from('teams')\n        .select('captain_id')\n        .eq('id', teamId)\n        .single();\n\n      if (verifyError) throw verifyError;\n\n      if (team.captain_id !== userId) {\n        return {\n          data: null,\n          error: {\n            code: 'UNAUTHORIZED',\n            message: 'Only team captains can archive their team',\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      // Archive the team\n      const { data: archivedTeam, error: updateError } = await this.supabase\n        .from('teams')\n        .update({\n          is_archived: true,\n          is_recruiting: false,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', teamId)\n        .select()\n        .single();\n\n      if (updateError) throw updateError;\n\n      // Clear caches\n      this.clearCache('getTeamDetails');\n      this.clearCache('getUserTeams');\n      this.clearCache('getOrphanedTeams');\n\n      return { data: archivedTeam, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'archiveTeam'),\n        success: false\n      };\n    }\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 1848, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/match.service.ts"],"sourcesContent":["/**\n * Match Service for MatchDay\n * \n * Handles match viewing and statistics operations with focus on:\n * - Player's upcoming and past matches\n * - Match events and statistics\n * - Live match tracking and real-time updates\n * - Performance metrics and match analysis\n * \n * Optimized for player-centric match experience with comprehensive statistics\n */\n\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport {\n  Database,\n  Match,\n  MatchEvent,\n  MatchWithDetails,\n  LiveMatchData,\n  ActiveMatch,\n  ServiceResponse,\n  ServiceError,\n  PaginatedServiceResponse,\n  MatchStatus,\n  EventType,\n  CacheOptions,\n  RealtimeSubscriptionOptions\n} from '@/lib/types/database.types';\n\nexport interface MatchFilters {\n  leagueId?: string;\n  teamId?: string;\n  status?: MatchStatus;\n  dateFrom?: string;\n  dateTo?: string;\n  venue?: string;\n  sportType?: string;\n}\n\nexport interface PlayerMatchStats {\n  matchId: string;\n  playerId: string;\n  playerName: string;\n  goals: number;\n  assists: number;\n  yellowCards: number;\n  redCards: number;\n  minutesPlayed: number;\n  position?: string;\n  events: MatchEvent[];\n  performance: {\n    rating: number;\n    keyPasses: number;\n    successfulPasses: number;\n    totalPasses: number;\n    tackles: number;\n    saves?: number;\n  };\n}\n\nexport interface MatchPrediction {\n  matchId: string;\n  homeWinProbability: number;\n  drawProbability: number;\n  awayWinProbability: number;\n  expectedGoalsHome: number;\n  expectedGoalsAway: number;\n  keyFactors: string[];\n  confidence: number;\n}\n\nexport interface MatchAnalytics {\n  matchId: string;\n  duration: number;\n  totalEvents: number;\n  goalsByPeriod: {\n    firstHalf: { home: number; away: number };\n    secondHalf: { home: number; away: number };\n    extraTime?: { home: number; away: number };\n  };\n  cardsByTeam: {\n    home: { yellow: number; red: number };\n    away: { yellow: number; red: number };\n  };\n  topPerformers: {\n    home: PlayerMatchStats[];\n    away: PlayerMatchStats[];\n  };\n  matchMomentum: Array<{\n    minute: number;\n    homeScore: number;\n    awayScore: number;\n    eventType: EventType;\n    momentum: number; // -100 to 100 (negative = away momentum, positive = home momentum)\n  }>;\n}\n\nexport class MatchService {\n  private static instance: MatchService;\n  private supabase: SupabaseClient<Database>;\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n\n  private constructor(supabaseClient: SupabaseClient<Database>) {\n    this.supabase = supabaseClient;\n  }\n\n  static getInstance(supabaseClient?: SupabaseClient<Database>): MatchService {\n    if (!MatchService.instance) {\n      if (!supabaseClient) {\n        throw new Error('SupabaseClient required for first initialization');\n      }\n      MatchService.instance = new MatchService(supabaseClient);\n    }\n    return MatchService.instance;\n  }\n\n  /**\n   * Handle service errors consistently\n   */\n  private handleError(error: any, operation: string): ServiceError {\n    console.error(`MatchService.${operation}:`, error);\n    return {\n      code: error.code || 'UNKNOWN_ERROR',\n      message: error.message || 'An unexpected error occurred',\n      details: error.details || error,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Cache management utilities\n   */\n  private getCacheKey(operation: string, params: any): string {\n    return `match_service:${operation}:${JSON.stringify(params)}`;\n  }\n\n  private getFromCache<T>(key: string): T | null {\n    const cached = this.cache.get(key);\n    if (!cached) return null;\n    \n    if (Date.now() - cached.timestamp > cached.ttl * 1000) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return cached.data as T;\n  }\n\n  private setCache<T>(key: string, data: T, ttl = 300): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl\n    });\n  }\n\n  /**\n   * Get player's matches with detailed information\n   */\n  async getPlayerMatches(\n    userId: string,\n    filters: MatchFilters = {},\n    options: {\n      limit?: number;\n      offset?: number;\n      includeFutureMatches?: boolean;\n      includeStats?: boolean;\n    } = {}\n  ): Promise<PaginatedServiceResponse<MatchWithDetails>> {\n    try {\n      const cacheKey = this.getCacheKey('getPlayerMatches', { userId, filters, options });\n      const cached = this.getFromCache<MatchWithDetails[]>(cacheKey);\n      \n      if (cached) {\n        return {\n          data: cached,\n          error: null,\n          success: true,\n          pagination: {\n            page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n            limit: options.limit || 20,\n            total: cached.length,\n            totalPages: Math.ceil(cached.length / (options.limit || 20)),\n            hasNext: false,\n            hasPrevious: false\n          }\n        };\n      }\n\n      // Get player's teams to find their matches\n      const { data: userTeams, error: teamsError } = await this.supabase\n        .from('team_members')\n        .select('team_id')\n        .eq('user_id', userId)\n        .eq('is_active', true);\n\n      if (teamsError) throw teamsError;\n\n      if (!userTeams || userTeams.length === 0) {\n        return {\n          data: [],\n          error: null,\n          success: true,\n          pagination: {\n            page: 1,\n            limit: options.limit || 20,\n            total: 0,\n            totalPages: 0,\n            hasNext: false,\n            hasPrevious: false\n          }\n        };\n      }\n\n      const teamIds = userTeams.map(tm => tm.team_id);\n\n      // Build match query\n      let query = this.supabase\n        .from('matches')\n        .select(`\n          *,\n          home_team:teams!matches_home_team_id_fkey(*),\n          away_team:teams!matches_away_team_id_fkey(*),\n          league:leagues!inner(*)\n        `, { count: 'exact' })\n        .or(`home_team_id.in.(${teamIds.join(',')}),away_team_id.in.(${teamIds.join(',')})`);\n\n      // Apply filters\n      if (filters.leagueId) {\n        query = query.eq('league_id', filters.leagueId);\n      }\n\n      if (filters.status) {\n        query = query.eq('status', filters.status);\n      }\n\n      if (filters.dateFrom) {\n        query = query.gte('scheduled_date', filters.dateFrom);\n      }\n\n      if (filters.dateTo) {\n        query = query.lte('scheduled_date', filters.dateTo);\n      }\n\n      if (filters.venue) {\n        query = query.ilike('venue', `%${filters.venue}%`);\n      }\n\n      if (!options.includeFutureMatches) {\n        query = query.lte('scheduled_date', new Date().toISOString());\n      }\n\n      const { data: matches, error, count } = await query\n        .order('scheduled_date', { ascending: false })\n        .range(options.offset || 0, (options.offset || 0) + (options.limit || 20) - 1);\n\n      if (error) throw error;\n\n      // Get match events and stats for each match\n      const matchesWithDetails: MatchWithDetails[] = await Promise.all(\n        (matches || []).map(async (match) => {\n          // Get match events\n          const { data: events, error: eventsError } = await this.supabase\n            .from('match_events')\n            .select('*')\n            .eq('match_id', match.id)\n            .order('event_time', { ascending: true });\n\n          if (eventsError) throw eventsError;\n\n          // Get team players\n          const { data: homePlayers, error: homeError } = await this.supabase\n            .from('team_members')\n            .select(`\n              user_id,\n              position,\n              jersey_number,\n              users!inner(*)\n            `)\n            .eq('team_id', match.home_team_id)\n            .eq('is_active', true);\n\n          const { data: awayPlayers, error: awayError } = await this.supabase\n            .from('team_members')\n            .select(`\n              user_id,\n              position,\n              jersey_number,\n              users!inner(*)\n            `)\n            .eq('team_id', match.away_team_id)\n            .eq('is_active', true);\n\n          if (homeError) throw homeError;\n          if (awayError) throw awayError;\n\n          // Calculate player stats if requested\n          let playerStats;\n          if (options.includeStats) {\n            playerStats = await this.calculateMatchPlayerStats(match.id, userId);\n          }\n\n          return {\n            ...match,\n            homeTeam: match.home_team,\n            awayTeam: match.away_team,\n            league: match.league,\n            events: events || [],\n            homeTeamPlayers: (homePlayers || []).map(p => p.users),\n            awayTeamPlayers: (awayPlayers || []).map(p => p.users),\n            playerStats: playerStats ? [playerStats] : undefined\n          };\n        })\n      );\n\n      // Cache for 2 minutes (shorter for live data)\n      this.setCache(cacheKey, matchesWithDetails, 120);\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n        limit: options.limit || 20,\n        total: count || 0,\n        totalPages: Math.ceil((count || 0) / (options.limit || 20)),\n        hasNext: ((options.offset || 0) + (options.limit || 20)) < (count || 0),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: matchesWithDetails,\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerMatches'),\n        success: false,\n        pagination: {\n          page: 1,\n          limit: options.limit || 20,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrevious: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Get detailed match information\n   */\n  async getMatchDetails(\n    matchId: string,\n    options: { userId?: string; includeAnalytics?: boolean } = {}\n  ): Promise<ServiceResponse<MatchWithDetails & { analytics?: MatchAnalytics }>> {\n    try {\n      const cacheKey = this.getCacheKey('getMatchDetails', { matchId, includeAnalytics: options.includeAnalytics });\n      const cached = this.getFromCache<any>(cacheKey);\n      \n      if (cached && !options.userId) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Get match with complete details\n      const { data: match, error: matchError } = await this.supabase\n        .from('matches')\n        .select(`\n          *,\n          home_team:teams!matches_home_team_id_fkey(*),\n          away_team:teams!matches_away_team_id_fkey(*),\n          league:leagues!inner(*),\n          match_events(*)\n        `)\n        .eq('id', matchId)\n        .single();\n\n      if (matchError) {\n        if (matchError.code === 'PGRST116') {\n          return {\n            data: null,\n            error: { code: 'MATCH_NOT_FOUND', message: 'Match not found', timestamp: new Date().toISOString() },\n            success: false\n          };\n        }\n        throw matchError;\n      }\n\n      // Get team players with profiles\n      const [homePlayers, awayPlayers] = await Promise.all([\n        this.supabase\n          .from('team_members')\n          .select(`\n            user_id,\n            position,\n            jersey_number,\n            users!inner(*)\n          `)\n          .eq('team_id', match.home_team_id)\n          .eq('is_active', true),\n        this.supabase\n          .from('team_members')\n          .select(`\n            user_id,\n            position,\n            jersey_number,\n            users!inner(*)\n          `)\n          .eq('team_id', match.away_team_id)\n          .eq('is_active', true)\n      ]);\n\n      if (homePlayers.error) throw homePlayers.error;\n      if (awayPlayers.error) throw awayPlayers.error;\n\n      // Calculate player stats if userId provided\n      let playerStats;\n      if (options.userId) {\n        playerStats = await this.calculateMatchPlayerStats(matchId, options.userId);\n      }\n\n      // Generate match analytics if requested\n      let analytics;\n      if (options.includeAnalytics) {\n        analytics = await this.generateMatchAnalytics(matchId);\n      }\n\n      const matchWithDetails: MatchWithDetails = {\n        ...match,\n        homeTeam: match.home_team,\n        awayTeam: match.away_team,\n        league: match.league,\n        events: match.match_events || [],\n        homeTeamPlayers: (homePlayers.data || []).map(p => p.users),\n        awayTeamPlayers: (awayPlayers.data || []).map(p => p.users),\n        playerStats: playerStats ? [playerStats] : undefined\n      };\n\n      const result = {\n        ...matchWithDetails,\n        analytics: analytics?.data || undefined\n      };\n\n      // Cache if not user-specific\n      if (!options.userId) {\n        this.setCache(cacheKey, result, match.status === 'live' ? 30 : 600);\n      }\n\n      return { data: result, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getMatchDetails'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get live match data with real-time updates\n   */\n  async getLiveMatchData(matchId: string): Promise<ServiceResponse<LiveMatchData>> {\n    try {\n      // Get match details first\n      const matchResponse = await this.getMatchDetails(matchId, { includeAnalytics: true });\n      if (!matchResponse.success || !matchResponse.data) {\n        throw new Error('Match not found');\n      }\n\n      const match = matchResponse.data;\n\n      // Get recent events (last 10 minutes)\n      const tenMinutesAgo = new Date(Date.now() - 10 * 60 * 1000);\n      const { data: recentEvents, error: eventsError } = await this.supabase\n        .from('match_events')\n        .select('*')\n        .eq('match_id', matchId)\n        .gte('created_at', tenMinutesAgo.toISOString())\n        .order('created_at', { ascending: false })\n        .limit(10);\n\n      if (eventsError) throw eventsError;\n\n      // Calculate live stats\n      const liveStats = await this.calculateLiveStats(matchId);\n\n      const liveMatchData: LiveMatchData = {\n        match,\n        recentEvents: recentEvents || [],\n        liveStats: liveStats.data || {\n          homeTeamStats: {},\n          awayTeamStats: {},\n          playerStats: {}\n        }\n      };\n\n      return { data: liveMatchData, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getLiveMatchData'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get active/live matches\n   */\n  async getActiveMatches(\n    filters: { leagueId?: string; sportType?: string } = {},\n    limit = 50\n  ): Promise<ServiceResponse<ActiveMatch[]>> {\n    try {\n      const cacheKey = this.getCacheKey('getActiveMatches', { filters, limit });\n      const cached = this.getFromCache<ActiveMatch[]>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      let query = this.supabase\n        .from('active_matches')\n        .select('*')\n        .limit(limit);\n\n      if (filters.leagueId) {\n        query = query.eq('league_id', filters.leagueId);\n      }\n\n      if (filters.sportType) {\n        query = query.eq('sport_type', filters.sportType);\n      }\n\n      const { data: activeMatches, error } = await query;\n\n      if (error) throw error;\n\n      // Cache for 1 minute (short cache for live data)\n      this.setCache(cacheKey, activeMatches || [], 60);\n\n      return { data: activeMatches || [], error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getActiveMatches'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get match predictions based on team and player statistics\n   */\n  async getMatchPrediction(matchId: string): Promise<ServiceResponse<MatchPrediction>> {\n    try {\n      const cacheKey = this.getCacheKey('getMatchPrediction', { matchId });\n      const cached = this.getFromCache<MatchPrediction>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Get match details\n      const matchResponse = await this.getMatchDetails(matchId);\n      if (!matchResponse.success || !matchResponse.data) {\n        throw new Error('Match not found');\n      }\n\n      const match = matchResponse.data;\n\n      // Get team statistics\n      const [homeTeamStats, awayTeamStats] = await Promise.all([\n        this.supabase\n          .from('team_stats')\n          .select('*')\n          .eq('team_id', match.homeTeam.id)\n          .eq('league_id', match.league_id)\n          .single(),\n        this.supabase\n          .from('team_stats')\n          .select('*')\n          .eq('team_id', match.awayTeam.id)\n          .eq('league_id', match.league_id)\n          .single()\n      ]);\n\n      // Calculate prediction probabilities using simple algorithm\n      const prediction = this.calculateMatchPrediction(\n        homeTeamStats.data,\n        awayTeamStats.data,\n        match\n      );\n\n      // Cache for 24 hours\n      this.setCache(cacheKey, prediction, 86400);\n\n      return { data: prediction, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getMatchPrediction'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get player's performance metrics for a specific match\n   */\n  async getPlayerMatchPerformance(\n    matchId: string,\n    playerId: string\n  ): Promise<ServiceResponse<PlayerMatchStats>> {\n    try {\n      const cacheKey = this.getCacheKey('getPlayerMatchPerformance', { matchId, playerId });\n      const cached = this.getFromCache<PlayerMatchStats>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      const playerStats = await this.calculateMatchPlayerStats(matchId, playerId);\n      \n      if (!playerStats) {\n        return {\n          data: null,\n          error: { code: 'PLAYER_NOT_IN_MATCH', message: 'Player not found in this match', timestamp: new Date().toISOString() },\n          success: false\n        };\n      }\n\n      // Cache for 30 minutes\n      this.setCache(cacheKey, playerStats, 1800);\n\n      return { data: playerStats, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerMatchPerformance'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n  private async calculateMatchPlayerStats(matchId: string, playerId: string): Promise<PlayerMatchStats | null> {\n    // Get player profile\n    const { data: player, error: playerError } = await this.supabase\n      .from('users')\n      .select('display_name')\n      .eq('id', playerId)\n      .single();\n\n    if (playerError || !player) return null;\n\n    // Get player's events in this match\n    const { data: events, error: eventsError } = await this.supabase\n      .from('match_events')\n      .select('*')\n      .eq('match_id', matchId)\n      .eq('player_id', playerId)\n      .order('event_time', { ascending: true });\n\n    if (eventsError) return null;\n\n    // Calculate stats from events\n    const stats = (events || []).reduce(\n      (acc, event) => {\n        switch (event.event_type) {\n          case 'goal':\n            acc.goals++;\n            break;\n          case 'assist':\n            acc.assists++;\n            break;\n          case 'yellow_card':\n            acc.yellowCards++;\n            break;\n          case 'red_card':\n            acc.redCards++;\n            break;\n        }\n        return acc;\n      },\n      {\n        goals: 0,\n        assists: 0,\n        yellowCards: 0,\n        redCards: 0\n      }\n    );\n\n    // Calculate performance rating (simplified)\n    const performance = {\n      rating: Math.min(10, Math.max(1, \n        5 + (stats.goals * 2) + (stats.assists * 1.5) - (stats.yellowCards * 0.5) - (stats.redCards * 2)\n      )),\n      keyPasses: 0, // Would need more detailed event tracking\n      successfulPasses: 0,\n      totalPasses: 0,\n      tackles: 0,\n      saves: undefined\n    };\n\n    return {\n      matchId,\n      playerId,\n      playerName: player.display_name,\n      goals: stats.goals,\n      assists: stats.assists,\n      yellowCards: stats.yellowCards,\n      redCards: stats.redCards,\n      minutesPlayed: 90, // Simplified - would need substitution tracking\n      events: events || [],\n      performance\n    };\n  }\n\n  private async calculateLiveStats(matchId: string): Promise<ServiceResponse<{\n    homeTeamStats: { [key: string]: number };\n    awayTeamStats: { [key: string]: number };\n    playerStats: { [playerId: string]: any };\n  }>> {\n    try {\n      // Get all match events\n      const { data: events, error } = await this.supabase\n        .from('match_events')\n        .select('*')\n        .eq('match_id', matchId);\n\n      if (error) throw error;\n\n      const homeTeamStats: { [key: string]: number } = {};\n      const awayTeamStats: { [key: string]: number } = {};\n      const playerStats: { [playerId: string]: any } = {};\n\n      // Process events to calculate live stats\n      (events || []).forEach(event => {\n        // Team stats\n        const isHomeTeam = event.team_id === 'home'; // This would need proper team ID checking\n        const teamStats = isHomeTeam ? homeTeamStats : awayTeamStats;\n        \n        teamStats[event.event_type] = (teamStats[event.event_type] || 0) + 1;\n\n        // Player stats\n        if (event.player_id) {\n          if (!playerStats[event.player_id]) {\n            playerStats[event.player_id] = {};\n          }\n          playerStats[event.player_id][event.event_type] = \n            (playerStats[event.player_id][event.event_type] || 0) + 1;\n        }\n      });\n\n      return {\n        data: { homeTeamStats, awayTeamStats, playerStats },\n        error: null,\n        success: true\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'calculateLiveStats'),\n        success: false\n      };\n    }\n  }\n\n  private async generateMatchAnalytics(matchId: string): Promise<ServiceResponse<MatchAnalytics>> {\n    try {\n      const { data: match, error: matchError } = await this.supabase\n        .from('matches')\n        .select('*')\n        .eq('id', matchId)\n        .single();\n\n      if (matchError) throw matchError;\n\n      const { data: events, error: eventsError } = await this.supabase\n        .from('match_events')\n        .select('*')\n        .eq('match_id', matchId)\n        .order('event_time', { ascending: true });\n\n      if (eventsError) throw eventsError;\n\n      // Calculate analytics\n      const analytics: MatchAnalytics = {\n        matchId,\n        duration: match.match_duration || 90,\n        totalEvents: events?.length || 0,\n        goalsByPeriod: this.calculateGoalsByPeriod(events || []),\n        cardsByTeam: this.calculateCardsByTeam(events || []),\n        topPerformers: {\n          home: [],\n          away: []\n        },\n        matchMomentum: this.calculateMatchMomentum(events || [])\n      };\n\n      return { data: analytics, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'generateMatchAnalytics'),\n        success: false\n      };\n    }\n  }\n\n  private calculateMatchPrediction(\n    homeStats: any,\n    awayStats: any,\n    match: MatchWithDetails\n  ): MatchPrediction {\n    // Simplified prediction algorithm\n    const homeForm = homeStats ? (homeStats.wins || 0) / Math.max(homeStats.games_played || 1, 1) : 0.5;\n    const awayForm = awayStats ? (awayStats.wins || 0) / Math.max(awayStats.games_played || 1, 1) : 0.5;\n    \n    const homeAttack = homeStats ? (homeStats.goals_for || 0) / Math.max(homeStats.games_played || 1, 1) : 1;\n    const awayAttack = awayStats ? (awayStats.goals_for || 0) / Math.max(awayStats.games_played || 1, 1) : 1;\n    \n    // Simple probability calculation\n    const totalStrength = homeForm + awayForm + 0.1; // Add small constant to avoid division by zero\n    const homeWinProbability = Math.round(((homeForm + 0.1) / totalStrength) * 100);\n    const awayWinProbability = Math.round(((awayForm + 0.1) / totalStrength) * 100);\n    const drawProbability = 100 - homeWinProbability - awayWinProbability;\n\n    return {\n      matchId: match.id,\n      homeWinProbability,\n      drawProbability,\n      awayWinProbability,\n      expectedGoalsHome: Number(homeAttack.toFixed(1)),\n      expectedGoalsAway: Number(awayAttack.toFixed(1)),\n      keyFactors: [\n        `${match.homeTeam.name} home advantage`,\n        `Recent form comparison`,\n        `Head-to-head record`\n      ],\n      confidence: 75\n    };\n  }\n\n  private calculateGoalsByPeriod(events: MatchEvent[]) {\n    return events.reduce(\n      (acc, event) => {\n        if (event.event_type === 'goal' && event.event_time !== null) {\n          if (event.event_time <= 45) {\n            // Would need team determination logic\n            acc.firstHalf.home++;\n          } else if (event.event_time <= 90) {\n            acc.secondHalf.home++;\n          }\n        }\n        return acc;\n      },\n      {\n        firstHalf: { home: 0, away: 0 },\n        secondHalf: { home: 0, away: 0 }\n      }\n    );\n  }\n\n  private calculateCardsByTeam(events: MatchEvent[]) {\n    return {\n      home: { yellow: 0, red: 0 },\n      away: { yellow: 0, red: 0 }\n    };\n  }\n\n  private calculateMatchMomentum(events: MatchEvent[]) {\n    return events.map((event, index) => ({\n      minute: event.event_time || 0,\n      homeScore: 0, // Would need proper score tracking\n      awayScore: 0,\n      eventType: event.event_type as EventType,\n      momentum: 0 // Would need momentum calculation algorithm\n    }));\n  }\n\n  /**\n   * Subscribe to real-time match updates\n   */\n  subscribeToMatchUpdates(\n    matchId: string,\n    callback: (payload: any) => void,\n    options: RealtimeSubscriptionOptions = { table: 'match_events', event: '*' }\n  ) {\n    return this.supabase\n      .channel(`match-${matchId}-updates`)\n      .on(\n        'postgres_changes',\n        {\n          event: options.event,\n          schema: options.schema || 'public',\n          table: options.table,\n          filter: options.filter || `match_id=eq.${matchId}`\n        },\n        callback\n      )\n      .subscribe();\n  }\n\n  /**\n   * Create a new match between two teams\n   */\n  async createMatch(data: {\n    homeTeamId: string;\n    awayTeamId: string;\n    matchDate: string;\n    venue?: string;\n    leagueId?: string;\n    matchType?: 'friendly' | 'league' | 'tournament' | 'regular_season';\n  }): Promise<ServiceResponse<any>> {\n    try {\n      console.log('üèüÔ∏è MatchService.createMatch:', data);\n\n      // Validate teams exist and are different\n      const { data: teams, error: teamsError } = await this.supabase\n        .from('teams')\n        .select('id, name')\n        .in('id', [data.homeTeamId, data.awayTeamId]);\n\n      if (teamsError) throw teamsError;\n\n      if (!teams || teams.length !== 2) {\n        return {\n          data: null,\n          error: { code: 'INVALID_TEAMS', message: 'One or both teams do not exist', timestamp: new Date().toISOString() },\n          success: false\n        };\n      }\n\n      // Create the match\n      const { data: match, error: matchError } = await this.supabase\n        .from('matches')\n        .insert({\n          home_team_id: data.homeTeamId,\n          away_team_id: data.awayTeamId,\n          match_date: data.matchDate,\n          scheduled_date: data.matchDate,\n          venue: data.venue || 'TBD',\n          league_id: data.leagueId || null,\n          match_type: data.matchType || 'friendly',\n          status: 'scheduled'\n        })\n        .select(`\n          *,\n          home_team:teams!matches_home_team_id_fkey(*),\n          away_team:teams!matches_away_team_id_fkey(*),\n          league:leagues(*)\n        `)\n        .single();\n\n      if (matchError) throw matchError;\n\n      // Clear cache\n      this.clearCache('getPlayerMatches');\n      this.clearCache('getActiveMatches');\n\n      return { data: match, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'createMatch'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Update match score and status\n   */\n  async updateMatchScore(\n    matchId: string, \n    data: {\n      homeScore: number;\n      awayScore: number;\n      status?: MatchStatus;\n      duration?: number;\n      notes?: string;\n    }\n  ): Promise<ServiceResponse<any>> {\n    try {\n      console.log('‚öΩ MatchService.updateMatchScore:', matchId, data);\n\n      const updateData: any = {\n        home_score: data.homeScore,\n        away_score: data.awayScore,\n        updated_at: new Date().toISOString()\n      };\n\n      if (data.status) {\n        updateData.status = data.status;\n      }\n\n      if (data.duration !== undefined) {\n        updateData.match_duration = data.duration;\n      }\n\n      if (data.notes !== undefined) {\n        updateData.notes = data.notes;\n      }\n\n      const { data: match, error: updateError } = await this.supabase\n        .from('matches')\n        .update(updateData)\n        .eq('id', matchId)\n        .select(`\n          *,\n          home_team:teams!matches_home_team_id_fkey(*),\n          away_team:teams!matches_away_team_id_fkey(*),\n          league:leagues(*)\n        `)\n        .single();\n\n      if (updateError) throw updateError;\n\n      // Clear cache\n      this.clearCache('getPlayerMatches');\n      this.clearCache('getMatchDetails');\n      this.clearCache('getActiveMatches');\n\n      return { data: match, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'updateMatchScore'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get match participants\n   */\n  async getMatchParticipants(matchId: string): Promise<ServiceResponse<{\n    homeTeam: { id: string; name: string; participants: any[] };\n    awayTeam: { id: string; name: string; participants: any[] };\n  }>> {\n    try {\n      console.log('üë• MatchService.getMatchParticipants:', matchId);\n\n      const cacheKey = this.getCacheKey('getMatchParticipants', { matchId });\n      const cached = this.getFromCache<any>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Get match details\n      const { data: match, error: matchError } = await this.supabase\n        .from('matches')\n        .select(`\n          id,\n          home_team_id,\n          away_team_id,\n          home_team:teams!matches_home_team_id_fkey(id, name, team_color),\n          away_team:teams!matches_away_team_id_fkey(id, name, team_color)\n        `)\n        .eq('id', matchId)\n        .single();\n\n      if (matchError) throw matchError;\n\n      // Get participants\n      const { data: participants, error: participantsError } = await this.supabase\n        .from('match_participants')\n        .select(`\n          *,\n          user:user_profiles(id, display_name, full_name, avatar_url, preferred_position)\n        `)\n        .eq('match_id', matchId)\n        .order('jersey_number', { ascending: true });\n\n      if (participantsError) throw participantsError;\n\n      // Group by team\n      const homeParticipants = participants?.filter(p => p.team_id === match.home_team_id) || [];\n      const awayParticipants = participants?.filter(p => p.team_id === match.away_team_id) || [];\n\n      const result = {\n        homeTeam: {\n          ...match.home_team,\n          participants: homeParticipants.map(p => ({\n            id: p.id,\n            userId: p.user_id,\n            position: p.position,\n            jerseyNumber: p.jersey_number,\n            isStarter: p.is_starter,\n            isCaptain: p.is_captain,\n            selectedAt: p.selected_at,\n            player: p.user\n          }))\n        },\n        awayTeam: {\n          ...match.away_team,\n          participants: awayParticipants.map(p => ({\n            id: p.id,\n            userId: p.user_id,\n            position: p.position,\n            jerseyNumber: p.jersey_number,\n            isStarter: p.is_starter,\n            isCaptain: p.is_captain,\n            selectedAt: p.selected_at,\n            player: p.user\n          }))\n        }\n      };\n\n      // Cache for 5 minutes\n      this.setCache(cacheKey, result, 300);\n\n      return { data: result, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getMatchParticipants'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Add participant to match\n   */\n  async addMatchParticipant(data: {\n    matchId: string;\n    teamId: string;\n    userId: string;\n    position?: string;\n    jerseyNumber?: number;\n    isStarter?: boolean;\n    isCaptain?: boolean;\n  }): Promise<ServiceResponse<any>> {\n    try {\n      console.log('‚ûï MatchService.addMatchParticipant:', data);\n\n      const { data: participant, error } = await this.supabase\n        .from('match_participants')\n        .upsert({\n          match_id: data.matchId,\n          team_id: data.teamId,\n          user_id: data.userId,\n          position: data.position || null,\n          jersey_number: data.jerseyNumber || null,\n          is_starter: data.isStarter || false,\n          is_captain: data.isCaptain || false\n        }, {\n          onConflict: 'match_id,user_id'\n        })\n        .select(`\n          *,\n          user:user_profiles(id, display_name, full_name)\n        `)\n        .single();\n\n      if (error) throw error;\n\n      // Clear cache\n      this.clearCache('getMatchParticipants');\n\n      return { data: participant, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'addMatchParticipant'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Remove participant from match\n   */\n  async removeMatchParticipant(participantId: string): Promise<ServiceResponse<void>> {\n    try {\n      console.log('üóëÔ∏è MatchService.removeMatchParticipant:', participantId);\n\n      const { error } = await this.supabase\n        .from('match_participants')\n        .delete()\n        .eq('id', participantId);\n\n      if (error) throw error;\n\n      // Clear cache\n      this.clearCache('getMatchParticipants');\n\n      return { data: null, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'removeMatchParticipant'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Clear cache\n   */\n  clearCache(pattern?: string): void {\n    if (!pattern) {\n      this.cache.clear();\n      return;\n    }\n\n    const keys = Array.from(this.cache.keys());\n    keys.forEach(key => {\n      if (key.includes(pattern)) {\n        this.cache.delete(key);\n      }\n    });\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 2746, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/season.service.ts"],"sourcesContent":["/**\n * Season Service for MatchDay\n * \n * Handles season management operations including:\n * - Season creation and management\n * - Team registration for seasons\n * - Match scheduling and fixture generation\n * - Season statistics and standings\n */\n\nimport { SupabaseClient } from '@supabase/supabase-js';\n\nexport interface Season {\n  id: string;\n  name: string;\n  league_id: string;\n  season_year: number;\n  display_name?: string;\n  status: 'draft' | 'registration' | 'active' | 'completed' | 'cancelled';\n  tournament_format: 'league' | 'knockout' | 'hybrid';\n  start_date: string;\n  end_date: string;\n  registration_deadline?: string;\n  match_frequency?: number;\n  preferred_match_time?: string;\n  min_teams?: number;\n  max_teams?: number;\n  registered_teams_count?: number;\n  rounds?: number;\n  points_for_win?: number;\n  points_for_draw?: number;\n  points_for_loss?: number;\n  allow_draws?: boolean;\n  home_away_balance?: boolean;\n  fixtures_status: 'pending' | 'generating' | 'completed' | 'error';\n  fixtures_generated_at?: string;\n  total_matches_planned?: number;\n  rules?: any;\n  settings?: any;\n  metadata?: any;\n  created_at: string;\n  updated_at: string;\n  created_by?: string;\n  updated_by?: string;\n}\n\nexport interface SeasonTeam {\n  id: string;\n  season_id: string;\n  team_id: string;\n  registration_date: string;\n  status: 'registered' | 'confirmed' | 'withdrawn';\n  team?: {\n    id: string;\n    name: string;\n    team_color?: string;\n    captain_id?: string;\n  };\n}\n\nexport interface Match {\n  id: string;\n  season_id: string;\n  home_team_id: string;\n  away_team_id: string;\n  match_date?: string;\n  round_number?: number;\n  status: 'scheduled' | 'in_progress' | 'completed' | 'cancelled';\n  home_score?: number;\n  away_score?: number;\n  venue?: string;\n  home_team?: {\n    id: string;\n    name: string;\n    team_color?: string;\n  };\n  away_team?: {\n    id: string;\n    name: string;\n    team_color?: string;\n  };\n}\n\nexport interface ServiceResponse<T> {\n  data: T | null;\n  error: any | null;\n  success: boolean;\n  message?: string;\n}\n\nexport class SeasonService {\n  private static instance: SeasonService;\n  private supabase: SupabaseClient;\n\n  private constructor(supabaseClient: SupabaseClient) {\n    this.supabase = supabaseClient;\n  }\n\n  static getInstance(supabaseClient?: SupabaseClient): SeasonService {\n    if (!SeasonService.instance) {\n      if (!supabaseClient) {\n        throw new Error('SupabaseClient required for first initialization');\n      }\n      SeasonService.instance = new SeasonService(supabaseClient);\n    }\n    return SeasonService.instance;\n  }\n\n  /**\n   * Get all seasons for a league\n   */\n  async getSeasonsByLeague(leagueId: string): Promise<ServiceResponse<Season[]>> {\n    try {\n      const { data: seasons, error } = await this.supabase\n        .from('seasons')\n        .select('*')\n        .eq('league_id', leagueId)\n        .order('season_year', { ascending: false });\n\n      if (error) throw error;\n\n      return {\n        data: seasons || [],\n        error: null,\n        success: true,\n        message: 'Seasons retrieved successfully'\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error,\n        success: false,\n        message: 'Failed to get seasons'\n      };\n    }\n  }\n\n  /**\n   * Get season details with teams\n   */\n  async getSeasonDetails(seasonId: string): Promise<ServiceResponse<Season & { teams?: SeasonTeam[] }>> {\n    try {\n      const { data: season, error } = await this.supabase\n        .from('seasons')\n        .select(`\n          *,\n          season_teams (\n            id,\n            team_id,\n            registration_date,\n            status,\n            team:teams (\n              id,\n              name,\n              team_color,\n              captain_id\n            )\n          )\n        `)\n        .eq('id', seasonId)\n        .single();\n\n      if (error) {\n        if (error.code === 'PGRST116') {\n          return {\n            data: null,\n            error: { code: 'SEASON_NOT_FOUND', message: 'Season not found' },\n            success: false\n          };\n        }\n        throw error;\n      }\n\n      return {\n        data: {\n          ...season,\n          teams: season.season_teams || []\n        },\n        error: null,\n        success: true,\n        message: 'Season details retrieved successfully'\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error,\n        success: false,\n        message: 'Failed to get season details'\n      };\n    }\n  }\n\n  /**\n   * Create a new season\n   */\n  async createSeason(seasonData: Partial<Season>): Promise<ServiceResponse<Season>> {\n    try {\n      const { data: season, error } = await this.supabase\n        .from('seasons')\n        .insert([{\n          name: seasonData.name,\n          league_id: seasonData.league_id,\n          season_year: seasonData.season_year || new Date().getFullYear(),\n          display_name: seasonData.display_name || seasonData.name,\n          status: seasonData.status || 'draft',\n          tournament_format: seasonData.tournament_format || 'league',\n          start_date: seasonData.start_date,\n          end_date: seasonData.end_date,\n          registration_deadline: seasonData.registration_deadline,\n          match_frequency: seasonData.match_frequency || 7,\n          preferred_match_time: seasonData.preferred_match_time || '15:00:00',\n          min_teams: seasonData.min_teams || 2,\n          max_teams: seasonData.max_teams,\n          rounds: seasonData.rounds || 1,\n          points_for_win: seasonData.points_for_win || 3,\n          points_for_draw: seasonData.points_for_draw || 1,\n          points_for_loss: seasonData.points_for_loss || 0,\n          allow_draws: seasonData.allow_draws !== false,\n          home_away_balance: seasonData.home_away_balance !== false,\n          rules: seasonData.rules || {},\n          settings: seasonData.settings || {},\n          metadata: seasonData.metadata || {}\n        }])\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      return {\n        data: season,\n        error: null,\n        success: true,\n        message: 'Season created successfully'\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error,\n        success: false,\n        message: 'Failed to create season'\n      };\n    }\n  }\n\n  /**\n   * Update season\n   */\n  async updateSeason(seasonId: string, updates: Partial<Season>): Promise<ServiceResponse<Season>> {\n    try {\n      const { data: season, error } = await this.supabase\n        .from('seasons')\n        .update({\n          ...updates,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', seasonId)\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      return {\n        data: season,\n        error: null,\n        success: true,\n        message: 'Season updated successfully'\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error,\n        success: false,\n        message: 'Failed to update season'\n      };\n    }\n  }\n\n  /**\n   * Register team for season\n   */\n  async registerTeamForSeason(seasonId: string, teamId: string): Promise<ServiceResponse<SeasonTeam>> {\n    try {\n      // Check if team is already registered\n      const { data: existing, error: checkError } = await this.supabase\n        .from('season_teams')\n        .select('id')\n        .eq('season_id', seasonId)\n        .eq('team_id', teamId)\n        .single();\n\n      if (checkError && checkError.code !== 'PGRST116') throw checkError;\n\n      if (existing) {\n        return {\n          data: null,\n          error: { code: 'ALREADY_REGISTERED', message: 'Team is already registered for this season' },\n          success: false\n        };\n      }\n\n      // Register the team\n      const { data: registration, error } = await this.supabase\n        .from('season_teams')\n        .insert([{\n          season_id: seasonId,\n          team_id: teamId,\n          registration_date: new Date().toISOString(),\n          status: 'registered'\n        }])\n        .select(`\n          *,\n          team:teams (\n            id,\n            name,\n            team_color,\n            captain_id\n          )\n        `)\n        .single();\n\n      if (error) throw error;\n\n      // Update registered teams count\n      await this.updateRegisteredTeamsCount(seasonId);\n\n      return {\n        data: registration,\n        error: null,\n        success: true,\n        message: 'Team registered for season successfully'\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error,\n        success: false,\n        message: 'Failed to register team for season'\n      };\n    }\n  }\n\n  /**\n   * Generate round-robin fixtures for a season\n   */\n  async generateFixtures(seasonId: string): Promise<ServiceResponse<Match[]>> {\n    try {\n      // Get season details\n      const seasonResponse = await this.getSeasonDetails(seasonId);\n      if (!seasonResponse.success || !seasonResponse.data) {\n        throw new Error('Season not found');\n      }\n\n      const season = seasonResponse.data;\n      const teams = season.teams?.filter(t => t.status === 'registered' || t.status === 'confirmed') || [];\n\n      if (teams.length < 2) {\n        return {\n          data: null,\n          error: { code: 'INSUFFICIENT_TEAMS', message: 'Need at least 2 teams to generate fixtures' },\n          success: false\n        };\n      }\n\n      // Update fixtures status to generating\n      await this.updateSeason(seasonId, { \n        fixtures_status: 'generating',\n        total_matches_planned: this.calculateTotalMatches(teams.length, season.rounds || 1, season.home_away_balance || false)\n      });\n\n      // Generate round-robin fixtures\n      const fixtures = this.generateRoundRobinFixtures(teams, season.rounds || 1, season.home_away_balance || false);\n      \n      // Calculate match dates based on season start date and frequency\n      const fixturesWithDates = this.assignMatchDates(fixtures, season);\n\n      // Clear existing fixtures for this season\n      await this.supabase\n        .from('matches')\n        .delete()\n        .eq('season_id', seasonId);\n\n      // Insert new fixtures\n      const { data: matches, error } = await this.supabase\n        .from('matches')\n        .insert(fixturesWithDates.map(fixture => ({\n          season_id: seasonId,\n          home_team_id: fixture.home_team_id,\n          away_team_id: fixture.away_team_id,\n          match_date: fixture.match_date,\n          status: 'scheduled'\n        })))\n        .select(`\n          *,\n          home_team:teams!matches_home_team_id_fkey (\n            id,\n            name,\n            team_color\n          ),\n          away_team:teams!matches_away_team_id_fkey (\n            id,\n            name,\n            team_color\n          )\n        `);\n\n      if (error) throw error;\n\n      // Update fixtures status to completed\n      await this.updateSeason(seasonId, { \n        fixtures_status: 'completed',\n        fixtures_generated_at: new Date().toISOString()\n      });\n\n      return {\n        data: matches || [],\n        error: null,\n        success: true,\n        message: 'Fixtures generated successfully'\n      };\n    } catch (error) {\n      // Update fixtures status to error\n      await this.updateSeason(seasonId, { \n        fixtures_status: 'error',\n        fixtures_generation_error: error instanceof Error ? error.message : 'Unknown error'\n      });\n\n      return {\n        data: null,\n        error,\n        success: false,\n        message: 'Failed to generate fixtures'\n      };\n    }\n  }\n\n  /**\n   * Get matches for a season\n   */\n  async getSeasonMatches(seasonId: string): Promise<ServiceResponse<Match[]>> {\n    try {\n      const { data: matches, error } = await this.supabase\n        .from('matches')\n        .select(`\n          *,\n          home_team:teams!matches_home_team_id_fkey (\n            id,\n            name,\n            team_color\n          ),\n          away_team:teams!matches_away_team_id_fkey (\n            id,\n            name,\n            team_color\n          )\n        `)\n        .eq('season_id', seasonId)\n        .order('match_date', { ascending: true });\n\n      if (error) throw error;\n\n      return {\n        data: matches || [],\n        error: null,\n        success: true,\n        message: 'Season matches retrieved successfully'\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error,\n        success: false,\n        message: 'Failed to get season matches'\n      };\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n  private async updateRegisteredTeamsCount(seasonId: string): Promise<void> {\n    const { count } = await this.supabase\n      .from('season_teams')\n      .select('*', { count: 'exact', head: true })\n      .eq('season_id', seasonId)\n      .in('status', ['registered', 'confirmed']);\n\n    await this.supabase\n      .from('seasons')\n      .update({ registered_teams_count: count || 0 })\n      .eq('id', seasonId);\n  }\n\n  private calculateTotalMatches(teamsCount: number, rounds: number, homeAndAway: boolean): number {\n    const matchesPerRound = (teamsCount * (teamsCount - 1)) / 2;\n    const multiplier = homeAndAway ? 2 : 1;\n    return matchesPerRound * rounds * multiplier;\n  }\n\n  private generateRoundRobinFixtures(teams: SeasonTeam[], rounds: number, homeAndAway: boolean): Array<{\n    home_team_id: string;\n    away_team_id: string;\n    round_number: number;\n  }> {\n    const fixtures: Array<{\n      home_team_id: string;\n      away_team_id: string;\n      round_number: number;\n    }> = [];\n\n    for (let round = 1; round <= rounds; round++) {\n      // Generate all possible pairings\n      for (let i = 0; i < teams.length; i++) {\n        for (let j = i + 1; j < teams.length; j++) {\n          fixtures.push({\n            home_team_id: teams[i].team_id,\n            away_team_id: teams[j].team_id,\n            round_number: round\n          });\n\n          // Add reverse fixture if home and away\n          if (homeAndAway) {\n            fixtures.push({\n              home_team_id: teams[j].team_id,\n              away_team_id: teams[i].team_id,\n              round_number: round\n            });\n          }\n        }\n      }\n    }\n\n    return fixtures;\n  }\n\n  private assignMatchDates(fixtures: Array<{\n    home_team_id: string;\n    away_team_id: string;\n    round_number: number;\n  }>, season: Season): Array<{\n    home_team_id: string;\n    away_team_id: string;\n    round_number: number;\n    match_date: string;\n  }> {\n    const startDate = new Date(season.start_date);\n    const matchFrequencyDays = season.match_frequency || 7;\n    const preferredTime = season.preferred_match_time || '15:00:00';\n\n    return fixtures.map((fixture, index) => {\n      const dayOffset = Math.floor(index / 2) * matchFrequencyDays; // 2 matches per day\n      const matchDate = new Date(startDate);\n      matchDate.setDate(matchDate.getDate() + dayOffset);\n      \n      return {\n        ...fixture,\n        match_date: `${matchDate.toISOString().split('T')[0]}T${preferredTime}Z`\n      };\n    });\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3104, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/player.service.ts"],"sourcesContent":["/**\n * Enhanced Player Service for MatchDay\n * \n * Handles comprehensive player-related operations with focus on:\n * - Player profiles and cross-league statistics\n * - Achievement tracking and progress\n * - Performance analytics and rankings\n * - Team memberships and join requests\n * \n * Optimized for amateur sports leagues with proper error handling,\n * caching strategies, and real-time updates.\n */\n\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport { \n  Database, \n  UserProfile, \n  PlayerStats, \n  PlayerProfileExtended, \n  PlayerCrossLeagueStats,\n  ServiceResponse,\n  ServiceError,\n  PaginatedServiceResponse,\n  TeamJoinRequest,\n  JoinRequestStatus,\n  Achievement,\n  UserAchievement,\n  CacheOptions,\n  RealtimeSubscriptionOptions\n} from '@/lib/types/database.types';\n\nexport class PlayerService {\n  private static instance: PlayerService;\n  private supabase: SupabaseClient<Database>;\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n\n  private constructor(supabaseClient: SupabaseClient<Database>) {\n    this.supabase = supabaseClient;\n  }\n\n  static getInstance(supabaseClient?: SupabaseClient<Database>): PlayerService {\n    if (!PlayerService.instance) {\n      if (!supabaseClient) {\n        throw new Error('SupabaseClient required for first initialization');\n      }\n      PlayerService.instance = new PlayerService(supabaseClient);\n    }\n    return PlayerService.instance;\n  }\n\n  /**\n   * Handle service errors consistently\n   */\n  private handleError(error: any, operation: string): ServiceError {\n    console.error(`PlayerService.${operation}:`, error);\n    return {\n      code: error.code || 'UNKNOWN_ERROR',\n      message: error.message || 'An unexpected error occurred',\n      details: error.details || error,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Cache management utilities\n   */\n  private getCacheKey(operation: string, params: any): string {\n    return `player_service:${operation}:${JSON.stringify(params)}`;\n  }\n\n  private getFromCache<T>(key: string): T | null {\n    const cached = this.cache.get(key);\n    if (!cached) return null;\n    \n    if (Date.now() - cached.timestamp > cached.ttl * 1000) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return cached.data as T;\n  }\n\n  private setCache<T>(key: string, data: T, ttl = 300): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl\n    });\n  }\n\n  /**\n   * Get comprehensive player profile with all related data\n   */\n  async getPlayerProfile(userId: string, options: CacheOptions = {}): Promise<ServiceResponse<PlayerProfileExtended>> {\n    try {\n      const cacheKey = this.getCacheKey('getPlayerProfile', { userId });\n      const cached = this.getFromCache<PlayerProfileExtended>(cacheKey);\n      \n      if (cached && !options.revalidateOnBackground) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Get basic profile\n      const { data: profile, error: profileError } = await this.supabase\n        .from('users')\n        .select('*')\n        .eq('id', userId)\n        .single();\n\n      if (profileError) {\n        if (profileError.code === 'PGRST116') {\n          return { \n            data: null, \n            error: { code: 'PLAYER_NOT_FOUND', message: 'Player not found', timestamp: new Date().toISOString() }, \n            success: false \n          };\n        }\n        throw profileError;\n      }\n\n      // Get team memberships with league details\n      const { data: teamMemberships, error: teamsError } = await this.supabase\n        .from('team_members')\n        .select(`\n          *,\n          team:teams!inner(\n            *,\n            league:leagues!inner(*)\n          )\n        `)\n        .eq('user_id', userId)\n        .eq('is_active', true);\n\n      if (teamsError) throw teamsError;\n\n      // Get achievements\n      const { data: userAchievements, error: achievementsError } = await this.supabase\n        .from('user_achievements')\n        .select(`\n          *,\n          achievement:achievements!inner(*)\n        `)\n        .eq('user_id', userId)\n        .order('earned_at', { ascending: false });\n\n      if (achievementsError) throw achievementsError;\n\n      // Get cross-league stats\n      const { data: crossLeagueStats, error: crossStatsError } = await this.supabase\n        .from('player_cross_league_stats')\n        .select('*')\n        .eq('player_id', userId)\n        .eq('season_year', new Date().getFullYear())\n        .single();\n\n      // Don't throw error if no cross-league stats exist\n      if (crossStatsError && crossStatsError.code !== 'PGRST116') {\n        throw crossStatsError;\n      }\n\n      // Get global rankings\n      const globalRankings = await this.getPlayerGlobalRankings(userId);\n\n      const playerProfile: PlayerProfileExtended = {\n        ...profile,\n        teams: teamMemberships?.map(tm => ({\n          team: tm.team as any,\n          membership: tm\n        })) || [],\n        achievements: userAchievements?.map(ua => ({\n          achievement: ua.achievement as Achievement,\n          userAchievement: ua\n        })) || [],\n        crossLeagueStats: crossLeagueStats || null,\n        globalRankings: globalRankings.data || {\n          goals: null,\n          assists: null,\n          matches: null\n        }\n      };\n\n      // Cache the result\n      this.setCache(cacheKey, playerProfile, options.ttl || 300);\n\n      return { data: playerProfile, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerProfile'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Update player profile information\n   */\n  async updatePlayerProfile(\n    userId: string, \n    updates: Partial<Database['public']['Tables']['user_profiles']['Update']>\n  ): Promise<ServiceResponse<UserProfile>> {\n    try {\n      const { data, error } = await this.supabase\n        .from('users')\n        .update({\n          ...updates,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', userId)\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      // Invalidate cache\n      const cacheKey = this.getCacheKey('getPlayerProfile', { userId });\n      this.cache.delete(cacheKey);\n\n      return { data, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'updatePlayerProfile'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get player's cross-league statistics aggregation\n   */\n  async getCrossLeagueStats(userId: string, seasonYear?: number): Promise<ServiceResponse<PlayerCrossLeagueStats>> {\n    try {\n      const year = seasonYear || new Date().getFullYear();\n      const cacheKey = this.getCacheKey('getCrossLeagueStats', { userId, year });\n      const cached = this.getFromCache<PlayerCrossLeagueStats>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      const { data, error } = await this.supabase\n        .from('player_cross_league_stats')\n        .select('*')\n        .eq('player_id', userId)\n        .eq('season_year', year)\n        .single();\n\n      if (error && error.code !== 'PGRST116') throw error;\n\n      // Cache for 10 minutes\n      this.setCache(cacheKey, data, 600);\n\n      return { data: data || null, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getCrossLeagueStats'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get player's global rankings across different stats\n   */\n  async getPlayerGlobalRankings(userId: string): Promise<ServiceResponse<{\n    goals: { rank: number; total: number; percentile: number } | null;\n    assists: { rank: number; total: number; percentile: number } | null;\n    matches: { rank: number; total: number; percentile: number } | null;\n  }>> {\n    try {\n      const cacheKey = this.getCacheKey('getPlayerGlobalRankings', { userId });\n      const cached = this.getFromCache<any>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Get rankings for different stats using stored procedures\n      const [goalsRank, assistsRank, matchesRank] = await Promise.allSettled([\n        this.supabase.rpc('get_player_global_rank', { \n          player_id: userId, \n          stat_column: 'total_goals' \n        }),\n        this.supabase.rpc('get_player_global_rank', { \n          player_id: userId, \n          stat_column: 'total_assists' \n        }),\n        this.supabase.rpc('get_player_global_rank', { \n          player_id: userId, \n          stat_column: 'total_games_played' \n        })\n      ]);\n\n      const rankings = {\n        goals: goalsRank.status === 'fulfilled' && goalsRank.value.data ? {\n          rank: goalsRank.value.data.rank,\n          total: goalsRank.value.data.total_players,\n          percentile: Math.round((1 - (goalsRank.value.data.rank / goalsRank.value.data.total_players)) * 100)\n        } : null,\n        assists: assistsRank.status === 'fulfilled' && assistsRank.value.data ? {\n          rank: assistsRank.value.data.rank,\n          total: assistsRank.value.data.total_players,\n          percentile: Math.round((1 - (assistsRank.value.data.rank / assistsRank.value.data.total_players)) * 100)\n        } : null,\n        matches: matchesRank.status === 'fulfilled' && matchesRank.value.data ? {\n          rank: matchesRank.value.data.rank,\n          total: matchesRank.value.data.total_players,\n          percentile: Math.round((1 - (matchesRank.value.data.rank / matchesRank.value.data.total_players)) * 100)\n        } : null\n      };\n\n      // Cache for 30 minutes\n      this.setCache(cacheKey, rankings, 1800);\n\n      return { data: rankings, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerGlobalRankings'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get player's achievements with progress tracking\n   */\n  async getPlayerAchievements(userId: string, options: {\n    category?: string;\n    completed?: boolean;\n    limit?: number;\n    offset?: number;\n  } = {}): Promise<PaginatedServiceResponse<{\n    achievement: Achievement;\n    userAchievement: UserAchievement | null;\n    progress?: {\n      current: number;\n      target: number;\n      percentage: number;\n    };\n  }>> {\n    try {\n      let query = this.supabase\n        .from('achievements')\n        .select(`\n          *,\n          user_achievements!left(*)\n        `)\n        .eq('is_active', true);\n\n      if (options.category) {\n        query = query.eq('category', options.category);\n      }\n\n      if (options.completed !== undefined) {\n        if (options.completed) {\n          query = query.not('user_achievements', 'is', null);\n        } else {\n          query = query.is('user_achievements', null);\n        }\n      }\n\n      const { data: achievements, error, count } = await query\n        .order('sort_order')\n        .range(options.offset || 0, (options.offset || 0) + (options.limit || 50) - 1);\n\n      if (error) throw error;\n\n      // Get current player stats for progress calculation\n      const playerStats = await this.getCrossLeagueStats(userId);\n      const stats = playerStats.data;\n\n      const achievementData = achievements?.map(achievement => {\n        const userAchievement = achievement.user_achievements?.find(\n          (ua: any) => ua.user_id === userId\n        );\n\n        // Calculate progress if not completed\n        let progress;\n        if (!userAchievement && stats) {\n          const requirements = achievement.requirements as any;\n          let current = 0;\n          let target = 0;\n\n          if (requirements.goals) {\n            current = stats.total_goals || 0;\n            target = requirements.goals;\n          } else if (requirements.assists) {\n            current = stats.total_assists || 0;\n            target = requirements.assists;\n          } else if (requirements.matches_played) {\n            current = stats.total_games_played || 0;\n            target = requirements.matches_played;\n          }\n\n          if (target > 0) {\n            progress = {\n              current,\n              target,\n              percentage: Math.min(100, Math.round((current / target) * 100))\n            };\n          }\n        }\n\n        return {\n          achievement,\n          userAchievement: userAchievement || null,\n          progress\n        };\n      }) || [];\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 50)) + 1,\n        limit: options.limit || 50,\n        total: count || 0,\n        totalPages: Math.ceil((count || 0) / (options.limit || 50)),\n        hasNext: ((options.offset || 0) + (options.limit || 50)) < (count || 0),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: achievementData,\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerAchievements'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get player's team join requests\n   */\n  async getTeamJoinRequests(\n    userId: string,\n    options: { status?: JoinRequestStatus; limit?: number } = {}\n  ): Promise<ServiceResponse<Array<TeamJoinRequest & {\n    team: Database['public']['Tables']['teams']['Row'];\n    league: Database['public']['Tables']['leagues']['Row'];\n  }>>> {\n    try {\n      let query = this.supabase\n        .from('team_join_requests')\n        .select(`\n          *,\n          team:teams!inner(\n            *,\n            league:leagues!inner(*)\n          )\n        `)\n        .eq('user_id', userId);\n\n      if (options.status) {\n        query = query.eq('status', options.status);\n      }\n\n      const { data, error } = await query\n        .order('created_at', { ascending: false })\n        .limit(options.limit || 50);\n\n      if (error) throw error;\n\n      return { data: data || [], error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getTeamJoinRequests'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Submit a team join request\n   */\n  async submitTeamJoinRequest(\n    userId: string,\n    teamId: string,\n    options: {\n      message?: string;\n      preferredPosition?: string;\n      requestedJerseyNumber?: number;\n    } = {}\n  ): Promise<ServiceResponse<TeamJoinRequest>> {\n    try {\n      // Check if user already has a pending request for this team\n      const { data: existing, error: checkError } = await this.supabase\n        .from('team_join_requests')\n        .select('id')\n        .eq('user_id', userId)\n        .eq('team_id', teamId)\n        .eq('status', 'pending')\n        .single();\n\n      if (checkError && checkError.code !== 'PGRST116') throw checkError;\n\n      if (existing) {\n        return {\n          data: null,\n          error: {\n            code: 'DUPLICATE_REQUEST',\n            message: 'You already have a pending request for this team',\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      const { data, error } = await this.supabase\n        .from('team_join_requests')\n        .insert({\n          user_id: userId,\n          team_id: teamId,\n          message: options.message,\n          preferred_position: options.preferredPosition,\n          requested_jersey_number: options.requestedJerseyNumber,\n          status: 'pending',\n          expires_at: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString() // 30 days\n        })\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      return { data, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'submitTeamJoinRequest'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Withdraw a team join request\n   */\n  async withdrawTeamJoinRequest(userId: string, requestId: string): Promise<ServiceResponse<boolean>> {\n    try {\n      const { data, error } = await this.supabase\n        .from('team_join_requests')\n        .update({ status: 'withdrawn' })\n        .eq('id', requestId)\n        .eq('user_id', userId)\n        .eq('status', 'pending')\n        .select()\n        .single();\n\n      if (error) throw error;\n\n      return { data: true, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'withdrawTeamJoinRequest'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Search for players across leagues\n   */\n  async searchPlayers(options: {\n    query?: string;\n    leagueId?: string;\n    sportType?: string;\n    minGames?: number;\n    limit?: number;\n    offset?: number;\n  } = {}): Promise<PaginatedServiceResponse<PlayerCrossLeagueStats>> {\n    try {\n      let query = this.supabase\n        .from('player_cross_league_stats')\n        .select('*', { count: 'exact' })\n        .eq('season_year', new Date().getFullYear());\n\n      if (options.query) {\n        query = query.ilike('display_name', `%${options.query}%`);\n      }\n\n      if (options.minGames) {\n        query = query.gte('total_games_played', options.minGames);\n      }\n\n      const { data, error, count } = await query\n        .order('total_goals', { ascending: false })\n        .range(options.offset || 0, (options.offset || 0) + (options.limit || 20) - 1);\n\n      if (error) throw error;\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n        limit: options.limit || 20,\n        total: count || 0,\n        totalPages: Math.ceil((count || 0) / (options.limit || 20)),\n        hasNext: ((options.offset || 0) + (options.limit || 20)) < (count || 0),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: data || [],\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'searchPlayers'),\n        success: false,\n        pagination: {\n          page: 1,\n          limit: options.limit || 20,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrevious: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Subscribe to real-time updates for player data\n   */\n  subscribeToPlayerUpdates(\n    userId: string,\n    callback: (payload: any) => void,\n    options: RealtimeSubscriptionOptions = { table: 'user_profiles', event: '*' }\n  ) {\n    return this.supabase\n      .channel(`player-${userId}-updates`)\n      .on(\n        'postgres_changes',\n        {\n          event: options.event,\n          schema: options.schema || 'public',\n          table: options.table,\n          filter: options.filter || `id=eq.${userId}`\n        },\n        callback\n      )\n      .subscribe();\n  }\n\n  /**\n   * Clear cache for specific operations or all cache\n   */\n  clearCache(pattern?: string): void {\n    if (!pattern) {\n      this.cache.clear();\n      return;\n    }\n\n    const keys = Array.from(this.cache.keys());\n    keys.forEach(key => {\n      if (key.includes(pattern)) {\n        this.cache.delete(key);\n      }\n    });\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3623, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/user.service.ts"],"sourcesContent":["/**\n * User Service for MatchDay\n * \n * Handles user profile operations with Supabase integration.\n * Provides CRUD operations for user profiles and related data.\n */\n\nimport { supabase } from '@/lib/supabase/client';\nimport type { UserProfile, UpdateUserProfile, ServiceResponse } from '@/lib/types/database.types';\n\nexport class UserService {\n  private static instance: UserService;\n  \n  static getInstance(): UserService {\n    if (!UserService.instance) {\n      UserService.instance = new UserService();\n    }\n    return UserService.instance;\n  }\n\n  /**\n   * Get user profile by ID\n   */\n  async getUserProfile(userId: string): Promise<ServiceResponse<UserProfile>> {\n    console.log('üì° UserService - getUserProfile called for userId:', userId);\n    \n    try {\n      console.log('üì° UserService - querying user_profiles table...');\n      \n      // Add timeout handling\n      const timeoutPromise = new Promise((_, reject) =>\n        setTimeout(() => reject(new Error('getUserProfile request timed out after 10 seconds')), 10000)\n      );\n      \n      const queryPromise = supabase\n        .from('users')\n        .select('*')\n        .eq('id', userId)\n        .single();\n\n      const { data, error } = await Promise.race([queryPromise, timeoutPromise]) as any;\n\n      console.log('üì° UserService - supabase response:', { \n        hasData: !!data, \n        error: error?.message, \n        errorCode: error?.code,\n        dataDisplayName: data?.display_name \n      });\n\n      if (error) {\n        console.log('‚ùå UserService - returning error response:', error.message);\n        return {\n          data: null,\n          error: {\n            code: 'PROFILE_NOT_FOUND',\n            message: error.message,\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      console.log('‚úÖ UserService - returning success response');\n      return {\n        data: data,\n        error: null,\n        success: true\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error: {\n          code: 'UNEXPECTED_ERROR',\n          message: error instanceof Error ? error.message : 'An unexpected error occurred',\n          timestamp: new Date().toISOString()\n        },\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Update user profile\n   */\n  async updateUserProfile(userId: string, updates: UpdateUserProfile): Promise<ServiceResponse<UserProfile>> {\n    try {\n      const { data, error } = await supabase\n        .from('users')\n        .update({\n          ...updates,\n          updated_at: new Date().toISOString()\n        })\n        .eq('id', userId)\n        .select('*')\n        .single();\n\n      if (error) {\n        return {\n          data: null,\n          error: {\n            code: 'UPDATE_FAILED',\n            message: error.message,\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      return {\n        data: data,\n        error: null,\n        success: true,\n        message: 'Profile updated successfully'\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error: {\n          code: 'UNEXPECTED_ERROR',\n          message: error instanceof Error ? error.message : 'Failed to update profile',\n          timestamp: new Date().toISOString()\n        },\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Create user profile (typically called during signup)\n   */\n  async createUserProfile(userId: string, profileData: {\n    display_name: string;\n    preferred_position?: string;\n    location?: string;\n    bio?: string;\n    date_of_birth?: string;\n  }): Promise<ServiceResponse<UserProfile>> {\n    try {\n      const { data, error } = await supabase\n        .from('users')\n        .insert({\n          id: userId,\n          display_name: profileData.display_name,\n          preferred_position: profileData.preferred_position,\n          location: profileData.location,\n          bio: profileData.bio,\n          date_of_birth: profileData.date_of_birth,\n          created_at: new Date().toISOString(),\n          updated_at: new Date().toISOString()\n        })\n        .select('*')\n        .single();\n\n      if (error) {\n        return {\n          data: null,\n          error: {\n            code: 'CREATE_FAILED',\n            message: error.message,\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      return {\n        data: data,\n        error: null,\n        success: true,\n        message: 'Profile created successfully'\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error: {\n          code: 'UNEXPECTED_ERROR',\n          message: error instanceof Error ? error.message : 'Failed to create profile',\n          timestamp: new Date().toISOString()\n        },\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Check if user profile exists\n   */\n  async profileExists(userId: string): Promise<ServiceResponse<boolean>> {\n    try {\n      const { data, error } = await supabase\n        .from('users')\n        .select('id')\n        .eq('id', userId)\n        .maybeSingle();\n\n      if (error) {\n        return {\n          data: false,\n          error: {\n            code: 'CHECK_FAILED',\n            message: error.message,\n            timestamp: new Date().toISOString()\n          },\n          success: false\n        };\n      }\n\n      return {\n        data: !!data,\n        error: null,\n        success: true\n      };\n    } catch (error) {\n      return {\n        data: false,\n        error: {\n          code: 'UNEXPECTED_ERROR',\n          message: error instanceof Error ? error.message : 'Failed to check profile',\n          timestamp: new Date().toISOString()\n        },\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get or create user profile (ensures profile exists)\n   */\n  async getOrCreateUserProfile(userId: string, fallbackData?: {\n    display_name: string;\n    preferred_position?: string;\n    location?: string;\n  }): Promise<ServiceResponse<UserProfile>> {\n    try {\n      // First try to get existing profile\n      const profileResult = await this.getUserProfile(userId);\n      \n      if (profileResult.success && profileResult.data) {\n        return profileResult;\n      }\n\n      // If profile doesn't exist and we have fallback data, create it\n      if (fallbackData) {\n        return await this.createUserProfile(userId, fallbackData);\n      }\n\n      // No profile and no fallback data\n      return {\n        data: null,\n        error: {\n          code: 'PROFILE_NOT_FOUND',\n          message: 'User profile not found and no fallback data provided',\n          timestamp: new Date().toISOString()\n        },\n        success: false\n      };\n    } catch (error) {\n      return {\n        data: null,\n        error: {\n          code: 'UNEXPECTED_ERROR',\n          message: error instanceof Error ? error.message : 'Failed to get or create profile',\n          timestamp: new Date().toISOString()\n        },\n        success: false\n      };\n    }\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 3850, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/stats.service.ts"],"sourcesContent":["/**\n * Stats Service for MatchDay\n * \n * Handles comprehensive performance analytics operations with focus on:\n * - Individual player statistics and trends\n * - Cross-league performance comparisons\n * - Global rankings and leaderboards\n * - Performance trend analysis and predictions\n * \n * Optimized for providing deep insights into player performance across leagues\n */\n\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport {\n  Database,\n  PlayerStats,\n  PlayerCrossLeagueStats,\n  LeagueComparison,\n  PerformanceTrend,\n  GlobalRanking,\n  ServiceResponse,\n  ServiceError,\n  PaginatedServiceResponse,\n  SportType,\n  LeagueType,\n  CacheOptions,\n  RealtimeSubscriptionOptions\n} from '@/lib/types/database.types';\n\nexport interface StatsFilters {\n  sportType?: SportType;\n  leagueType?: LeagueType;\n  seasonYear?: number;\n  minGames?: number;\n  position?: string;\n  ageGroup?: 'under_18' | 'under_21' | 'under_25' | 'over_25' | 'all';\n}\n\nexport interface PlayerPerformanceAnalysis {\n  playerId: string;\n  playerName: string;\n  avatarUrl?: string;\n  overallRating: number;\n  strengths: string[];\n  improvements: string[];\n  trends: {\n    goals: PerformanceTrend[];\n    assists: PerformanceTrend[];\n    overall: PerformanceTrend[];\n  };\n  comparisons: {\n    vsLeagueAverage: {\n      goals: number;\n      assists: number;\n      performance: number;\n    };\n    vsPositionAverage: {\n      goals: number;\n      assists: number;\n      performance: number;\n    };\n    improvement: {\n      last30Days: number;\n      last3Months: number;\n      season: number;\n    };\n  };\n  predictions: {\n    seasonEndGoals: number;\n    seasonEndAssists: number;\n    confidenceLevel: number;\n  };\n}\n\nexport interface LeagueAnalytics {\n  leagueId: string;\n  leagueName: string;\n  sportType: SportType;\n  totalPlayers: number;\n  totalTeams: number;\n  totalMatches: number;\n  averageGoalsPerGame: number;\n  competitiveness: {\n    score: number;\n    description: string;\n  };\n  topPerformers: {\n    goals: GlobalRanking[];\n    assists: GlobalRanking[];\n    overall: GlobalRanking[];\n  };\n  trends: {\n    playerGrowth: number;\n    matchActivity: number;\n    competitiveBalance: number;\n  };\n  insights: string[];\n}\n\nexport interface CrossLeagueComparison {\n  playerId: string;\n  playerName: string;\n  leagues: Array<{\n    league: Database['public']['Tables']['leagues']['Row'];\n    stats: PlayerStats;\n    rank: {\n      goals: number;\n      assists: number;\n      overall: number;\n    };\n    performance: {\n      goalsPerGame: number;\n      assistsPerGame: number;\n      consistency: number;\n      improvement: number;\n    };\n    adaptability: {\n      score: number;\n      factors: string[];\n    };\n  }>;\n  overallAnalysis: {\n    versatility: number;\n    consistency: number;\n    adaptability: number;\n    growthPotential: number;\n  };\n  recommendations: string[];\n}\n\nexport class StatsService {\n  private static instance: StatsService;\n  private supabase: SupabaseClient<Database>;\n  private cache = new Map<string, { data: unknown; timestamp: number; ttl: number }>();\n\n  private constructor(supabaseClient: SupabaseClient<Database>) {\n    this.supabase = supabaseClient;\n  }\n\n  static getInstance(supabaseClient?: SupabaseClient<Database>): StatsService {\n    if (!StatsService.instance) {\n      if (!supabaseClient) {\n        throw new Error('SupabaseClient required for first initialization');\n      }\n      StatsService.instance = new StatsService(supabaseClient);\n    }\n    return StatsService.instance;\n  }\n\n  /**\n   * Handle service errors consistently\n   */\n  private handleError(error: unknown, operation: string): ServiceError {\n    console.error(`StatsService.${operation}:`, {\n      error,\n      errorType: typeof error,\n      errorKeys: error ? Object.keys(error) : [],\n      errorCode: error?.code,\n      errorMessage: error?.message,\n      stack: error?.stack\n    });\n    \n    // Handle specific database errors\n    if (error?.code === 'PGRST116') {\n      return {\n        code: 'NOT_FOUND',\n        message: 'No data found for the requested user',\n        details: { originalError: error, operation },\n        timestamp: new Date().toISOString()\n      };\n    }\n    \n    // Handle empty error objects\n    if (!error || (typeof error === 'object' && Object.keys(error).length === 0)) {\n      return {\n        code: 'EMPTY_ERROR',\n        message: 'An unknown error occurred with no error details',\n        details: { operation, receivedError: error },\n        timestamp: new Date().toISOString()\n      };\n    }\n    \n    return {\n      code: error?.code || 'UNKNOWN_ERROR',\n      message: error?.message || 'An unexpected error occurred',\n      details: error?.details || error,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Cache management utilities\n   */\n  private getCacheKey(operation: string, params: unknown): string {\n    return `stats_service:${operation}:${JSON.stringify(params)}`;\n  }\n\n  private getFromCache<T>(key: string): T | null {\n    const cached = this.cache.get(key);\n    if (!cached) return null;\n    \n    if (Date.now() - cached.timestamp > cached.ttl * 1000) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return cached.data as T;\n  }\n\n  private setCache<T>(key: string, data: T, ttl = 900): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl\n    });\n  }\n\n  /**\n   * Get comprehensive player performance analysis\n   */\n  async getPlayerPerformanceAnalysis(\n    userId: string,\n    options: {\n      seasonYear?: number;\n      includeComparisons?: boolean;\n      includePredictions?: boolean;\n    } = {}\n  ): Promise<ServiceResponse<PlayerPerformanceAnalysis>> {\n    try {\n      const cacheKey = this.getCacheKey('getPlayerPerformanceAnalysis', { userId, options });\n      const cached = this.getFromCache<PlayerPerformanceAnalysis>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      const seasonYear = options.seasonYear || new Date().getFullYear();\n\n      // Get player profile\n      const { data: profile, error: profileError } = await this.supabase\n        .from('users')\n        .select('display_name, avatar_url, preferred_position')\n        .eq('id', userId)\n        .single();\n\n      if (profileError && profileError.code !== 'PGRST116') throw profileError;\n      \n      // If no profile exists, create a default one for the analysis\n      const playerProfile = profile || {\n        display_name: 'Unknown Player',\n        avatar_url: null,\n        preferred_position: null\n      };\n\n      // Try to get cross-league stats (table may not exist yet)\n      let crossLeagueStats = null;\n      try {\n        const { data: stats, error: statsError } = await this.supabase\n          .from('player_cross_league_stats')\n          .select('*')\n          .eq('player_id', userId)\n          .eq('season_year', seasonYear)\n          .single();\n\n        if (statsError && statsError.code !== 'PGRST116') {\n          console.warn('player_cross_league_stats table not found, will generate stats from player_stats');\n        } else {\n          crossLeagueStats = stats;\n        }\n      } catch (error) {\n        console.warn('player_cross_league_stats table not available, using fallback approach');\n      }\n\n      // Get individual league stats for detailed analysis\n      const { data: leagueStats, error: leagueError } = await this.supabase\n        .from('player_stats')\n        .select(`\n          *,\n          league:leagues!inner(*),\n          team:teams!inner(*)\n        `)\n        .eq('player_id', userId)\n        .eq('season_year', seasonYear);\n\n      if (leagueError) throw leagueError;\n\n      // If no cross-league stats, generate them from individual league stats\n      if (!crossLeagueStats && leagueStats && leagueStats.length > 0) {\n        crossLeagueStats = this.generateCrossLeagueStatsFromPlayerStats(leagueStats);\n      }\n\n      // Calculate performance trends (with error handling)\n      let trends;\n      try {\n        trends = await this.calculatePerformanceTrends(userId, seasonYear);\n      } catch (trendsError) {\n        console.warn('Failed to calculate performance trends:', trendsError);\n        trends = { data: { goals: [], assists: [], overall: [] }, error: null, success: false };\n      }\n\n      // Calculate overall rating\n      const overallRating = this.calculateOverallRating(crossLeagueStats, leagueStats || []);\n\n      // Analyze strengths and improvements\n      const { strengths, improvements } = this.analyzePlayerStrengthsAndWeaknesses(\n        crossLeagueStats,\n        leagueStats || []\n      );\n\n      // Calculate comparisons if requested\n      let comparisons;\n      if (options.includeComparisons) {\n        comparisons = await this.calculatePlayerComparisons(\n          userId,\n          playerProfile.preferred_position,\n          crossLeagueStats,\n          seasonYear\n        );\n      }\n\n      // Calculate predictions if requested\n      let predictions;\n      if (options.includePredictions) {\n        predictions = await this.calculateSeasonPredictions(userId, crossLeagueStats, trends.data);\n      }\n\n      const analysis: PlayerPerformanceAnalysis = {\n        playerId: userId,\n        playerName: playerProfile.display_name,\n        avatarUrl: playerProfile.avatar_url,\n        overallRating,\n        strengths,\n        improvements,\n        trends: trends.data || {\n          goals: [],\n          assists: [],\n          overall: []\n        },\n        comparisons: comparisons || {\n          vsLeagueAverage: { goals: 0, assists: 0, performance: 0 },\n          vsPositionAverage: { goals: 0, assists: 0, performance: 0 },\n          improvement: { last30Days: 0, last3Months: 0, season: 0 }\n        },\n        predictions: predictions || {\n          seasonEndGoals: crossLeagueStats?.total_goals || 0,\n          seasonEndAssists: crossLeagueStats?.total_assists || 0,\n          confidenceLevel: 50\n        }\n      };\n\n      // Cache for 15 minutes\n      this.setCache(cacheKey, analysis, 900);\n\n      return { data: analysis, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerPerformanceAnalysis'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get global player rankings across different stats\n   */\n  async getGlobalRankings(\n    statType: 'goals' | 'assists' | 'matches' | 'performance',\n    filters: StatsFilters = {},\n    options: { limit?: number; offset?: number } = {}\n  ): Promise<PaginatedServiceResponse<GlobalRanking>> {\n    try {\n      const cacheKey = this.getCacheKey('getGlobalRankings', { statType, filters, options });\n      const cached = this.getFromCache<GlobalRanking[]>(cacheKey);\n      \n      if (cached) {\n        return {\n          data: cached,\n          error: null,\n          success: true,\n          pagination: {\n            page: Math.floor((options.offset || 0) / (options.limit || 50)) + 1,\n            limit: options.limit || 50,\n            total: cached.length,\n            totalPages: Math.ceil(cached.length / (options.limit || 50)),\n            hasNext: false,\n            hasPrevious: false\n          }\n        };\n      }\n\n      // Use RPC function for complex ranking calculation\n      const { data: rankings, error } = await this.supabase\n        .rpc('get_global_rankings', {\n          stat_type: statType,\n          sport_type_filter: filters.sportType || null,\n          league_type_filter: filters.leagueType || null,\n          season_year_filter: filters.seasonYear || new Date().getFullYear(),\n          min_games_filter: filters.minGames || 1,\n          position_filter: filters.position || null,\n          limit_count: options.limit || 50,\n          offset_count: options.offset || 0\n        });\n\n      if (error) throw error;\n\n      const globalRankings: GlobalRanking[] = (rankings || []).map((entry, index) => ({\n        playerId: entry.player_id,\n        displayName: entry.display_name,\n        avatarUrl: entry.avatar_url,\n        rank: (options.offset || 0) + index + 1,\n        statValue: entry.stat_value,\n        trend: 'stable', // Would need historical data to calculate trend\n        previousRank: entry.previous_rank\n      }));\n\n      // Cache for 30 minutes\n      this.setCache(cacheKey, globalRankings, 1800);\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 50)) + 1,\n        limit: options.limit || 50,\n        total: globalRankings.length,\n        totalPages: Math.ceil(globalRankings.length / (options.limit || 50)),\n        hasNext: globalRankings.length === (options.limit || 50),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: globalRankings,\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getGlobalRankings'),\n        success: false,\n        pagination: {\n          page: 1,\n          limit: options.limit || 50,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrevious: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Get cross-league performance comparison for a player\n   */\n  async getCrossLeagueComparison(\n    userId: string,\n    options: { seasonYear?: number; includeAnalysis?: boolean } = {}\n  ): Promise<ServiceResponse<CrossLeagueComparison>> {\n    try {\n      const cacheKey = this.getCacheKey('getCrossLeagueComparison', { userId, options });\n      const cached = this.getFromCache<CrossLeagueComparison>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      const seasonYear = options.seasonYear || new Date().getFullYear();\n\n      // Get player profile\n      const { data: profile, error: profileError } = await this.supabase\n        .from('users')\n        .select('display_name')\n        .eq('id', userId)\n        .single();\n\n      if (profileError) throw profileError;\n\n      // Get player's stats across leagues\n      const { data: playerStats, error: statsError } = await this.supabase\n        .from('player_stats')\n        .select(`\n          *,\n          league:leagues!inner(*),\n          team:teams!inner(*)\n        `)\n        .eq('player_id', userId)\n        .eq('season_year', seasonYear);\n\n      if (statsError) throw statsError;\n\n      // Process league comparisons\n      const leagues = await Promise.all(\n        (playerStats || []).map(async (stat) => {\n          // Get league rankings for this player\n          const rank = await this.getPlayerLeagueRank(userId, stat.league_id, seasonYear);\n          \n          // Calculate performance metrics\n          const performance = {\n            goalsPerGame: stat.games_played > 0 ? (stat.goals || 0) / stat.games_played : 0,\n            assistsPerGame: stat.games_played > 0 ? (stat.assists || 0) / stat.games_played : 0,\n            consistency: this.calculateConsistency(stat),\n            improvement: 0 // Would need historical data\n          };\n\n          // Calculate adaptability\n          const adaptability = this.calculateAdaptability(stat, stat.league);\n\n          return {\n            league: stat.league,\n            stats: stat,\n            rank: rank.data || { goals: 999, assists: 999, overall: 999 },\n            performance,\n            adaptability\n          };\n        })\n      );\n\n      // Calculate overall analysis\n      const overallAnalysis = this.calculateOverallCrossLeagueAnalysis(leagues);\n      \n      // Generate recommendations\n      const recommendations = this.generateCrossLeagueRecommendations(leagues, overallAnalysis);\n\n      const comparison: CrossLeagueComparison = {\n        playerId: userId,\n        playerName: profile.display_name,\n        leagues,\n        overallAnalysis,\n        recommendations\n      };\n\n      // Cache for 20 minutes\n      this.setCache(cacheKey, comparison, 1200);\n\n      return { data: comparison, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getCrossLeagueComparison'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get comprehensive league analytics\n   */\n  async getLeagueAnalytics(\n    leagueId: string,\n    options: { seasonYear?: number; includeInsights?: boolean } = {}\n  ): Promise<ServiceResponse<LeagueAnalytics>> {\n    try {\n      const cacheKey = this.getCacheKey('getLeagueAnalytics', { leagueId, options });\n      const cached = this.getFromCache<LeagueAnalytics>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      const seasonYear = options.seasonYear || new Date().getFullYear();\n\n      // Get league details\n      const { data: league, error: leagueError } = await this.supabase\n        .from('leagues')\n        .select('*')\n        .eq('id', leagueId)\n        .single();\n\n      if (leagueError) throw leagueError;\n\n      // Get league statistics using RPC\n      const { data: leagueStats, error: statsError } = await this.supabase\n        .rpc('get_league_analytics', {\n          league_id: leagueId,\n          season_year: seasonYear\n        });\n\n      if (statsError) throw statsError;\n\n      // Get top performers\n      const topPerformers = await this.getLeagueTopPerformers(leagueId, seasonYear);\n\n      // Calculate trends\n      const trends = await this.calculateLeagueTrends(leagueId, seasonYear);\n\n      // Generate insights\n      let insights: string[] = [];\n      if (options.includeInsights) {\n        insights = this.generateLeagueInsights(leagueStats, topPerformers.data, trends.data);\n      }\n\n      const analytics: LeagueAnalytics = {\n        leagueId,\n        leagueName: league.name,\n        sportType: league.sport_type as SportType,\n        totalPlayers: leagueStats?.total_players || 0,\n        totalTeams: leagueStats?.total_teams || 0,\n        totalMatches: leagueStats?.total_matches || 0,\n        averageGoalsPerGame: leagueStats?.average_goals_per_game || 0,\n        competitiveness: {\n          score: leagueStats?.competitiveness_score || 50,\n          description: this.getCompetitivenessDescription(leagueStats?.competitiveness_score || 50)\n        },\n        topPerformers: topPerformers.data || {\n          goals: [],\n          assists: [],\n          overall: []\n        },\n        trends: trends.data || {\n          playerGrowth: 0,\n          matchActivity: 0,\n          competitiveBalance: 0\n        },\n        insights\n      };\n\n      // Cache for 1 hour\n      this.setCache(cacheKey, analytics, 3600);\n\n      return { data: analytics, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getLeagueAnalytics'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get performance trends for a player over time\n   */\n  async getPerformanceTrends(\n    userId: string,\n    options: {\n      period: 'weekly' | 'monthly' | 'quarterly';\n      statTypes: Array<'goals' | 'assists' | 'matches' | 'performance'>;\n      seasonYear?: number;\n    }\n  ): Promise<ServiceResponse<{ [key: string]: PerformanceTrend[] }>> {\n    try {\n      const cacheKey = this.getCacheKey('getPerformanceTrends', { userId, options });\n      const cached = this.getFromCache<{ [key: string]: PerformanceTrend[] }>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      const trends = await this.calculatePerformanceTrends(\n        userId,\n        options.seasonYear || new Date().getFullYear(),\n        options.period,\n        options.statTypes\n      );\n\n      return trends;\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPerformanceTrends'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n  private generateCrossLeagueStatsFromPlayerStats(playerStats: PlayerStats[]): any {\n    const totalGoals = playerStats.reduce((sum, stat) => sum + (stat.goals || 0), 0);\n    const totalAssists = playerStats.reduce((sum, stat) => sum + (stat.assists || 0), 0);\n    const totalGames = playerStats.reduce((sum, stat) => sum + (stat.games_played || 0), 0);\n    const leaguesPlayed = new Set(playerStats.map(stat => stat.league_id)).size;\n    const teamsPlayed = new Set(playerStats.map(stat => stat.team_id)).size;\n\n    return {\n      player_id: playerStats[0]?.player_id || '',\n      display_name: 'Generated Stats',\n      avatar_url: null,\n      preferred_position: null,\n      season_year: new Date().getFullYear(),\n      leagues_played: leaguesPlayed,\n      teams_played: teamsPlayed,\n      total_games_played: totalGames,\n      total_goals: totalGoals,\n      total_assists: totalAssists,\n      total_yellow_cards: playerStats.reduce((sum, stat) => sum + (stat.yellow_cards || 0), 0),\n      total_red_cards: playerStats.reduce((sum, stat) => sum + (stat.red_cards || 0), 0),\n      avg_goals_per_game: totalGames > 0 ? totalGoals / totalGames : 0,\n      avg_contributions_per_game: totalGames > 0 ? (totalGoals + totalAssists) / totalGames : 0,\n      goals_consistency: totalGames > 0 ? this.calculateGoalsConsistency(playerStats) : null,\n      created_at: new Date().toISOString(),\n      updated_at: new Date().toISOString()\n    };\n  }\n\n  private calculateGoalsConsistency(playerStats: PlayerStats[]): number {\n    if (playerStats.length === 0) return 0;\n    \n    const goalRates = playerStats.map(stat => \n      (stat.games_played || 0) > 0 ? (stat.goals || 0) / (stat.games_played || 1) : 0\n    );\n    \n    const avgRate = goalRates.reduce((sum, rate) => sum + rate, 0) / goalRates.length;\n    const variance = goalRates.reduce((sum, rate) => sum + Math.pow(rate - avgRate, 2), 0) / goalRates.length;\n    \n    return Math.sqrt(variance);\n  }\n  private async calculatePerformanceTrends(\n    userId: string,\n    seasonYear: number,\n    period: 'weekly' | 'monthly' | 'quarterly' = 'monthly',\n    statTypes: Array<'goals' | 'assists' | 'matches' | 'performance'> = ['goals', 'assists', 'performance']\n  ): Promise<ServiceResponse<{ [key: string]: PerformanceTrend[] }>> {\n    try {\n      // Check if the RPC function exists first, if not return empty trends\n      const { data: trendsData, error } = await this.supabase\n        .rpc('calculate_performance_trends', {\n          player_id: userId,\n          season_year: seasonYear,\n          period_type: period,\n          stat_types: statTypes\n        });\n\n      // If RPC function doesn't exist or has error, return empty trends\n      if (error) {\n        console.warn('Performance trends RPC function not available:', error);\n        const emptyTrends: { [key: string]: PerformanceTrend[] } = {};\n        statTypes.forEach(statType => {\n          emptyTrends[statType] = [];\n        });\n        return { data: emptyTrends, error: null, success: true };\n      }\n\n      // Process the trends data\n      const trends: { [key: string]: PerformanceTrend[] } = {};\n      statTypes.forEach(statType => {\n        trends[statType] = trendsData?.filter((t: { stat_type: string }) => t.stat_type === statType).map((t: { period: string; goals?: number; assists?: number; matches?: number; performance?: number }) => ({\n          period: t.period,\n          goals: t.goals || 0,\n          assists: t.assists || 0,\n          matches: t.matches || 0,\n          performance: t.performance || 0\n        })) || [];\n      });\n\n      return { data: trends, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'calculatePerformanceTrends'),\n        success: false\n      };\n    }\n  }\n\n  private calculateOverallRating(\n    crossLeagueStats: PlayerCrossLeagueStats | null,\n    leagueStats: PlayerStats[]\n  ): number {\n    if (!crossLeagueStats || !leagueStats.length) return 50;\n\n    // Simple rating calculation based on multiple factors\n    const avgGoalsPerGame = crossLeagueStats.avg_goals_per_game || 0;\n    const avgAssistsPerGame = crossLeagueStats.avg_contributions_per_game \n      ? crossLeagueStats.avg_contributions_per_game - avgGoalsPerGame \n      : 0;\n    const consistency = crossLeagueStats.goals_consistency ? 100 - (crossLeagueStats.goals_consistency * 10) : 50;\n    const leagueVariety = crossLeagueStats.leagues_played || 1;\n\n    const rating = Math.min(100, Math.max(0,\n      (avgGoalsPerGame * 20) +\n      (avgAssistsPerGame * 15) +\n      (consistency * 0.3) +\n      (leagueVariety * 2) +\n      30 // Base rating\n    ));\n\n    return Math.round(rating);\n  }\n\n  private analyzePlayerStrengthsAndWeaknesses(\n    crossLeagueStats: PlayerCrossLeagueStats | null,\n    leagueStats: PlayerStats[]\n  ): { strengths: string[]; improvements: string[] } {\n    const strengths: string[] = [];\n    const improvements: string[] = [];\n\n    if (!crossLeagueStats) {\n      return { strengths: ['New player - building experience'], improvements: ['Play more matches to build statistics'] };\n    }\n\n    // Analyze strengths\n    if (crossLeagueStats.avg_goals_per_game > 0.5) {\n      strengths.push('Excellent goal scoring ability');\n    }\n    if (crossLeagueStats.avg_contributions_per_game > 0.7) {\n      strengths.push('High overall contribution to team');\n    }\n    if (crossLeagueStats.leagues_played > 2) {\n      strengths.push('Versatile across different leagues');\n    }\n    if (crossLeagueStats.total_games_played > 20) {\n      strengths.push('Experienced and consistent player');\n    }\n\n    // Analyze improvements\n    if (crossLeagueStats.avg_goals_per_game < 0.2) {\n      improvements.push('Focus on creating more scoring opportunities');\n    }\n    if (crossLeagueStats.goals_consistency && crossLeagueStats.goals_consistency > 0.5) {\n      improvements.push('Work on consistency in performance');\n    }\n    if (crossLeagueStats.leagues_played === 1) {\n      improvements.push('Consider exploring different leagues for variety');\n    }\n\n    // Ensure we have at least some content\n    if (strengths.length === 0) {\n      strengths.push('Building experience and skills');\n    }\n    if (improvements.length === 0) {\n      improvements.push('Continue developing match experience');\n    }\n\n    return { strengths, improvements };\n  }\n\n  private async calculatePlayerComparisons(\n    userId: string,\n    position: string | null,\n    crossLeagueStats: PlayerCrossLeagueStats | null,\n    seasonYear: number\n  ) {\n    // This would involve complex calculations comparing against league and position averages\n    // Simplified implementation\n    return {\n      vsLeagueAverage: {\n        goals: crossLeagueStats?.avg_goals_per_game || 0,\n        assists: (crossLeagueStats?.avg_contributions_per_game || 0) - (crossLeagueStats?.avg_goals_per_game || 0),\n        performance: 0\n      },\n      vsPositionAverage: {\n        goals: crossLeagueStats?.avg_goals_per_game || 0,\n        assists: (crossLeagueStats?.avg_contributions_per_game || 0) - (crossLeagueStats?.avg_goals_per_game || 0),\n        performance: 0\n      },\n      improvement: {\n        last30Days: 0,\n        last3Months: 0,\n        season: 0\n      }\n    };\n  }\n\n  private async calculateSeasonPredictions(\n    userId: string,\n    crossLeagueStats: PlayerCrossLeagueStats | null,\n    trends: any\n  ) {\n    if (!crossLeagueStats) {\n      return {\n        seasonEndGoals: 0,\n        seasonEndAssists: 0,\n        confidenceLevel: 0\n      };\n    }\n\n    // Simple prediction based on current performance\n    const remainingWeeks = Math.max(0, 52 - new Date().getWeek());\n    const currentRate = crossLeagueStats.avg_goals_per_game || 0;\n    \n    return {\n      seasonEndGoals: Math.round((crossLeagueStats.total_goals || 0) + (currentRate * remainingWeeks * 0.5)),\n      seasonEndAssists: Math.round((crossLeagueStats.total_assists || 0) + (currentRate * 0.7 * remainingWeeks * 0.5)),\n      confidenceLevel: crossLeagueStats.total_games_played > 10 ? 75 : 45\n    };\n  }\n\n  private async getPlayerLeagueRank(userId: string, leagueId: string, seasonYear: number): Promise<ServiceResponse<{\n    goals: number;\n    assists: number;\n    overall: number;\n  }>> {\n    try {\n      const { data, error } = await this.supabase\n        .rpc('get_player_league_rank', {\n          player_id: userId,\n          league_id: leagueId,\n          season_year: seasonYear\n        });\n\n      if (error) throw error;\n\n      return {\n        data: data || { goals: 999, assists: 999, overall: 999 },\n        error: null,\n        success: true\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerLeagueRank'),\n        success: false\n      };\n    }\n  }\n\n  private calculateConsistency(stats: PlayerStats): number {\n    // Simplified consistency calculation\n    if (!stats.games_played || stats.games_played === 0) return 0;\n    \n    const goalConsistency = stats.goals ? (stats.goals / stats.games_played) * 100 : 0;\n    const participationConsistency = stats.games_started ? (stats.games_started / stats.games_played) * 100 : 50;\n    \n    return Math.round((goalConsistency + participationConsistency) / 2);\n  }\n\n  private calculateAdaptability(stats: PlayerStats, league: any) {\n    const factors: string[] = [];\n    let score = 50;\n\n    if (stats.games_played > 5) {\n      score += 20;\n      factors.push('Good match participation');\n    }\n\n    if (league.league_type === 'competitive' && (stats.goals || 0) > 0) {\n      score += 15;\n      factors.push('Performs well in competitive environment');\n    }\n\n    return {\n      score: Math.min(100, score),\n      factors\n    };\n  }\n\n  private calculateOverallCrossLeagueAnalysis(leagues: any[]) {\n    const numLeagues = leagues.length;\n    \n    return {\n      versatility: Math.min(100, numLeagues * 25),\n      consistency: numLeagues > 0 \n        ? Math.round(leagues.reduce((sum, l) => sum + l.performance.consistency, 0) / numLeagues)\n        : 0,\n      adaptability: numLeagues > 0\n        ? Math.round(leagues.reduce((sum, l) => sum + l.adaptability.score, 0) / numLeagues)\n        : 0,\n      growthPotential: 75 // Simplified calculation\n    };\n  }\n\n  private generateCrossLeagueRecommendations(leagues: any[], overallAnalysis: any): string[] {\n    const recommendations: string[] = [];\n\n    if (leagues.length === 1) {\n      recommendations.push('Consider joining additional leagues to showcase versatility');\n    }\n\n    if (overallAnalysis.consistency < 60) {\n      recommendations.push('Focus on maintaining consistent performance across leagues');\n    }\n\n    if (overallAnalysis.adaptability < 70) {\n      recommendations.push('Work on adapting your play style to different league formats');\n    }\n\n    return recommendations;\n  }\n\n  private async getLeagueTopPerformers(leagueId: string, seasonYear: number): Promise<ServiceResponse<{\n    goals: GlobalRanking[];\n    assists: GlobalRanking[];\n    overall: GlobalRanking[];\n  }>> {\n    try {\n      // Get top goal scorers\n      const { data: goalScorers, error: goalError } = await this.supabase\n        .from('player_leaderboard')\n        .select('*')\n        .eq('league_id', leagueId)\n        .eq('season_year', seasonYear)\n        .order('goals', { ascending: false })\n        .limit(10);\n\n      if (goalError) throw goalError;\n\n      // Get top assists\n      const { data: assistLeaders, error: assistError } = await this.supabase\n        .from('player_leaderboard')\n        .select('*')\n        .eq('league_id', leagueId)\n        .eq('season_year', seasonYear)\n        .order('assists', { ascending: false })\n        .limit(10);\n\n      if (assistError) throw assistError;\n\n      // Get overall performers (based on goals + assists)\n      const { data: overallPerformers, error: overallError } = await this.supabase\n        .from('player_leaderboard')\n        .select('*')\n        .eq('league_id', leagueId)\n        .eq('season_year', seasonYear)\n        .order('goal_contributions_per_game', { ascending: false })\n        .limit(10);\n\n      if (overallError) throw overallError;\n\n      const data = {\n        goals: (goalScorers || []).map((player, index) => ({\n          playerId: player.player_id,\n          displayName: player.display_name,\n          avatarUrl: player.avatar_url,\n          rank: index + 1,\n          statValue: player.goals,\n          trend: 'stable' as const\n        })),\n        assists: (assistLeaders || []).map((player, index) => ({\n          playerId: player.player_id,\n          displayName: player.display_name,\n          avatarUrl: player.avatar_url,\n          rank: index + 1,\n          statValue: player.assists,\n          trend: 'stable' as const\n        })),\n        overall: (overallPerformers || []).map((player, index) => ({\n          playerId: player.player_id,\n          displayName: player.display_name,\n          avatarUrl: player.avatar_url,\n          rank: index + 1,\n          statValue: player.goals + player.assists,\n          trend: 'stable' as const\n        }))\n      };\n\n      return { data, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getLeagueTopPerformers'),\n        success: false\n      };\n    }\n  }\n\n  private async calculateLeagueTrends(leagueId: string, seasonYear: number): Promise<ServiceResponse<{\n    playerGrowth: number;\n    matchActivity: number;\n    competitiveBalance: number;\n  }>> {\n    try {\n      // Get league statistics for trends calculation\n      const { data: currentStats, error: currentError } = await this.supabase\n        .from('league_standings')\n        .select('*')\n        .eq('league_id', leagueId)\n        .eq('season_year', seasonYear);\n\n      if (currentError) throw currentError;\n\n      // Get previous year for comparison (if available)\n      const { data: previousStats, error: previousError } = await this.supabase\n        .from('league_standings')\n        .select('*')\n        .eq('league_id', leagueId)\n        .eq('season_year', seasonYear - 1);\n\n      // Calculate trends\n      const currentPlayerCount = currentStats?.length || 0;\n      const previousPlayerCount = previousStats?.length || 0;\n      const playerGrowth = previousPlayerCount > 0 \n        ? Math.round(((currentPlayerCount - previousPlayerCount) / previousPlayerCount) * 100)\n        : 0;\n\n      // Calculate match activity based on games played\n      const totalGames = currentStats?.reduce((sum, team) => sum + (team.games_played || 0), 0) || 0;\n      const expectedGames = currentPlayerCount * 10; // Assuming ~10 games per season\n      const matchActivity = expectedGames > 0 \n        ? Math.min(100, Math.round((totalGames / expectedGames) * 100))\n        : 0;\n\n      // Calculate competitive balance based on points distribution\n      const points = currentStats?.map(team => team.points || 0) || [];\n      const avgPoints = points.length > 0 ? points.reduce((a, b) => a + b, 0) / points.length : 0;\n      const pointsVariance = points.length > 0 \n        ? points.reduce((sum, points) => sum + Math.pow(points - avgPoints, 2), 0) / points.length\n        : 0;\n      const competitiveBalance = points.length > 0 \n        ? Math.max(0, Math.min(100, 100 - (Math.sqrt(pointsVariance) / avgPoints * 100)))\n        : 50;\n\n      const data = {\n        playerGrowth: Math.max(-100, Math.min(100, playerGrowth)),\n        matchActivity: Math.max(0, Math.min(100, matchActivity)),\n        competitiveBalance: Math.max(0, Math.min(100, Math.round(competitiveBalance)))\n      };\n\n      return { data, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: {\n          playerGrowth: 0,\n          matchActivity: 0,\n          competitiveBalance: 50\n        },\n        error: this.handleError(error, 'calculateLeagueTrends'),\n        success: false\n      };\n    }\n  }\n\n  private generateLeagueInsights(leagueStats: any, topPerformers: any, trends: any): string[] {\n    const insights: string[] = [];\n\n    if (leagueStats?.competitiveness_score > 80) {\n      insights.push('Highly competitive league with balanced teams');\n    } else if (leagueStats?.competitiveness_score < 40) {\n      insights.push('Consider strategies to improve competitive balance');\n    }\n\n    if (trends?.playerGrowth > 20) {\n      insights.push('Strong player growth indicating healthy league development');\n    }\n\n    if (leagueStats?.average_goals_per_game > 3) {\n      insights.push('High-scoring league with attacking play style');\n    } else if (leagueStats?.average_goals_per_game < 1.5) {\n      insights.push('Defensive-minded league with tight matches');\n    }\n\n    return insights;\n  }\n\n  private getCompetitivenessDescription(score: number): string {\n    if (score >= 80) return 'Highly competitive with balanced teams';\n    if (score >= 60) return 'Good competitive balance';\n    if (score >= 40) return 'Moderate competitiveness';\n    return 'Needs improvement in competitive balance';\n  }\n\n  /**\n   * Subscribe to real-time stats updates\n   */\n  subscribeToStatsUpdates(\n    userId: string,\n    callback: (payload: any) => void,\n    options: RealtimeSubscriptionOptions = { table: 'player_stats', event: '*' }\n  ) {\n    return this.supabase\n      .channel(`stats-${userId}-updates`)\n      .on(\n        'postgres_changes',\n        {\n          event: options.event,\n          schema: options.schema || 'public',\n          table: options.table,\n          filter: options.filter || `player_id=eq.${userId}`\n        },\n        callback\n      )\n      .subscribe();\n  }\n\n  /**\n   * Clear cache\n   */\n  clearCache(pattern?: string): void {\n    if (!pattern) {\n      this.cache.clear();\n      return;\n    }\n\n    const keys = Array.from(this.cache.keys());\n    keys.forEach(key => {\n      if (key.includes(pattern)) {\n        this.cache.delete(key);\n      }\n    });\n  }\n}\n\n// Extend Date prototype for week calculation (helper for predictions)\ndeclare global {\n  interface Date {\n    getWeek(): number;\n  }\n}\n\nDate.prototype.getWeek = function() {\n  const date = new Date(this.getTime());\n  date.setHours(0, 0, 0, 0);\n  date.setDate(date.getDate() + 3 - (date.getDay() + 6) % 7);\n  const week1 = new Date(date.getFullYear(), 0, 4);\n  return 1 + Math.round(((date.getTime() - week1.getTime()) / 86400000 - 3 + (week1.getDay() + 6) % 7) / 7);\n};"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4746, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/analytics.service.ts"],"sourcesContent":["/**\n * Analytics Service for MatchDay\n * \n * Handles cross-league comparisons and advanced statistics that make amateur\n * players feel professional. Provides comprehensive analytics across all leagues.\n * \n * @example\n * ```typescript\n * const ranking = await AnalyticsService.getInstance().getGlobalPlayerRanking(userId);\n * const comparison = await AnalyticsService.getInstance().comparePlayerAcrossLeagues(userId);\n * ```\n * \n * This service should be used for ALL analytics and comparison operations.\n */\n\nimport { Database } from '../types/database.types';\n\ntype PlayerStats = Database['public']['Tables']['player_stats']['Row'];\ntype TeamStats = Database['public']['Tables']['team_stats']['Row'];\n\nexport interface GlobalPlayerRanking {\n  playerId: string;\n  displayName: string;\n  avatarUrl?: string;\n  totalGoals: number;\n  totalAssists: number;\n  totalGames: number;\n  totalMinutes: number;\n  globalRank: number;\n  percentileRank: number;\n  leaguesPlayed: number;\n  topLeague: string;\n  achievements: number;\n}\n\nexport interface CrossLeagueComparison {\n  playerId: string;\n  playerStats: {\n    totalGoals: number;\n    totalAssists: number;\n    totalGames: number;\n    averageGoalsPerGame: number;\n    totalMinutes: number;\n  };\n  leagueBreakdown: Array<{\n    leagueId: string;\n    leagueName: string;\n    sportType: string;\n    goals: number;\n    assists: number;\n    games: number;\n    rank: number;\n    percentile: number;\n  }>;\n  globalComparison: {\n    betterThanPercent: number;\n    similarPlayers: Array<{\n      playerId: string;\n      displayName: string;\n      goals: number;\n      assists: number;\n    }>;\n  };\n}\n\nexport interface GlobalLeaderboard {\n  category: string;\n  timeframe: string;\n  sportType?: string;\n  players: Array<{\n    rank: number;\n    playerId: string;\n    displayName: string;\n    avatarUrl?: string;\n    value: number;\n    leagues: string[];\n    trend: 'up' | 'down' | 'same';\n  }>;\n}\n\nexport class AnalyticsService {\n  private static instance: AnalyticsService;\n  private supabase: any;\n  \n  private constructor() {}\n  \n  static getInstance(): AnalyticsService {\n    if (!AnalyticsService.instance) {\n      AnalyticsService.instance = new AnalyticsService();\n    }\n    return AnalyticsService.instance;\n  }\n  \n  setSupabaseClient(client: any) {\n    this.supabase = client;\n  }\n  \n  /**\n   * Get global player ranking across all leagues\n   */\n  async getGlobalPlayerRanking(playerId: string): Promise<GlobalPlayerRanking | null> {\n    const { data, error } = await this.supabase.rpc('get_global_player_ranking', {\n      player_id: playerId\n    });\n    \n    if (error) throw error;\n    return data;\n  }\n  \n  /**\n   * Compare player performance across different leagues\n   */\n  async comparePlayerAcrossLeagues(playerId: string): Promise<CrossLeagueComparison> {\n    // Get player stats across all leagues\n    const { data: playerStats, error: statsError } = await this.supabase\n      .from('player_stats')\n      .select(`\n        *,\n        leagues(id, name, sport_type),\n        teams(name)\n      `)\n      .eq('player_id', playerId);\n    \n    if (statsError) throw statsError;\n    \n    // Calculate aggregated stats\n    const totalStats = playerStats.reduce((acc, stat) => ({\n      totalGoals: acc.totalGoals + (stat.goals || 0),\n      totalAssists: acc.totalAssists + (stat.assists || 0),\n      totalGames: acc.totalGames + (stat.games_played || 0),\n      totalMinutes: acc.totalMinutes + (stat.minutes_played || 0)\n    }), { totalGoals: 0, totalAssists: 0, totalGames: 0, totalMinutes: 0 });\n    \n    // Get league-specific rankings\n    const leagueBreakdown = await Promise.all(\n      playerStats.map(async (stat) => {\n        const { data: ranking } = await this.supabase.rpc('get_league_player_ranking', {\n          league_id: stat.league_id,\n          player_id: playerId\n        });\n        \n        return {\n          leagueId: stat.league_id,\n          leagueName: stat.leagues.name,\n          sportType: stat.leagues.sport_type,\n          goals: stat.goals || 0,\n          assists: stat.assists || 0,\n          games: stat.games_played || 0,\n          rank: ranking?.rank || 0,\n          percentile: ranking?.percentile || 0\n        };\n      })\n    );\n    \n    // Get global comparison data\n    const { data: globalData } = await this.supabase.rpc('get_player_global_comparison', {\n      player_id: playerId,\n      total_goals: totalStats.totalGoals\n    });\n    \n    return {\n      playerId,\n      playerStats: {\n        ...totalStats,\n        averageGoalsPerGame: totalStats.totalGames > 0 \n          ? totalStats.totalGoals / totalStats.totalGames \n          : 0\n      },\n      leagueBreakdown,\n      globalComparison: globalData || {\n        betterThanPercent: 0,\n        similarPlayers: []\n      }\n    };\n  }\n  \n  /**\n   * Get global leaderboards with various filters\n   */\n  async getGlobalLeaderboards(options: {\n    category: 'goals' | 'assists' | 'games_played' | 'goals_per_game';\n    timeframe: 'current_season' | 'all_time' | 'last_30_days';\n    sportType?: string;\n    limit?: number;\n  }): Promise<GlobalLeaderboard> {\n    const { data, error } = await this.supabase.rpc('get_global_leaderboard', {\n      stat_category: options.category,\n      time_frame: options.timeframe,\n      sport_filter: options.sportType,\n      result_limit: options.limit || 50\n    });\n    \n    if (error) throw error;\n    \n    return {\n      category: options.category,\n      timeframe: options.timeframe,\n      sportType: options.sportType,\n      players: data || []\n    };\n  }\n  \n  /**\n   * Get player performance trends over time\n   */\n  async getPlayerTrends(playerId: string, timeframe: 'season' | 'career' = 'season'): Promise<{\n    goals: Array<{ period: string; value: number }>;\n    assists: Array<{ period: string; value: number }>;\n    gamesPlayed: Array<{ period: string; value: number }>;\n  }> {\n    const { data, error } = await this.supabase.rpc('get_player_trends', {\n      player_id: playerId,\n      time_frame: timeframe\n    });\n    \n    if (error) throw error;\n    return data || { goals: [], assists: [], gamesPlayed: [] };\n  }\n  \n  /**\n   * Compare teams across leagues\n   */\n  async compareTeamsAcrossLeagues(teamIds: string[]): Promise<Array<{\n    teamId: string;\n    teamName: string;\n    leagueName: string;\n    sportType: string;\n    points: number;\n    wins: number;\n    draws: number;\n    losses: number;\n    goalsFor: number;\n    goalsAgainst: number;\n    leagueRank: number;\n    globalRank: number;\n  }>> {\n    const { data, error } = await this.supabase.rpc('compare_teams_across_leagues', {\n      team_ids: teamIds\n    });\n    \n    if (error) throw error;\n    return data || [];\n  }\n  \n  /**\n   * Get league strength rankings\n   */\n  async getLeagueStrengthRankings(sportType?: string): Promise<Array<{\n    leagueId: string;\n    leagueName: string;\n    sportType: string;\n    strengthScore: number;\n    avgGoalsPerGame: number;\n    competitivenessIndex: number;\n    totalPlayers: number;\n    totalTeams: number;\n  }>> {\n    const { data, error } = await this.supabase.rpc('get_league_strength_rankings', {\n      sport_filter: sportType\n    });\n    \n    if (error) throw error;\n    return data || [];\n  }\n  \n  /**\n   * Get player's achievement progress compared to others\n   */\n  async getAchievementComparison(playerId: string): Promise<{\n    totalAchievements: number;\n    globalRank: number;\n    percentileRank: number;\n    recentAchievements: Array<{\n      achievementId: string;\n      name: string;\n      earnedAt: string;\n      rarity: number; // Percentage of players who have this\n    }>;\n    recommendedAchievements: Array<{\n      achievementId: string;\n      name: string;\n      description: string;\n      progress: number; // 0-100\n      requirements: any;\n    }>;\n  }> {\n    const { data, error } = await this.supabase.rpc('get_achievement_comparison', {\n      player_id: playerId\n    });\n    \n    if (error) throw error;\n    return data || {\n      totalAchievements: 0,\n      globalRank: 0,\n      percentileRank: 0,\n      recentAchievements: [],\n      recommendedAchievements: []\n    };\n  }\n  \n  /**\n   * Get comprehensive player profile for cross-league display\n   */\n  async getPlayerGlobalProfile(playerId: string): Promise<{\n    basicInfo: {\n      displayName: string;\n      avatarUrl?: string;\n      preferredPosition?: string;\n      location?: string;\n    };\n    globalStats: {\n      totalGoals: number;\n      totalAssists: number;\n      totalGames: number;\n      totalMinutes: number;\n      leaguesPlayed: number;\n      achievementsEarned: number;\n    };\n    rankings: {\n      globalGoalsRank: number;\n      globalAssistsRank: number;\n      globalGamesRank: number;\n      overallRank: number;\n    };\n    leagueHistory: Array<{\n      leagueId: string;\n      leagueName: string;\n      sportType: string;\n      season: string;\n      teamName: string;\n      stats: {\n        goals: number;\n        assists: number;\n        games: number;\n        rank: number;\n      };\n    }>;\n    similarPlayers: Array<{\n      playerId: string;\n      displayName: string;\n      similarityScore: number;\n      commonLeagues: string[];\n    }>;\n  }> {\n    const { data, error } = await this.supabase.rpc('get_player_global_profile', {\n      player_id: playerId\n    });\n    \n    if (error) throw error;\n    return data;\n  }\n  \n  /**\n   * Search and filter players across all leagues\n   */\n  async searchPlayersGlobally(options: {\n    query?: string;\n    sportType?: string;\n    position?: string;\n    minGoals?: number;\n    minGames?: number;\n    leagueIds?: string[];\n    limit?: number;\n  }): Promise<Array<{\n    playerId: string;\n    displayName: string;\n    avatarUrl?: string;\n    position?: string;\n    totalGoals: number;\n    totalAssists: number;\n    totalGames: number;\n    currentLeagues: string[];\n    globalRank: number;\n  }>> {\n    const { data, error } = await this.supabase.rpc('search_players_globally', options);\n    \n    if (error) throw error;\n    return data || [];\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 4931, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/apps/player/src/lib/types/database.types.ts"],"sourcesContent":["/**\n * Database Types for MatchDay\n * \n * Generated TypeScript types for the database schema.\n * These types ensure type safety across the application.\n */\n\nexport interface Database {\n  public: {\n    Tables: {\n      user_profiles: {\n        Row: {\n          id: string;\n          full_name: string | null;\n          display_name: string | null;\n          avatar_url: string | null;\n          bio: string | null;\n          phone: string | null;\n          date_of_birth: string | null;\n          preferred_position: string | null;\n          location: string | null;\n          created_at: string;\n          updated_at: string;\n        };\n        Insert: {\n          id: string;\n          full_name?: string | null;\n          display_name?: string | null;\n          avatar_url?: string | null;\n          bio?: string | null;\n          phone?: string | null;\n          date_of_birth?: string | null;\n          preferred_position?: string | null;\n          location?: string | null;\n          created_at?: string;\n          updated_at?: string;\n        };\n        Update: {\n          id?: string;\n          full_name?: string | null;\n          display_name?: string | null;\n          avatar_url?: string | null;\n          bio?: string | null;\n          phone?: string | null;\n          date_of_birth?: string | null;\n          preferred_position?: string | null;\n          location?: string | null;\n          created_at?: string;\n          updated_at?: string;\n        };\n      };\n      leagues: {\n        Row: {\n          id: string;\n          name: string;\n          description: string | null;\n          sport_type: string;\n          league_type: string;\n          location: string | null;\n          season_start: string | null;\n          season_end: string | null;\n          max_teams: number | null;\n          entry_fee: number | null;\n          created_by: string | null;\n          is_active: boolean | null;\n          is_public: boolean | null;\n          season: string | null;\n          created_at: string;\n          updated_at: string;\n        };\n        Insert: {\n          id?: string;\n          name: string;\n          description?: string | null;\n          sport_type: string;\n          league_type: string;\n          location?: string | null;\n          season_start?: string | null;\n          season_end?: string | null;\n          max_teams?: number | null;\n          entry_fee?: number | null;\n          created_by?: string | null;\n          is_active?: boolean | null;\n          is_public?: boolean | null;\n          season?: string | null;\n          created_at?: string;\n          updated_at?: string;\n        };\n        Update: {\n          id?: string;\n          name?: string;\n          description?: string | null;\n          sport_type?: string;\n          league_type?: string;\n          location?: string | null;\n          season_start?: string | null;\n          season_end?: string | null;\n          max_teams?: number | null;\n          entry_fee?: number | null;\n          created_by?: string | null;\n          is_active?: boolean | null;\n          is_public?: boolean | null;\n          season?: string | null;\n          created_at?: string;\n          updated_at?: string;\n        };\n      };\n      teams: {\n        Row: {\n          id: string;\n          league_id: string | null;\n          name: string;\n          logo_url: string | null;\n          team_color: string | null;\n          captain_id: string | null;\n          max_players: number | null;\n          min_players: number | null;\n          is_recruiting: boolean | null;\n          team_bio: string | null;\n          is_archived: boolean | null;\n          previous_league_name: string | null;\n          created_at: string;\n          updated_at: string;\n        };\n        Insert: {\n          id?: string;\n          league_id?: string | null;\n          name: string;\n          logo_url?: string | null;\n          team_color?: string | null;\n          captain_id?: string | null;\n          max_players?: number | null;\n          min_players?: number | null;\n          is_recruiting?: boolean | null;\n          team_bio?: string | null;\n          is_archived?: boolean | null;\n          previous_league_name?: string | null;\n          created_at?: string;\n          updated_at?: string;\n        };\n        Update: {\n          id?: string;\n          league_id?: string | null;\n          name?: string;\n          logo_url?: string | null;\n          team_color?: string | null;\n          captain_id?: string | null;\n          max_players?: number | null;\n          min_players?: number | null;\n          is_recruiting?: boolean | null;\n          team_bio?: string | null;\n          is_archived?: boolean | null;\n          previous_league_name?: string | null;\n          created_at?: string;\n          updated_at?: string;\n        };\n      };\n      team_members: {\n        Row: {\n          id: string;\n          team_id: string;\n          user_id: string;\n          position: string | null;\n          jersey_number: number | null;\n          is_active: boolean | null;\n          joined_at: string;\n        };\n        Insert: {\n          id?: string;\n          team_id: string;\n          user_id: string;\n          position?: string | null;\n          jersey_number?: number | null;\n          is_active?: boolean | null;\n          joined_at?: string;\n        };\n        Update: {\n          id?: string;\n          team_id?: string;\n          user_id?: string;\n          position?: string | null;\n          jersey_number?: number | null;\n          is_active?: boolean | null;\n          joined_at?: string;\n        };\n      };\n      matches: {\n        Row: {\n          id: string;\n          league_id: string;\n          home_team_id: string;\n          away_team_id: string;\n          scheduled_date: string;\n          venue: string | null;\n          match_day: number | null;\n          status: string | null;\n          home_score: number | null;\n          away_score: number | null;\n          created_at: string;\n          updated_at: string;\n        };\n        Insert: {\n          id?: string;\n          league_id: string;\n          home_team_id: string;\n          away_team_id: string;\n          scheduled_date: string;\n          venue?: string | null;\n          match_day?: number | null;\n          status?: string | null;\n          home_score?: number | null;\n          away_score?: number | null;\n          created_at?: string;\n          updated_at?: string;\n        };\n        Update: {\n          id?: string;\n          league_id?: string;\n          home_team_id?: string;\n          away_team_id?: string;\n          scheduled_date?: string;\n          venue?: string | null;\n          match_day?: number | null;\n          status?: string | null;\n          home_score?: number | null;\n          away_score?: number | null;\n          created_at?: string;\n          updated_at?: string;\n        };\n      };\n      match_events: {\n        Row: {\n          id: string;\n          match_id: string;\n          team_id: string | null;\n          player_id: string | null;\n          event_type: string;\n          event_time: number | null;\n          description: string | null;\n          created_at: string;\n        };\n        Insert: {\n          id?: string;\n          match_id: string;\n          team_id?: string | null;\n          player_id?: string | null;\n          event_type: string;\n          event_time?: number | null;\n          description?: string | null;\n          created_at?: string;\n        };\n        Update: {\n          id?: string;\n          match_id?: string;\n          team_id?: string | null;\n          player_id?: string | null;\n          event_type?: string;\n          event_time?: number | null;\n          description?: string | null;\n          created_at?: string;\n        };\n      };\n      player_stats: {\n        Row: {\n          id: string;\n          player_id: string;\n          league_id: string;\n          team_id: string;\n          games_played: number | null;\n          goals: number | null;\n          assists: number | null;\n          yellow_cards: number | null;\n          red_cards: number | null;\n          minutes_played: number | null;\n          additional_stats: any | null;\n          updated_at: string;\n        };\n        Insert: {\n          id?: string;\n          player_id: string;\n          league_id: string;\n          team_id: string;\n          games_played?: number | null;\n          goals?: number | null;\n          assists?: number | null;\n          yellow_cards?: number | null;\n          red_cards?: number | null;\n          minutes_played?: number | null;\n          additional_stats?: any | null;\n          updated_at?: string;\n        };\n        Update: {\n          id?: string;\n          player_id?: string;\n          league_id?: string;\n          team_id?: string;\n          games_played?: number | null;\n          goals?: number | null;\n          assists?: number | null;\n          yellow_cards?: number | null;\n          red_cards?: number | null;\n          minutes_played?: number | null;\n          additional_stats?: any | null;\n          updated_at?: string;\n        };\n      };\n      team_stats: {\n        Row: {\n          id: string;\n          team_id: string;\n          league_id: string;\n          games_played: number | null;\n          wins: number | null;\n          draws: number | null;\n          losses: number | null;\n          goals_for: number | null;\n          goals_against: number | null;\n          points: number | null;\n          updated_at: string;\n        };\n        Insert: {\n          id?: string;\n          team_id: string;\n          league_id: string;\n          games_played?: number | null;\n          wins?: number | null;\n          draws?: number | null;\n          losses?: number | null;\n          goals_for?: number | null;\n          goals_against?: number | null;\n          points?: number | null;\n          updated_at?: string;\n        };\n        Update: {\n          id?: string;\n          team_id?: string;\n          league_id?: string;\n          games_played?: number | null;\n          wins?: number | null;\n          draws?: number | null;\n          losses?: number | null;\n          goals_for?: number | null;\n          goals_against?: number | null;\n          points?: number | null;\n          updated_at?: string;\n        };\n      };\n      achievements: {\n        Row: {\n          id: string;\n          name: string;\n          description: string | null;\n          icon: string | null;\n          category: string;\n          difficulty: string;\n          requirements: any;\n          points_value: number;\n          is_active: boolean;\n          is_repeatable: boolean;\n          sort_order: number;\n          created_at: string;\n        };\n        Insert: {\n          id?: string;\n          name: string;\n          description?: string | null;\n          icon?: string | null;\n          category: string;\n          difficulty?: string;\n          requirements: any;\n          points_value?: number;\n          is_active?: boolean;\n          is_repeatable?: boolean;\n          sort_order?: number;\n          created_at?: string;\n        };\n        Update: {\n          id?: string;\n          name?: string;\n          description?: string | null;\n          icon?: string | null;\n          category?: string;\n          difficulty?: string;\n          requirements?: any;\n          points_value?: number;\n          is_active?: boolean;\n          is_repeatable?: boolean;\n          sort_order?: number;\n          created_at?: string;\n        };\n      };\n      user_achievements: {\n        Row: {\n          id: string;\n          user_id: string;\n          achievement_id: string;\n          earned_at: string;\n          context: any | null;\n          league_id: string | null;\n          match_id: string | null;\n        };\n        Insert: {\n          id?: string;\n          user_id: string;\n          achievement_id: string;\n          earned_at?: string;\n          context?: any | null;\n          league_id?: string | null;\n          match_id?: string | null;\n        };\n        Update: {\n          id?: string;\n          user_id?: string;\n          achievement_id?: string;\n          earned_at?: string;\n          context?: any | null;\n          league_id?: string | null;\n          match_id?: string | null;\n        };\n      };\n      team_join_requests: {\n        Row: {\n          id: string;\n          team_id: string;\n          user_id: string;\n          message: string | null;\n          preferred_position: string | null;\n          requested_jersey_number: number | null;\n          status: string;\n          reviewed_by: string | null;\n          reviewed_at: string | null;\n          response_message: string | null;\n          created_at: string;\n          expires_at: string;\n        };\n        Insert: {\n          id?: string;\n          team_id: string;\n          user_id: string;\n          message?: string | null;\n          preferred_position?: string | null;\n          requested_jersey_number?: number | null;\n          status?: string;\n          reviewed_by?: string | null;\n          reviewed_at?: string | null;\n          response_message?: string | null;\n          created_at?: string;\n          expires_at?: string;\n        };\n        Update: {\n          id?: string;\n          team_id?: string;\n          user_id?: string;\n          message?: string | null;\n          preferred_position?: string | null;\n          requested_jersey_number?: number | null;\n          status?: string;\n          reviewed_by?: string | null;\n          reviewed_at?: string | null;\n          response_message?: string | null;\n          created_at?: string;\n          expires_at?: string;\n        };\n      };\n      app_configurations: {\n        Row: {\n          id: string;\n          value: any;\n          description: string | null;\n          is_public: boolean;\n          updated_at: string;\n          updated_by: string | null;\n        };\n        Insert: {\n          id: string;\n          value: any;\n          description?: string | null;\n          is_public?: boolean;\n          updated_at?: string;\n          updated_by?: string | null;\n        };\n        Update: {\n          id?: string;\n          value?: any;\n          description?: string | null;\n          is_public?: boolean;\n          updated_at?: string;\n          updated_by?: string | null;\n        };\n      };\n      team_invitations: {\n        Row: {\n          id: string;\n          team_id: string;\n          invited_by: string;\n          email: string | null;\n          position: string | null;\n          jersey_number: number | null;\n          message: string | null;\n          token: string;\n          status: 'pending' | 'accepted' | 'expired';\n          expires_at: string;\n          created_at: string;\n          updated_at: string;\n        };\n        Insert: {\n          id?: string;\n          team_id: string;\n          invited_by: string;\n          email?: string | null;\n          position?: string | null;\n          jersey_number?: number | null;\n          message?: string | null;\n          token?: string;\n          status?: 'pending' | 'accepted' | 'expired';\n          expires_at?: string;\n          created_at?: string;\n          updated_at?: string;\n        };\n        Update: {\n          id?: string;\n          team_id?: string;\n          invited_by?: string;\n          email?: string | null;\n          position?: string | null;\n          jersey_number?: number | null;\n          message?: string | null;\n          token?: string;\n          status?: 'pending' | 'accepted' | 'expired';\n          expires_at?: string;\n          created_at?: string;\n          updated_at?: string;\n        };\n      };\n    };\n    Views: {\n      league_standings: {\n        Row: {\n          id: string;\n          team_id: string;\n          league_id: string;\n          season_year: number;\n          games_played: number;\n          wins: number;\n          draws: number;\n          losses: number;\n          goals_for: number;\n          goals_against: number;\n          points: number;\n          clean_sheets: number;\n          team_name: string;\n          logo_url: string | null;\n          team_color: string | null;\n          league_name: string;\n          sport_type: string;\n          goal_difference: number;\n          points_percentage: number;\n          position: number;\n        };\n      };\n      player_leaderboard: {\n        Row: {\n          id: string;\n          player_id: string;\n          league_id: string;\n          team_id: string;\n          season_year: number;\n          games_played: number;\n          games_started: number;\n          goals: number;\n          assists: number;\n          yellow_cards: number;\n          red_cards: number;\n          minutes_played: number;\n          shots_on_target: number;\n          passes_completed: number;\n          passes_attempted: number;\n          tackles_won: number;\n          display_name: string;\n          avatar_url: string | null;\n          preferred_position: string | null;\n          team_name: string;\n          team_logo: string | null;\n          team_color: string | null;\n          league_name: string;\n          sport_type: string;\n          goals_per_game: number;\n          goal_contributions_per_game: number;\n          goals_per_90_minutes: number;\n          pass_accuracy: number;\n        };\n      };\n      player_cross_league_stats: {\n        Row: {\n          player_id: string;\n          display_name: string;\n          avatar_url: string | null;\n          preferred_position: string | null;\n          season_year: number;\n          leagues_played: number;\n          teams_played: number;\n          total_games_played: number;\n          total_goals: number;\n          total_assists: number;\n          total_minutes_played: number;\n          avg_goals_per_game: number;\n          avg_contributions_per_game: number;\n          best_goals_in_league: number;\n          best_assists_in_league: number;\n          goals_consistency: number | null;\n        };\n      };\n      active_matches: {\n        Row: {\n          id: string;\n          league_id: string;\n          scheduled_date: string;\n          venue: string | null;\n          status: string;\n          home_score: number;\n          away_score: number;\n          match_duration: number | null;\n          league_name: string;\n          sport_type: string;\n          home_team_id: string;\n          home_team_name: string;\n          home_team_logo: string | null;\n          home_team_color: string | null;\n          away_team_id: string;\n          away_team_name: string;\n          away_team_logo: string | null;\n          away_team_color: string | null;\n          total_events: number;\n          latest_event_type: string | null;\n          latest_event_time: number | null;\n        };\n      };\n    };\n  };\n}\n\n// Utility types for common operations\nexport type UserProfile = Database['public']['Tables']['user_profiles']['Row'];\nexport type League = Database['public']['Tables']['leagues']['Row'];\nexport type Team = Database['public']['Tables']['teams']['Row'];\nexport type TeamMember = Database['public']['Tables']['team_members']['Row'];\nexport type Match = Database['public']['Tables']['matches']['Row'];\nexport type MatchEvent = Database['public']['Tables']['match_events']['Row'];\nexport type PlayerStats = Database['public']['Tables']['player_stats']['Row'];\nexport type TeamStats = Database['public']['Tables']['team_stats']['Row'];\nexport type Achievement = Database['public']['Tables']['achievements']['Row'];\nexport type UserAchievement = Database['public']['Tables']['user_achievements']['Row'];\nexport type TeamJoinRequest = Database['public']['Tables']['team_join_requests']['Row'];\nexport type TeamInvitation = Database['public']['Tables']['team_invitations']['Row'];\nexport type AppConfiguration = Database['public']['Tables']['app_configurations']['Row'];\n\n// Insert types\nexport type InsertLeague = Database['public']['Tables']['leagues']['Insert'];\nexport type InsertTeam = Database['public']['Tables']['teams']['Insert'];\nexport type InsertMatch = Database['public']['Tables']['matches']['Insert'];\n\n// Update types\nexport type UpdateLeague = Database['public']['Tables']['leagues']['Update'];\nexport type UpdateTeam = Database['public']['Tables']['teams']['Update'];\nexport type UpdateMatch = Database['public']['Tables']['matches']['Update'];\nexport type UpdateUserProfile = Database['public']['Tables']['user_profiles']['Update'];\nexport type UpdatePlayerStats = Database['public']['Tables']['player_stats']['Update'];\n\n// View types\nexport type LeagueStanding = Database['public']['Views']['league_standings']['Row'];\nexport type PlayerLeaderboard = Database['public']['Views']['player_leaderboard']['Row'];\nexport type PlayerCrossLeagueStats = Database['public']['Views']['player_cross_league_stats']['Row'];\nexport type ActiveMatch = Database['public']['Views']['active_matches']['Row'];\n\n// Enums for type safety\nexport enum SportType {\n  FOOTBALL = 'football'\n}\n\nexport enum LeagueType {\n  COMPETITIVE = 'competitive',\n  CASUAL = 'casual',\n  TOURNAMENT = 'tournament',\n  FRIENDLY = 'friendly'\n}\n\nexport enum MatchStatus {\n  SCHEDULED = 'scheduled',\n  LIVE = 'live',\n  COMPLETED = 'completed',\n  POSTPONED = 'postponed',\n  CANCELLED = 'cancelled'\n}\n\nexport enum EventType {\n  GOAL = 'goal',\n  ASSIST = 'assist',\n  YELLOW_CARD = 'yellow_card',\n  RED_CARD = 'red_card',\n  SUBSTITUTION = 'substitution',\n  INJURY = 'injury',\n  TIMEOUT = 'timeout'\n}\n\nexport enum AchievementCategory {\n  GOALS = 'goals',\n  ASSISTS = 'assists',\n  MATCHES = 'matches',\n  TEAM_PLAY = 'team_play',\n  CONSISTENCY = 'consistency',\n  MILESTONES = 'milestones',\n  LEADERSHIP = 'leadership'\n}\n\nexport enum AchievementDifficulty {\n  BRONZE = 'bronze',\n  SILVER = 'silver',\n  GOLD = 'gold',\n  PLATINUM = 'platinum'\n}\n\nexport enum JoinRequestStatus {\n  PENDING = 'pending',\n  APPROVED = 'approved',\n  REJECTED = 'rejected',\n  WITHDRAWN = 'withdrawn'\n}\n\nexport enum InvitationStatus {\n  PENDING = 'pending',\n  ACCEPTED = 'accepted',\n  EXPIRED = 'expired'\n}\n\n// Complex types for forms and API responses\nexport interface PlayerProfile extends UserProfile {\n  teams?: Array<{\n    team: Team;\n    league: League;\n    position?: string;\n    jersey_number?: number;\n    is_active?: boolean;\n  }>;\n  stats?: PlayerStats[];\n  achievements?: Array<{\n    achievement: Achievement;\n    earned_at: string;\n    context?: any;\n  }>;\n}\n\nexport interface LeagueWithDetails extends League {\n  teams?: Team[];\n  matches?: Match[];\n  creator?: UserProfile;\n  stats?: {\n    total_teams: number;\n    total_players: number;\n    total_matches: number;\n    completed_matches: number;\n  };\n}\n\nexport interface MatchWithDetails extends Match {\n  home_team: Team;\n  away_team: Team;\n  league: League;\n  events?: MatchEvent[];\n  players?: {\n    home_players: UserProfile[];\n    away_players: UserProfile[];\n  };\n}\n\n// Form validation schemas (for use with react-hook-form + zod)\nexport interface CreateLeagueForm {\n  name: string;\n  description?: string;\n  sport_type: SportType;\n  league_type: LeagueType;\n  location?: string;\n  season_start?: string;\n  season_end?: string;\n  max_teams?: number;\n  entry_fee?: number;\n}\n\nexport interface CreateTeamForm {\n  name: string;\n  league_id: string;\n  sport: string;\n  league: string;\n  description?: string;\n  max_players?: number;\n  min_players?: number;\n  location?: string;\n  team_color?: string;\n}\n\nexport interface JoinTeamForm {\n  team_id: string;\n  position?: string;\n  jersey_number?: number;\n}\n\nexport interface UpdateProfileForm {\n  display_name: string;\n  bio?: string;\n  preferred_position?: string;\n  location?: string;\n  date_of_birth?: string;\n}\n\nexport interface SendInvitationForm {\n  email: string;\n  position?: string;\n  jersey_number?: number;\n  message?: string;\n}\n\n// API Response types\nexport interface ApiResponse<T = any> {\n  data: T;\n  error?: string;\n  message?: string;\n}\n\nexport interface PaginatedResponse<T = any> {\n  data: T[];\n  count: number;\n  page: number;\n  per_page: number;\n  total_pages: number;\n}\n\n// Real-time types for live features\nexport interface LiveMatchUpdate {\n  match_id: string;\n  event_type: EventType;\n  event_time: number;\n  player_id?: string;\n  team_id?: string;\n  description?: string;\n  score_update?: {\n    home_score: number;\n    away_score: number;\n  };\n}\n\nexport interface PlayerStatsSummary {\n  player_id: string;\n  total_goals: number;\n  total_assists: number;\n  total_matches: number;\n  total_minutes: number;\n  goals_per_game: number;\n  current_league_stats?: PlayerStats;\n}\n\n// Cross-league comparison types\nexport interface CrossLeaguePlayerStats {\n  player_id: string;\n  player_name: string;\n  leagues: Array<{\n    league: League;\n    stats: PlayerStats;\n    team: Team;\n  }>;\n  overall_stats: PlayerStatsSummary;\n}\n\n// Service Response Types\nexport interface ServiceResponse<T = any> {\n  data: T | null;\n  error: ServiceError | null;\n  success: boolean;\n  message?: string;\n}\n\nexport interface ServiceError {\n  code: string;\n  message: string;\n  details?: any;\n  timestamp: string;\n}\n\nexport interface PaginatedServiceResponse<T = any> extends ServiceResponse<T[]> {\n  pagination?: {\n    page: number;\n    limit: number;\n    total: number;\n    totalPages: number;\n    hasNext: boolean;\n    hasPrevious: boolean;\n  };\n}\n\n// Player Service Types\nexport interface PlayerProfileExtended extends UserProfile {\n  teams: Array<{\n    team: Team & { league: League };\n    membership: TeamMember;\n  }>;\n  achievements: Array<{\n    achievement: Achievement;\n    userAchievement: UserAchievement;\n  }>;\n  crossLeagueStats: PlayerCrossLeagueStats | null;\n  globalRankings: {\n    goals: { rank: number; total: number; percentile: number } | null;\n    assists: { rank: number; total: number; percentile: number } | null;\n    matches: { rank: number; total: number; percentile: number } | null;\n  };\n}\n\n// League Service Types\nexport interface LeagueDiscovery extends League {\n  teams: Team[];\n  teamCount: number;\n  playerCount: number;\n  availableSpots: number;\n  joinRequests?: TeamJoinRequest[];\n  isUserMember: boolean;\n  compatibilityScore?: number;\n}\n\nexport interface LeagueFilters {\n  sportType?: SportType;\n  leagueType?: LeagueType;\n  location?: string;\n  maxDistance?: number;\n  entryFeeMax?: number;\n  hasAvailableSpots?: boolean;\n  seasonActive?: boolean;\n  search?: string;\n}\n\n// Match Service Types\nexport interface MatchWithDetails extends Match {\n  homeTeam: Team;\n  awayTeam: Team;\n  league: League;\n  events: MatchEvent[];\n  homeTeamPlayers: UserProfile[];\n  awayTeamPlayers: UserProfile[];\n  playerStats?: Array<{\n    player: UserProfile;\n    stats: {\n      goals: number;\n      assists: number;\n      cards: number;\n      minutesPlayed: number;\n    };\n  }>;\n}\n\nexport interface LiveMatchData {\n  match: MatchWithDetails;\n  recentEvents: MatchEvent[];\n  liveStats: {\n    homeTeamStats: { [key: string]: number };\n    awayTeamStats: { [key: string]: number };\n    playerStats: { [playerId: string]: any };\n  };\n}\n\n// Achievement Service Types\nexport interface PlayerAchievementProgress {\n  achievement: Achievement;\n  currentProgress: number;\n  targetValue: number;\n  progressPercentage: number;\n  isCompleted: boolean;\n  estimatedCompletion?: string;\n  nextMilestone?: number;\n}\n\nexport interface AchievementBadge {\n  id: string;\n  name: string;\n  description: string;\n  icon: string;\n  category: AchievementCategory;\n  difficulty: AchievementDifficulty;\n  earnedAt?: string;\n  context?: any;\n  rarity: {\n    totalEarned: number;\n    totalPlayers: number;\n    rarityPercentage: number;\n  };\n}\n\n// Stats Service Types\nexport interface PerformanceTrend {\n  period: string; // YYYY-MM or YYYY-WW\n  goals: number;\n  assists: number;\n  matches: number;\n  performance: number;\n}\n\nexport interface GlobalRanking {\n  playerId: string;\n  displayName: string;\n  avatarUrl?: string;\n  rank: number;\n  statValue: number;\n  trend: 'up' | 'down' | 'stable';\n  previousRank?: number;\n}\n\nexport interface LeagueComparison {\n  league: League;\n  playerStats: PlayerStats;\n  teamRank: number;\n  leagueRank: number;\n  performance: {\n    goalsPerGame: number;\n    assistsPerGame: number;\n    winRate: number;\n    consistency: number;\n  };\n}\n\n// Real-time Subscription Types\nexport interface RealtimeSubscriptionOptions {\n  table: string;\n  filter?: string;\n  event?: 'INSERT' | 'UPDATE' | 'DELETE' | '*';\n  schema?: string;\n}\n\nexport interface CacheOptions {\n  ttl?: number; // Time to live in seconds\n  key?: string;\n  tags?: string[];\n  revalidateOnBackground?: boolean;\n}"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;;;;;;;AA8pBM,IAAA,AAAK,mCAAA;;WAAA;;AAIL,IAAA,AAAK,oCAAA;;;;;WAAA;;AAOL,IAAA,AAAK,qCAAA;;;;;;WAAA;;AAQL,IAAA,AAAK,mCAAA;;;;;;;;WAAA;;AAUL,IAAA,AAAK,6CAAA;;;;;;;;WAAA;;AAUL,IAAA,AAAK,+CAAA;;;;;WAAA;;AAOL,IAAA,AAAK,2CAAA;;;;;WAAA;;AAOL,IAAA,AAAK,0CAAA;;;;WAAA","debugId":null}},
    {"offset": {"line": 5014, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/achievement.service.ts"],"sourcesContent":["/**\n * Achievement Service for MatchDay\n * \n * Handles comprehensive achievement and gamification operations with focus on:\n * - Player achievements and progress tracking\n * - Badge system and rarity calculations\n * - Cross-league milestone tracking\n * - Achievement recommendation system\n * \n * Optimized for motivating player engagement through gamification\n */\n\nimport { SupabaseClient } from '@supabase/supabase-js';\nimport {\n  Database,\n  Achievement,\n  UserAchievement,\n  AchievementBadge,\n  PlayerAchievementProgress,\n  ServiceResponse,\n  ServiceError,\n  PaginatedServiceResponse,\n  AchievementCategory,\n  AchievementDifficulty,\n  CacheOptions,\n  RealtimeSubscriptionOptions\n} from '@/lib/types/database.types';\n\nexport interface AchievementFilters {\n  category?: AchievementCategory;\n  difficulty?: AchievementDifficulty;\n  isActive?: boolean;\n  earned?: boolean;\n  inProgress?: boolean;\n  search?: string;\n}\n\nexport interface AchievementStats {\n  totalAchievements: number;\n  earnedAchievements: number;\n  totalPoints: number;\n  earnedPoints: number;\n  completionPercentage: number;\n  categoryProgress: {\n    [key in AchievementCategory]: {\n      total: number;\n      earned: number;\n      points: number;\n      percentage: number;\n    };\n  };\n  difficultyProgress: {\n    [key in AchievementDifficulty]: {\n      total: number;\n      earned: number;\n      points: number;\n    };\n  };\n  recentAchievements: UserAchievement[];\n  nextMilestones: PlayerAchievementProgress[];\n}\n\nexport interface AchievementRecommendation {\n  achievement: Achievement;\n  priority: number;\n  reasonCode: 'close_to_completion' | 'category_focus' | 'difficulty_progression' | 'seasonal_bonus';\n  reason: string;\n  estimatedEffort: 'low' | 'medium' | 'high';\n  estimatedTimeToComplete: string;\n  tips: string[];\n}\n\nexport interface LeaderboardEntry {\n  playerId: string;\n  playerName: string;\n  avatarUrl?: string;\n  totalPoints: number;\n  totalAchievements: number;\n  recentAchievements: number;\n  rank: number;\n  trend: 'up' | 'down' | 'stable';\n}\n\nexport class AchievementService {\n  private static instance: AchievementService;\n  private supabase: SupabaseClient<Database>;\n  private cache = new Map<string, { data: any; timestamp: number; ttl: number }>();\n\n  private constructor(supabaseClient: SupabaseClient<Database>) {\n    this.supabase = supabaseClient;\n  }\n\n  static getInstance(supabaseClient?: SupabaseClient<Database>): AchievementService {\n    if (!AchievementService.instance) {\n      if (!supabaseClient) {\n        throw new Error('SupabaseClient required for first initialization');\n      }\n      AchievementService.instance = new AchievementService(supabaseClient);\n    }\n    return AchievementService.instance;\n  }\n\n  /**\n   * Handle service errors consistently\n   */\n  private handleError(error: any, operation: string): ServiceError {\n    console.error(`AchievementService.${operation}:`, error);\n    return {\n      code: error.code || 'UNKNOWN_ERROR',\n      message: error.message || 'An unexpected error occurred',\n      details: error.details || error,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Cache management utilities\n   */\n  private getCacheKey(operation: string, params: any): string {\n    return `achievement_service:${operation}:${JSON.stringify(params)}`;\n  }\n\n  private getFromCache<T>(key: string): T | null {\n    const cached = this.cache.get(key);\n    if (!cached) return null;\n    \n    if (Date.now() - cached.timestamp > cached.ttl * 1000) {\n      this.cache.delete(key);\n      return null;\n    }\n    \n    return cached.data as T;\n  }\n\n  private setCache<T>(key: string, data: T, ttl = 600): void {\n    this.cache.set(key, {\n      data,\n      timestamp: Date.now(),\n      ttl\n    });\n  }\n\n  /**\n   * Get comprehensive achievement statistics for a player\n   */\n  async getPlayerAchievementStats(\n    userId: string,\n    options: CacheOptions = {}\n  ): Promise<ServiceResponse<AchievementStats>> {\n    try {\n      const cacheKey = this.getCacheKey('getPlayerAchievementStats', { userId });\n      const cached = this.getFromCache<AchievementStats>(cacheKey);\n      \n      if (cached && !options.revalidateOnBackground) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Get all achievements\n      const { data: allAchievements, error: achievementsError } = await this.supabase\n        .from('achievements')\n        .select('*')\n        .eq('is_active', true)\n        .order('sort_order');\n\n      if (achievementsError) throw achievementsError;\n\n      // Get user's earned achievements\n      const { data: userAchievements, error: userError } = await this.supabase\n        .from('user_achievements')\n        .select(`\n          *,\n          achievement:achievements!inner(*)\n        `)\n        .eq('user_id', userId)\n        .order('earned_at', { ascending: false });\n\n      if (userError) throw userError;\n\n      // Get player stats for progress calculation\n      const { data: playerStats } = await this.supabase\n        .from('player_cross_league_stats')\n        .select('*')\n        .eq('player_id', userId)\n        .eq('season_year', new Date().getFullYear())\n        .single();\n\n      const totalAchievements = allAchievements?.length || 0;\n      const earnedAchievements = userAchievements?.length || 0;\n      const totalPoints = allAchievements?.reduce((sum, a) => sum + a.points_value, 0) || 0;\n      const earnedPoints = userAchievements?.reduce((sum, ua) => sum + ua.achievement.points_value, 0) || 0;\n\n      // Calculate category progress\n      const categoryProgress = this.calculateCategoryProgress(allAchievements || [], userAchievements || []);\n      \n      // Calculate difficulty progress\n      const difficultyProgress = this.calculateDifficultyProgress(allAchievements || [], userAchievements || []);\n\n      // Get recent achievements (last 30 days)\n      const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n      const recentAchievements = userAchievements?.filter(\n        ua => new Date(ua.earned_at) >= thirtyDaysAgo\n      ) || [];\n\n      // Calculate next milestones\n      const nextMilestones = this.calculateNextMilestones(\n        allAchievements || [],\n        userAchievements || [],\n        playerStats\n      );\n\n      const stats: AchievementStats = {\n        totalAchievements,\n        earnedAchievements,\n        totalPoints,\n        earnedPoints,\n        completionPercentage: totalAchievements > 0 ? Math.round((earnedAchievements / totalAchievements) * 100) : 0,\n        categoryProgress,\n        difficultyProgress,\n        recentAchievements,\n        nextMilestones\n      };\n\n      // Cache for 5 minutes\n      this.setCache(cacheKey, stats, options.ttl || 300);\n\n      return { data: stats, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerAchievementStats'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get player's achievement badges with rarity information\n   */\n  async getPlayerAchievementBadges(\n    userId: string,\n    filters: AchievementFilters = {},\n    options: { limit?: number; offset?: number } = {}\n  ): Promise<PaginatedServiceResponse<AchievementBadge>> {\n    try {\n      // Build query for user achievements\n      let query = this.supabase\n        .from('user_achievements')\n        .select(`\n          *,\n          achievement:achievements!inner(*)\n        `, { count: 'exact' })\n        .eq('user_id', userId);\n\n      if (filters.category) {\n        query = query.eq('achievement.category', filters.category);\n      }\n\n      if (filters.difficulty) {\n        query = query.eq('achievement.difficulty', filters.difficulty);\n      }\n\n      if (filters.search) {\n        query = query.ilike('achievement.name', `%${filters.search}%`);\n      }\n\n      const { data: userAchievements, error, count } = await query\n        .order('earned_at', { ascending: false })\n        .range(options.offset || 0, (options.offset || 0) + (options.limit || 20) - 1);\n\n      if (error) throw error;\n\n      // Calculate rarity for each achievement\n      const badges: AchievementBadge[] = await Promise.all(\n        (userAchievements || []).map(async (ua) => {\n          const rarity = await this.calculateAchievementRarity(ua.achievement_id);\n          \n          return {\n            id: ua.achievement.id,\n            name: ua.achievement.name,\n            description: ua.achievement.description || '',\n            icon: ua.achievement.icon || '',\n            category: ua.achievement.category as AchievementCategory,\n            difficulty: ua.achievement.difficulty as AchievementDifficulty,\n            earnedAt: ua.earned_at,\n            context: ua.context,\n            rarity: rarity.data || {\n              totalEarned: 0,\n              totalPlayers: 1,\n              rarityPercentage: 100\n            }\n          };\n        })\n      );\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n        limit: options.limit || 20,\n        total: count || 0,\n        totalPages: Math.ceil((count || 0) / (options.limit || 20)),\n        hasNext: ((options.offset || 0) + (options.limit || 20)) < (count || 0),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: badges,\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getPlayerAchievementBadges'),\n        success: false,\n        pagination: {\n          page: 1,\n          limit: options.limit || 20,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrevious: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Get achievement progress tracking with detailed metrics\n   */\n  async getAchievementProgress(\n    userId: string,\n    filters: AchievementFilters = {},\n    options: { limit?: number; offset?: number } = {}\n  ): Promise<PaginatedServiceResponse<PlayerAchievementProgress>> {\n    try {\n      // Get all available achievements\n      let query = this.supabase\n        .from('achievements')\n        .select('*', { count: 'exact' })\n        .eq('is_active', true);\n\n      if (filters.category) {\n        query = query.eq('category', filters.category);\n      }\n\n      if (filters.difficulty) {\n        query = query.eq('difficulty', filters.difficulty);\n      }\n\n      if (filters.search) {\n        query = query.ilike('name', `%${filters.search}%`);\n      }\n\n      const { data: achievements, error, count } = await query\n        .order('sort_order')\n        .range(options.offset || 0, (options.offset || 0) + (options.limit || 50) - 1);\n\n      if (error) throw error;\n\n      // Get user's earned achievements\n      const { data: userAchievements, error: userError } = await this.supabase\n        .from('user_achievements')\n        .select('achievement_id, earned_at')\n        .eq('user_id', userId);\n\n      if (userError) throw userError;\n\n      // Get player stats for progress calculation\n      const { data: playerStats } = await this.supabase\n        .from('player_cross_league_stats')\n        .select('*')\n        .eq('player_id', userId)\n        .eq('season_year', new Date().getFullYear())\n        .single();\n\n      const earnedAchievementIds = new Set(userAchievements?.map(ua => ua.achievement_id) || []);\n\n      // Calculate progress for each achievement\n      const achievementProgress: PlayerAchievementProgress[] = (achievements || [])\n        .map(achievement => {\n          const isCompleted = earnedAchievementIds.has(achievement.id);\n          \n          if (isCompleted) {\n            return {\n              achievement,\n              currentProgress: 1,\n              targetValue: 1,\n              progressPercentage: 100,\n              isCompleted: true\n            };\n          }\n\n          // Calculate progress based on requirements\n          const progress = this.calculateAchievementProgress(achievement, playerStats);\n          return {\n            achievement,\n            currentProgress: progress.current,\n            targetValue: progress.target,\n            progressPercentage: progress.percentage,\n            isCompleted: false,\n            estimatedCompletion: progress.estimatedCompletion,\n            nextMilestone: progress.nextMilestone\n          };\n        });\n\n      // Apply filters\n      let filteredProgress = achievementProgress;\n      \n      if (filters.earned === true) {\n        filteredProgress = filteredProgress.filter(ap => ap.isCompleted);\n      } else if (filters.earned === false) {\n        filteredProgress = filteredProgress.filter(ap => !ap.isCompleted);\n      }\n\n      if (filters.inProgress === true) {\n        filteredProgress = filteredProgress.filter(ap => \n          !ap.isCompleted && ap.progressPercentage > 0\n        );\n      }\n\n      // Sort by progress percentage (closest to completion first)\n      filteredProgress.sort((a, b) => {\n        if (a.isCompleted && !b.isCompleted) return 1;\n        if (!a.isCompleted && b.isCompleted) return -1;\n        return b.progressPercentage - a.progressPercentage;\n      });\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 50)) + 1,\n        limit: options.limit || 50,\n        total: count || 0,\n        totalPages: Math.ceil((count || 0) / (options.limit || 50)),\n        hasNext: ((options.offset || 0) + (options.limit || 50)) < (count || 0),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: filteredProgress,\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getAchievementProgress'),\n        success: false,\n        pagination: {\n          page: 1,\n          limit: options.limit || 50,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrevious: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Get personalized achievement recommendations\n   */\n  async getAchievementRecommendations(\n    userId: string,\n    options: { limit?: number; focusCategory?: AchievementCategory } = {}\n  ): Promise<ServiceResponse<AchievementRecommendation[]>> {\n    try {\n      const cacheKey = this.getCacheKey('getAchievementRecommendations', { userId, options });\n      const cached = this.getFromCache<AchievementRecommendation[]>(cacheKey);\n      \n      if (cached) {\n        return { data: cached, error: null, success: true };\n      }\n\n      // Get player's achievement progress\n      const progressResponse = await this.getAchievementProgress(userId, {\n        earned: false\n      });\n\n      if (!progressResponse.success || !progressResponse.data) {\n        throw new Error('Failed to get achievement progress');\n      }\n\n      const progress = progressResponse.data;\n      \n      // Get player stats for context\n      const { data: playerStats } = await this.supabase\n        .from('player_cross_league_stats')\n        .select('*')\n        .eq('player_id', userId)\n        .eq('season_year', new Date().getFullYear())\n        .single();\n\n      // Generate recommendations\n      const recommendations: AchievementRecommendation[] = progress\n        .filter(ap => !ap.isCompleted)\n        .map(ap => this.generateRecommendation(ap, playerStats))\n        .sort((a, b) => b.priority - a.priority)\n        .slice(0, options.limit || 10);\n\n      // Cache for 30 minutes\n      this.setCache(cacheKey, recommendations, 1800);\n\n      return { data: recommendations, error: null, success: true };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getAchievementRecommendations'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Get achievement leaderboard\n   */\n  async getAchievementLeaderboard(\n    options: {\n      period?: 'all_time' | 'monthly' | 'weekly';\n      category?: AchievementCategory;\n      limit?: number;\n      offset?: number;\n    } = {}\n  ): Promise<PaginatedServiceResponse<LeaderboardEntry>> {\n    try {\n      const cacheKey = this.getCacheKey('getAchievementLeaderboard', { options });\n      const cached = this.getFromCache<LeaderboardEntry[]>(cacheKey);\n      \n      if (cached) {\n        return {\n          data: cached,\n          error: null,\n          success: true,\n          pagination: {\n            page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n            limit: options.limit || 20,\n            total: cached.length,\n            totalPages: Math.ceil(cached.length / (options.limit || 20)),\n            hasNext: false,\n            hasPrevious: false\n          }\n        };\n      }\n\n      // Build query based on period\n      let dateFilter = '';\n      if (options.period === 'monthly') {\n        const monthAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);\n        dateFilter = `and earned_at >= '${monthAgo.toISOString()}'`;\n      } else if (options.period === 'weekly') {\n        const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);\n        dateFilter = `and earned_at >= '${weekAgo.toISOString()}'`;\n      }\n\n      // Use RPC function for complex leaderboard calculation\n      const { data: leaderboard, error } = await this.supabase\n        .rpc('get_achievement_leaderboard', {\n          date_filter: dateFilter,\n          category_filter: options.category || null,\n          limit_count: options.limit || 50,\n          offset_count: options.offset || 0\n        });\n\n      if (error) throw error;\n\n      const leaderboardEntries: LeaderboardEntry[] = (leaderboard || []).map((entry, index) => ({\n        playerId: entry.player_id,\n        playerName: entry.player_name,\n        avatarUrl: entry.avatar_url,\n        totalPoints: entry.total_points,\n        totalAchievements: entry.total_achievements,\n        recentAchievements: entry.recent_achievements || 0,\n        rank: (options.offset || 0) + index + 1,\n        trend: 'stable' as const // Would need historical data to calculate trend\n      }));\n\n      // Cache for 10 minutes\n      this.setCache(cacheKey, leaderboardEntries, 600);\n\n      const pagination = {\n        page: Math.floor((options.offset || 0) / (options.limit || 20)) + 1,\n        limit: options.limit || 20,\n        total: leaderboardEntries.length,\n        totalPages: Math.ceil(leaderboardEntries.length / (options.limit || 20)),\n        hasNext: leaderboardEntries.length === (options.limit || 20),\n        hasPrevious: (options.offset || 0) > 0\n      };\n\n      return {\n        data: leaderboardEntries,\n        error: null,\n        success: true,\n        pagination\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'getAchievementLeaderboard'),\n        success: false,\n        pagination: {\n          page: 1,\n          limit: options.limit || 20,\n          total: 0,\n          totalPages: 0,\n          hasNext: false,\n          hasPrevious: false\n        }\n      };\n    }\n  }\n\n  /**\n   * Calculate achievement rarity\n   */\n  async calculateAchievementRarity(\n    achievementId: string\n  ): Promise<ServiceResponse<{\n    totalEarned: number;\n    totalPlayers: number;\n    rarityPercentage: number;\n  }>> {\n    try {\n      const { data, error } = await this.supabase\n        .rpc('calculate_achievement_rarity', { achievement_id: achievementId });\n\n      if (error) throw error;\n\n      return {\n        data: data || { totalEarned: 0, totalPlayers: 1, rarityPercentage: 100 },\n        error: null,\n        success: true\n      };\n\n    } catch (error) {\n      return {\n        data: null,\n        error: this.handleError(error, 'calculateAchievementRarity'),\n        success: false\n      };\n    }\n  }\n\n  /**\n   * Private helper methods\n   */\n  private calculateCategoryProgress(\n    allAchievements: Achievement[],\n    userAchievements: Array<{ achievement: Achievement }>\n  ) {\n    const categories = Object.values(AchievementCategory);\n    const result: any = {};\n\n    categories.forEach(category => {\n      const categoryAchievements = allAchievements.filter(a => a.category === category);\n      const earnedCategoryAchievements = userAchievements.filter(ua => ua.achievement.category === category);\n      \n      result[category] = {\n        total: categoryAchievements.length,\n        earned: earnedCategoryAchievements.length,\n        points: earnedCategoryAchievements.reduce((sum, ua) => sum + ua.achievement.points_value, 0),\n        percentage: categoryAchievements.length > 0 \n          ? Math.round((earnedCategoryAchievements.length / categoryAchievements.length) * 100) \n          : 0\n      };\n    });\n\n    return result;\n  }\n\n  private calculateDifficultyProgress(\n    allAchievements: Achievement[],\n    userAchievements: Array<{ achievement: Achievement }>\n  ) {\n    const difficulties = Object.values(AchievementDifficulty);\n    const result: any = {};\n\n    difficulties.forEach(difficulty => {\n      const difficultyAchievements = allAchievements.filter(a => a.difficulty === difficulty);\n      const earnedDifficultyAchievements = userAchievements.filter(ua => ua.achievement.difficulty === difficulty);\n      \n      result[difficulty] = {\n        total: difficultyAchievements.length,\n        earned: earnedDifficultyAchievements.length,\n        points: earnedDifficultyAchievements.reduce((sum, ua) => sum + ua.achievement.points_value, 0)\n      };\n    });\n\n    return result;\n  }\n\n  private calculateNextMilestones(\n    allAchievements: Achievement[],\n    userAchievements: Array<{ achievement: Achievement }>,\n    playerStats: any\n  ): PlayerAchievementProgress[] {\n    const earnedIds = new Set(userAchievements.map(ua => ua.achievement.id));\n    \n    return allAchievements\n      .filter(a => !earnedIds.has(a.id))\n      .map(achievement => {\n        const progress = this.calculateAchievementProgress(achievement, playerStats);\n        return {\n          achievement,\n          currentProgress: progress.current,\n          targetValue: progress.target,\n          progressPercentage: progress.percentage,\n          isCompleted: false,\n          estimatedCompletion: progress.estimatedCompletion,\n          nextMilestone: progress.nextMilestone\n        };\n      })\n      .filter(ap => ap.progressPercentage > 0)\n      .sort((a, b) => b.progressPercentage - a.progressPercentage)\n      .slice(0, 5);\n  }\n\n  private calculateAchievementProgress(achievement: Achievement, playerStats: any) {\n    const requirements = achievement.requirements as any;\n    let current = 0;\n    let target = 1;\n\n    if (requirements.goals && playerStats) {\n      current = playerStats.total_goals || 0;\n      target = requirements.goals;\n    } else if (requirements.assists && playerStats) {\n      current = playerStats.total_assists || 0;\n      target = requirements.assists;\n    } else if (requirements.matches_played && playerStats) {\n      current = playerStats.total_games_played || 0;\n      target = requirements.matches_played;\n    } else if (requirements.leagues_played && playerStats) {\n      current = playerStats.leagues_played || 0;\n      target = requirements.leagues_played;\n    }\n\n    const percentage = target > 0 ? Math.min(100, Math.round((current / target) * 100)) : 0;\n    \n    // Estimate completion time based on current progress\n    let estimatedCompletion: string | undefined;\n    if (current > 0 && percentage < 100) {\n      const remaining = target - current;\n      const rate = current / Math.max(playerStats?.total_games_played || 1, 1);\n      const estimatedGames = remaining / Math.max(rate, 0.1);\n      \n      if (estimatedGames <= 5) {\n        estimatedCompletion = 'Within 5 games';\n      } else if (estimatedGames <= 10) {\n        estimatedCompletion = 'Within 10 games';\n      } else {\n        estimatedCompletion = 'Long term goal';\n      }\n    }\n\n    return {\n      current,\n      target,\n      percentage,\n      estimatedCompletion,\n      nextMilestone: current > 0 ? Math.ceil(current * 1.2) : Math.ceil(target * 0.2)\n    };\n  }\n\n  private generateRecommendation(\n    progress: PlayerAchievementProgress,\n    playerStats: any\n  ): AchievementRecommendation {\n    let priority = 0;\n    let reasonCode: AchievementRecommendation['reasonCode'] = 'category_focus';\n    let reason = '';\n    let estimatedEffort: AchievementRecommendation['estimatedEffort'] = 'medium';\n    let estimatedTimeToComplete = 'Unknown';\n    const tips: string[] = [];\n\n    // Calculate priority based on progress percentage\n    if (progress.progressPercentage >= 80) {\n      priority = 90;\n      reasonCode = 'close_to_completion';\n      reason = 'You\\'re very close to earning this achievement!';\n      estimatedEffort = 'low';\n      estimatedTimeToComplete = 'Very soon';\n    } else if (progress.progressPercentage >= 50) {\n      priority = 70;\n      reasonCode = 'close_to_completion';\n      reason = 'You\\'re halfway there - keep it up!';\n      estimatedEffort = 'medium';\n      estimatedTimeToComplete = 'Medium term';\n    } else if (progress.progressPercentage >= 25) {\n      priority = 50;\n      reasonCode = 'category_focus';\n      reason = 'Good progress in this category';\n      estimatedEffort = 'medium';\n      estimatedTimeToComplete = 'Medium term';\n    } else {\n      priority = 30;\n      reasonCode = 'difficulty_progression';\n      reason = 'A good challenge to work towards';\n      estimatedEffort = 'high';\n      estimatedTimeToComplete = 'Long term';\n    }\n\n    // Add difficulty bonus\n    switch (progress.achievement.difficulty) {\n      case 'bronze':\n        priority += 10;\n        break;\n      case 'silver':\n        priority += 5;\n        break;\n      case 'gold':\n        priority -= 5;\n        break;\n      case 'platinum':\n        priority -= 10;\n        break;\n    }\n\n    // Generate tips based on achievement requirements\n    const requirements = progress.achievement.requirements as any;\n    if (requirements.goals) {\n      tips.push('Focus on creating scoring opportunities');\n      tips.push('Practice shooting accuracy in training');\n    } else if (requirements.assists) {\n      tips.push('Look for teammates in better positions');\n      tips.push('Improve your passing accuracy');\n    } else if (requirements.matches_played) {\n      tips.push('Stay active in your leagues');\n      tips.push('Consistency is key for this achievement');\n    }\n\n    return {\n      achievement: progress.achievement,\n      priority: Math.max(0, Math.min(100, priority)),\n      reasonCode,\n      reason,\n      estimatedEffort,\n      estimatedTimeToComplete,\n      tips\n    };\n  }\n\n  /**\n   * Subscribe to real-time achievement updates\n   */\n  subscribeToAchievementUpdates(\n    userId: string,\n    callback: (payload: any) => void,\n    options: RealtimeSubscriptionOptions = { table: 'user_achievements', event: '*' }\n  ) {\n    return this.supabase\n      .channel(`achievements-${userId}-updates`)\n      .on(\n        'postgres_changes',\n        {\n          event: options.event,\n          schema: options.schema || 'public',\n          table: options.table,\n          filter: options.filter || `user_id=eq.${userId}`\n        },\n        callback\n      )\n      .subscribe();\n  }\n\n  /**\n   * Clear cache\n   */\n  clearCache(pattern?: string): void {\n    if (!pattern) {\n      this.cache.clear();\n      return;\n    }\n\n    const keys = Array.from(this.cache.keys());\n    keys.forEach(key => {\n      if (key.includes(pattern)) {\n        this.cache.delete(key);\n      }\n    });\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 5658, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/edge-functions.service.ts"],"sourcesContent":["/**\n * Edge Functions Service for MatchDay\n * \n * Handles ALL server communication following the LEVER principle of server-side authority.\n * ALL business logic operations MUST go through Edge Functions to maintain data integrity,\n * security, and proper audit logging.\n * \n * @example\n * ```typescript\n * const result = await EdgeFunctionsService.getInstance().createLeague(leagueData);\n * const match = await EdgeFunctionsService.getInstance().recordMatchResult(matchData);\n * ```\n * \n * This service should be used for ALL write operations and complex business logic.\n */\n\nexport interface EdgeFunctionResponse<T = any> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  auditLogId?: string;\n}\n\nexport class EdgeFunctionsService {\n  private static instance: EdgeFunctionsService;\n  private supabase: any; // Will be injected\n  \n  private constructor() {}\n  \n  static getInstance(): EdgeFunctionsService {\n    if (!EdgeFunctionsService.instance) {\n      EdgeFunctionsService.instance = new EdgeFunctionsService();\n    }\n    return EdgeFunctionsService.instance;\n  }\n  \n  setSupabaseClient(client: any) {\n    this.supabase = client;\n  }\n  \n  private async invokeFunction<T>(\n    functionName: string, \n    payload: any\n  ): Promise<EdgeFunctionResponse<T>> {\n    try {\n      const { data, error } = await this.supabase.functions.invoke(functionName, {\n        body: payload\n      });\n      \n      if (error) {\n        throw error;\n      }\n      \n      return data;\n    } catch (error) {\n      console.error(`Edge function ${functionName} failed:`, error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error occurred'\n      };\n    }\n  }\n  \n  // League Management\n  async createLeague(leagueData: {\n    name: string;\n    description?: string;\n    sport_type: string;\n    league_type: string;\n    location?: string;\n    season_start: string;\n    season_end: string;\n    max_teams: number;\n    entry_fee?: number;\n  }): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('create-league', leagueData);\n  }\n  \n  async updateLeague(leagueId: string, updates: any): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('update-league', { leagueId, updates });\n  }\n  \n  async deleteLeague(leagueId: string): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('delete-league', { leagueId });\n  }\n  \n  // Team Management\n  async createTeam(teamData: {\n    league_id: string;\n    name: string;\n    logo_url?: string;\n    team_color?: string;\n  }): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('create-team', teamData);\n  }\n  \n  async joinTeam(teamId: string, playerData: {\n    position?: string;\n    jersey_number?: number;\n  }): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('join-team', { teamId, ...playerData });\n  }\n  \n  async leaveTeam(teamId: string): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('leave-team', { teamId });\n  }\n  \n  async updateTeamMember(teamId: string, userId: string, updates: {\n    position?: string;\n    jersey_number?: number;\n    is_active?: boolean;\n  }): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('update-team-member', { teamId, userId, updates });\n  }\n  \n  // Match Management\n  async createMatch(matchData: {\n    league_id: string;\n    home_team_id: string;\n    away_team_id: string;\n    scheduled_date: string;\n    venue?: string;\n    match_day?: number;\n  }): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('create-match', matchData);\n  }\n  \n  async recordMatchResult(matchId: string, result: {\n    home_score: number;\n    away_score: number;\n    events?: Array<{\n      team_id: string;\n      player_id: string;\n      event_type: string;\n      event_time: number;\n      description?: string;\n    }>;\n  }): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('record-match-result', { matchId, ...result });\n  }\n  \n  async updateMatchStatus(matchId: string, status: string): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('update-match-status', { matchId, status });\n  }\n  \n  // Statistics & Achievements\n  async recalculatePlayerStats(playerId: string, leagueId?: string): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('recalculate-player-stats', { playerId, leagueId });\n  }\n  \n  async recalculateTeamStats(teamId: string): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('recalculate-team-stats', { teamId });\n  }\n  \n  async checkAchievements(userId: string, context?: any): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('check-achievements', { userId, context });\n  }\n  \n  // Schedule Generation\n  async generateLeagueSchedule(leagueId: string, options?: {\n    rounds?: number;\n    start_date?: string;\n    days_between_matches?: number;\n  }): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('generate-schedule', { leagueId, options });\n  }\n  \n  // Batch Operations\n  async importPlayers(teamId: string, players: Array<{\n    email: string;\n    display_name: string;\n    position?: string;\n    jersey_number?: number;\n  }>): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('import-players', { teamId, players });\n  }\n  \n  async bulkCreateMatches(matches: Array<{\n    league_id: string;\n    home_team_id: string;\n    away_team_id: string;\n    scheduled_date: string;\n    venue?: string;\n    match_day?: number;\n  }>): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('bulk-create-matches', { matches });\n  }\n  \n  // User Profile\n  async updateUserProfile(updates: {\n    display_name?: string;\n    avatar_url?: string;\n    preferred_position?: string;\n    bio?: string;\n    date_of_birth?: string;\n    location?: string;\n  }): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('update-user-profile', updates);\n  }\n  \n  // Cross-League Analytics\n  async getCrossLeagueStats(userId: string): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('get-cross-league-stats', { userId });\n  }\n  \n  async getGlobalLeaderboards(options?: {\n    stat_type?: string; // 'goals', 'assists', 'games_played'\n    sport_type?: string;\n    time_period?: string; // 'current_season', 'all_time'\n    limit?: number;\n  }): Promise<EdgeFunctionResponse> {\n    return this.invokeFunction('get-global-leaderboards', options || {});\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 5821, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/config.service.ts"],"sourcesContent":["/**\n * Configuration Service for MatchDay\n * \n * Manages all application configuration following the LEVER principle of\n * centralized configuration management. Provides hierarchical config loading:\n * 1. Memory cache\n * 2. Local storage\n * 3. Supabase database\n * 4. Default fallbacks\n * \n * @example\n * ```typescript\n * const config = await ConfigService.getInstance().getScoringRules();\n * const maxTeams = await ConfigService.getInstance().getLeagueSettings();\n * ```\n * \n * This service should be used for ALL configuration access.\n */\nexport class ConfigService {\n  private static instance: ConfigService;\n  private memoryCache = new Map();\n  private supabase: any; // Will be injected\n  \n  private constructor() {}\n  \n  static getInstance(): ConfigService {\n    if (!ConfigService.instance) {\n      ConfigService.instance = new ConfigService();\n    }\n    return ConfigService.instance;\n  }\n  \n  setSupabaseClient(client: any) {\n    this.supabase = client;\n  }\n  \n  async getConfig<T>(key: string): Promise<T> {\n    // 1. Check memory cache\n    if (this.memoryCache.has(key)) {\n      return this.memoryCache.get(key);\n    }\n    \n    // 2. Check local storage\n    if (typeof window !== 'undefined') {\n      const local = localStorage.getItem(`matchday_config_${key}`);\n      if (local) {\n        const parsed = JSON.parse(local);\n        this.memoryCache.set(key, parsed);\n        return parsed;\n      }\n    }\n    \n    // 3. Fetch from Supabase\n    if (this.supabase) {\n      try {\n        const { data } = await this.supabase\n          .from('app_configurations')\n          .select('value')\n          .eq('id', key)\n          .single();\n        \n        if (data) {\n          const value = data.value;\n          if (typeof window !== 'undefined') {\n            localStorage.setItem(`matchday_config_${key}`, JSON.stringify(value));\n          }\n          this.memoryCache.set(key, value);\n          return value;\n        }\n      } catch (error) {\n        console.warn(`Failed to fetch config for ${key}:`, error);\n      }\n    }\n    \n    // 4. Fall back to defaults\n    return this.getDefault(key);\n  }\n  \n  private getDefault<T>(key: string): T {\n    const defaults: Record<string, any> = {\n      scoring_rules: { win: 3, draw: 1, loss: 0 },\n      achievement_rules: {\n        first_goal: { points: 10 },\n        hat_trick: { points: 50 },\n        clean_sheet: { points: 25 },\n        mvp_game: { points: 30 },\n        perfect_attendance: { points: 100 }\n      },\n      league_settings: {\n        max_teams_per_league: 16,\n        matches_per_season: 30,\n        min_players_per_team: 11,\n        max_players_per_team: 25\n      },\n      notification_settings: {\n        match_reminders: true,\n        score_updates: true,\n        achievement_notifications: true\n      }\n    };\n    \n    return defaults[key] || null;\n  }\n  \n  // Specific getters for commonly used configs\n  async getScoringRules(): Promise<{ win: number; draw: number; loss: number }> {\n    return this.getConfig('scoring_rules');\n  }\n  \n  async getAchievementRules(): Promise<Record<string, { points: number }>> {\n    return this.getConfig('achievement_rules');\n  }\n  \n  async getLeagueSettings(): Promise<{\n    max_teams_per_league: number;\n    matches_per_season: number;\n    min_players_per_team: number;\n    max_players_per_team: number;\n  }> {\n    return this.getConfig('league_settings');\n  }\n  \n  // Clear cache when config is updated\n  invalidateConfig(key?: string) {\n    if (key) {\n      this.memoryCache.delete(key);\n      if (typeof window !== 'undefined') {\n        localStorage.removeItem(`matchday_config_${key}`);\n      }\n    } else {\n      this.memoryCache.clear();\n      if (typeof window !== 'undefined') {\n        Object.keys(localStorage)\n          .filter(k => k.startsWith('matchday_config_'))\n          .forEach(k => localStorage.removeItem(k));\n      }\n    }\n  }\n}\n\n// Export singleton instance\nexport const configService = ConfigService.getInstance();"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 5965, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/services/src/index.ts"],"sourcesContent":["/**\n * @matchday/services\n *\n * Shared service layer for MatchDay monorepo\n */\n\nexport * from './league.service';\nexport * from './team.service';\nexport * from './match.service';\nexport * from './season.service';\nexport * from './player.service';\nexport * from './user.service';\nexport * from './stats.service';\nexport * from './analytics.service';\nexport * from './achievement.service';\nexport * from './edge-functions.service';\nexport * from './config.service';\n"],"names":[],"mappings":"AAAA;;;;CAIC;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","debugId":null}},
    {"offset": {"line": 6018, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/auth/src/auth.service.ts"],"sourcesContent":["/**\n * Authentication Service for MatchDay\n * \n * Handles user authentication and session management following LEVER principles.\n * Integrates with Supabase Auth and manages user profiles automatically.\n * \n * @example\n * ```typescript\n * const { user, session } = await AuthService.getInstance().signInWithEmail(email, password);\n * await AuthService.getInstance().signOut();\n * ```\n * \n * This service should be used for ALL authentication operations.\n */\n\nimport { User, Session, AuthError } from '@supabase/supabase-js';\nimport { EdgeFunctionsService } from '@matchday/services';\n\nexport interface AuthUser extends User {\n  profile?: {\n    display_name: string;\n    avatar_url?: string;\n    preferred_position?: string;\n    bio?: string;\n    date_of_birth?: string;\n    location?: string;\n  };\n}\n\nexport interface AuthSession extends Session {\n  user: AuthUser;\n}\n\nexport interface SignUpData {\n  email: string;\n  password: string;\n  displayName: string;\n  preferredPosition?: string;\n  location?: string;\n}\n\nexport interface SignInData {\n  email: string;\n  password: string;\n}\n\nexport class AuthService {\n  private static instance: AuthService;\n  private supabase: any;\n  private currentUser: AuthUser | null = null;\n  private currentSession: AuthSession | null = null;\n  private listeners: Array<(user: AuthUser | null) => void> = [];\n  \n  private constructor() {}\n  \n  static getInstance(): AuthService {\n    if (!AuthService.instance) {\n      AuthService.instance = new AuthService();\n    }\n    return AuthService.instance;\n  }\n  \n  setSupabaseClient(client: any) {\n    this.supabase = client;\n    this.initializeAuthListener();\n  }\n  \n  private async initializeAuthListener() {\n    // Listen for auth state changes\n    this.supabase.auth.onAuthStateChange(async (event: string, session: Session | null) => {\n      if (session?.user) {\n        // Fetch user profile\n        const userWithProfile = await this.enrichUserWithProfile(session.user);\n        this.currentUser = userWithProfile;\n        this.currentSession = { ...session, user: userWithProfile } as AuthSession;\n      } else {\n        this.currentUser = null;\n        this.currentSession = null;\n      }\n      \n      // Notify listeners\n      this.listeners.forEach(listener => listener(this.currentUser));\n    });\n    \n    // Get initial session\n    const { data: { session } } = await this.supabase.auth.getSession();\n    if (session?.user) {\n      const userWithProfile = await this.enrichUserWithProfile(session.user);\n      this.currentUser = userWithProfile;\n      this.currentSession = { ...session, user: userWithProfile } as AuthSession;\n    }\n  }\n  \n  private async enrichUserWithProfile(user: User): Promise<AuthUser> {\n    try {\n      const { data: profile } = await this.supabase\n        .from('users')\n        .select('*')\n        .eq('id', user.id)\n        .single();\n      \n      return {\n        ...user,\n        profile: profile || undefined\n      };\n    } catch (error) {\n      console.warn('Failed to fetch user profile:', error);\n      return user as AuthUser;\n    }\n  }\n  \n  /**\n   * Sign up new user with automatic profile creation\n   */\n  async signUp(data: SignUpData): Promise<{\n    user: AuthUser | null;\n    session: AuthSession | null;\n    error: AuthError | null;\n  }> {\n    try {\n      const { data: authData, error: authError } = await this.supabase.auth.signUp({\n        email: data.email,\n        password: data.password\n      });\n      \n      if (authError) {\n        return { user: null, session: null, error: authError };\n      }\n      \n      if (authData.user) {\n        // Create user profile via Edge Function to ensure proper validation and audit logging\n        const profileResult = await EdgeFunctionsService.getInstance().updateUserProfile({\n          display_name: data.displayName,\n          preferred_position: data.preferredPosition,\n          location: data.location\n        });\n        \n        if (!profileResult.success) {\n          console.warn('Failed to create user profile:', profileResult.error);\n        }\n        \n        const enrichedUser = await this.enrichUserWithProfile(authData.user);\n        const enrichedSession = authData.session ? \n          { ...authData.session, user: enrichedUser } as AuthSession : null;\n        \n        return {\n          user: enrichedUser,\n          session: enrichedSession,\n          error: null\n        };\n      }\n      \n      return { user: null, session: null, error: null };\n    } catch (error) {\n      return {\n        user: null,\n        session: null,\n        error: error as AuthError\n      };\n    }\n  }\n  \n  /**\n   * Sign in existing user\n   */\n  async signIn(data: SignInData): Promise<{\n    user: AuthUser | null;\n    session: AuthSession | null;\n    error: AuthError | null;\n  }> {\n    try {\n      const { data: authData, error } = await this.supabase.auth.signInWithPassword({\n        email: data.email,\n        password: data.password\n      });\n      \n      if (error) {\n        return { user: null, session: null, error };\n      }\n      \n      if (authData.user) {\n        const enrichedUser = await this.enrichUserWithProfile(authData.user);\n        const enrichedSession = { ...authData.session, user: enrichedUser } as AuthSession;\n        \n        return {\n          user: enrichedUser,\n          session: enrichedSession,\n          error: null\n        };\n      }\n      \n      return { user: null, session: null, error: null };\n    } catch (error) {\n      return {\n        user: null,\n        session: null,\n        error: error as AuthError\n      };\n    }\n  }\n  \n  /**\n   * Sign in with OAuth providers (Google, etc.)\n   */\n  async signInWithOAuth(provider: 'google' | 'github' | 'discord'): Promise<{\n    error: AuthError | null;\n  }> {\n    try {\n      const { error } = await this.supabase.auth.signInWithOAuth({\n        provider,\n        options: {\n          redirectTo: `${window.location.origin}/auth/callback`\n        }\n      });\n      \n      return { error };\n    } catch (error) {\n      return { error: error as AuthError };\n    }\n  }\n  \n  /**\n   * Sign out current user\n   */\n  async signOut(): Promise<{ error: AuthError | null }> {\n    try {\n      const { error } = await this.supabase.auth.signOut();\n      return { error };\n    } catch (error) {\n      return { error: error as AuthError };\n    }\n  }\n  \n  /**\n   * Reset password\n   */\n  async resetPassword(email: string): Promise<{ error: AuthError | null }> {\n    try {\n      const { error } = await this.supabase.auth.resetPasswordForEmail(email, {\n        redirectTo: `${window.location.origin}/auth/reset-password`\n      });\n      \n      return { error };\n    } catch (error) {\n      return { error: error as AuthError };\n    }\n  }\n  \n  /**\n   * Update password\n   */\n  async updatePassword(newPassword: string): Promise<{ error: AuthError | null }> {\n    try {\n      const { error } = await this.supabase.auth.updateUser({\n        password: newPassword\n      });\n      \n      return { error };\n    } catch (error) {\n      return { error: error as AuthError };\n    }\n  }\n  \n  /**\n   * Update user profile\n   */\n  async updateProfile(updates: {\n    display_name?: string;\n    avatar_url?: string;\n    preferred_position?: string;\n    bio?: string;\n    date_of_birth?: string;\n    location?: string;\n  }): Promise<{ error: Error | null }> {\n    try {\n      const result = await EdgeFunctionsService.getInstance().updateUserProfile(updates);\n      \n      if (!result.success) {\n        return { error: new Error(result.error) };\n      }\n      \n      // Refresh current user data\n      if (this.currentUser) {\n        this.currentUser = await this.enrichUserWithProfile(this.currentUser);\n        this.listeners.forEach(listener => listener(this.currentUser));\n      }\n      \n      return { error: null };\n    } catch (error) {\n      return { error: error as Error };\n    }\n  }\n  \n  /**\n   * Get current user\n   */\n  getCurrentUser(): AuthUser | null {\n    return this.currentUser;\n  }\n  \n  /**\n   * Get current session\n   */\n  getCurrentSession(): AuthSession | null {\n    return this.currentSession;\n  }\n  \n  /**\n   * Check if user is authenticated\n   */\n  isAuthenticated(): boolean {\n    return !!this.currentUser;\n  }\n  \n  /**\n   * Subscribe to auth state changes\n   */\n  onAuthStateChange(callback: (user: AuthUser | null) => void): () => void {\n    this.listeners.push(callback);\n    \n    // Return unsubscribe function\n    return () => {\n      const index = this.listeners.indexOf(callback);\n      if (index > -1) {\n        this.listeners.splice(index, 1);\n      }\n    };\n  }\n  \n  /**\n   * Require authentication - throws if not authenticated\n   */\n  requireAuth(): AuthUser {\n    if (!this.currentUser) {\n      throw new Error('Authentication required');\n    }\n    return this.currentUser;\n  }\n  \n  /**\n   * Check if user has specific permissions\n   */\n  hasPermission(permission: 'create_league' | 'manage_team' | 'admin'): boolean {\n    if (!this.currentUser) return false;\n    \n    // For now, all authenticated users can create leagues and manage teams\n    // In the future, this could be enhanced with role-based permissions\n    switch (permission) {\n      case 'create_league':\n      case 'manage_team':\n        return true;\n      case 'admin':\n        // Check if user has admin role (would be stored in user metadata or separate table)\n        return this.currentUser.user_metadata?.role === 'admin';\n      default:\n        return false;\n    }\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 6339, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/auth/src/validator.ts"],"sourcesContent":["/**\n * Centralized Authentication Validator\n * \n * Single source of truth for authentication validation across the application.\n * Provides consistent validation logic for both client and server-side usage.\n */\n\nimport { Session } from '@supabase/supabase-js';\nimport { supabase, isInvalidJWTError } from '@/lib/supabase/client';\n\nexport interface AuthValidationResult {\n  isValid: boolean;\n  status: 'healthy' | 'invalid_token' | 'no_session' | 'expired' | 'validation_failed';\n  session: Session | null;\n  user: any | null;\n  reason?: string;\n  shouldClearCookies: boolean;\n  shouldRedirectToLogin: boolean;\n  action: 'none' | 'clear_cookies' | 'refresh_token' | 'redirect_login' | 'retry';\n}\n\n/**\n * Comprehensive authentication state validation\n */\nexport async function validateAuthenticationState(): Promise<AuthValidationResult> {\n  try {\n    console.log('üîç Validating authentication state...');\n    \n    // Step 1: Check if we have a session\n    const { data: { session }, error: sessionError } = await supabase.auth.getSession();\n    \n    if (sessionError) {\n      console.log('üîç Session error:', sessionError.message);\n      \n      if (isInvalidJWTError(sessionError)) {\n        return {\n          isValid: false,\n          status: 'invalid_token',\n          session: null,\n          user: null,\n          reason: sessionError.message,\n          shouldClearCookies: true,\n          shouldRedirectToLogin: true,\n          action: 'clear_cookies'\n        };\n      }\n      \n      return {\n        isValid: false,\n        status: 'validation_failed',\n        session: null,\n        user: null,\n        reason: sessionError.message,\n        shouldClearCookies: false,\n        shouldRedirectToLogin: false,\n        action: 'retry'\n      };\n    }\n    \n    if (!session) {\n      console.log('üîç No session found');\n      return {\n        isValid: false,\n        status: 'no_session',\n        session: null,\n        user: null,\n        shouldClearCookies: false,\n        shouldRedirectToLogin: true,\n        action: 'redirect_login'\n      };\n    }\n    \n    // Step 2: Check token expiry\n    const now = Math.floor(Date.now() / 1000);\n    const expiresAt = session.expires_at || 0;\n    \n    if (expiresAt <= now) {\n      console.log('üîç Token expired');\n      return {\n        isValid: false,\n        status: 'expired',\n        session,\n        user: session.user,\n        reason: 'Token has expired',\n        shouldClearCookies: false,\n        shouldRedirectToLogin: false,\n        action: 'refresh_token'\n      };\n    }\n    \n    // Step 3: Validate token with server (optional during initialization)\n    try {\n      // Add timeout and error handling to prevent blocking initialization\n      const controller = new AbortController();\n      const timeoutId = setTimeout(() => controller.abort(), 3000); // 3 second timeout\n      \n      const healthResponse = await fetch('/api/auth/health', {\n        credentials: 'include',\n        headers: {\n          'Authorization': `Bearer ${session.access_token}`\n        },\n        signal: controller.signal\n      });\n      \n      clearTimeout(timeoutId);\n      \n      if (!healthResponse.ok) {\n        const healthData = await healthResponse.json();\n        console.log('üîç Health check failed:', healthData.status);\n        \n        return {\n          isValid: false,\n          status: healthData.status === 'INVALID_TOKEN' ? 'invalid_token' : 'validation_failed',\n          session,\n          user: session.user,\n          reason: healthData.message,\n          shouldClearCookies: healthData.action === 'CLEAR_COOKIES_AND_REAUTH',\n          shouldRedirectToLogin: healthData.action !== 'RETRY_OR_REAUTH',\n          action: healthData.action === 'CLEAR_COOKIES_AND_REAUTH' ? 'clear_cookies' : 'retry'\n        };\n      }\n      \n      const healthData = await healthResponse.json();\n      console.log('üîç Authentication state is healthy');\n      \n      return {\n        isValid: true,\n        status: 'healthy',\n        session,\n        user: session.user,\n        shouldClearCookies: false,\n        shouldRedirectToLogin: false,\n        action: 'none'\n      };\n      \n    } catch (healthError) {\n      console.log('üîç Health check request failed (gracefully degrading):', healthError);\n      \n      // Graceful degradation: If health check fails during initialization,\n      // assume the session is valid if it passes local validation\n      // This prevents circular dependency issues during app startup\n      if (healthError.name === 'AbortError') {\n        console.log('üîç Health check timed out - assuming valid session for now');\n      } else if (healthError.message?.includes('fetch')) {\n        console.log('üîç Health endpoint not available - assuming valid session for now');\n      }\n      \n      // Fall back to local validation only\n      return {\n        isValid: true, // Assume valid if local checks passed\n        status: 'healthy',\n        session,\n        user: session.user,\n        shouldClearCookies: false,\n        shouldRedirectToLogin: false,\n        action: 'none'\n      };\n    }\n    \n  } catch (error) {\n    console.error('üîç Authentication validation error:', error);\n    \n    return {\n      isValid: false,\n      status: 'validation_failed',\n      session: null,\n      user: null,\n      reason: error instanceof Error ? error.message : 'Unknown validation error',\n      shouldClearCookies: false,\n      shouldRedirectToLogin: false,\n      action: 'retry'\n    };\n  }\n}\n\n/**\n * Quick session health check (lightweight)\n */\nexport async function validateSessionHealth(session: Session | null): Promise<boolean> {\n  if (!session?.access_token) return false;\n  \n  try {\n    // Check token expiry first (local check, no network)\n    const now = Math.floor(Date.now() / 1000);\n    const expiresAt = session.expires_at || 0;\n    \n    if (expiresAt <= now) {\n      console.log('üîç Token expired (local check)');\n      return false;\n    }\n    \n    // Validate with server\n    const { data, error } = await supabase.auth.getUser();\n    \n    if (error && isInvalidJWTError(error)) {\n      console.log('üîç Invalid JWT detected in health check');\n      return false;\n    }\n    \n    return !error && !!data.user;\n  } catch (error) {\n    if (isInvalidJWTError(error)) {\n      console.log('üîç Invalid JWT detected in health check (catch)');\n      return false;\n    }\n    return false;\n  }\n}\n\n/**\n * Check if token is about to expire (within 2 minutes)\n */\nexport function isTokenNearExpiry(session: Session | null): boolean {\n  if (!session?.expires_at) return false;\n  \n  const now = Math.floor(Date.now() / 1000);\n  const expiresAt = session.expires_at;\n  const twoMinutes = 2 * 60;\n  \n  return (expiresAt - now) <= twoMinutes;\n}\n\n/**\n * Attempt to refresh the current session\n */\nexport async function refreshAuthSession(): Promise<{ success: boolean; session: Session | null; error?: string }> {\n  try {\n    console.log('üîÑ Attempting to refresh auth session...');\n    \n    const { data, error } = await supabase.auth.refreshSession();\n    \n    if (error) {\n      console.log('üîÑ Session refresh failed:', error.message);\n      return { success: false, session: null, error: error.message };\n    }\n    \n    console.log('üîÑ Session refreshed successfully');\n    return { success: true, session: data.session };\n    \n  } catch (error) {\n    console.log('üîÑ Session refresh error:', error);\n    return { \n      success: false, \n      session: null, \n      error: error instanceof Error ? error.message : 'Unknown refresh error' \n    };\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 6551, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/auth/src/role.service.ts"],"sourcesContent":["/**\n * Role Service\n * \n * Handles role-based authentication and authorization across the application.\n * Provides utilities for checking user roles and permissions.\n */\n\nimport { supabase } from '@/lib/supabase/client';\nimport { UserRole } from '@/lib/types/database.types';\n\nexport interface RoleCheckResult {\n  hasAccess: boolean;\n  userRole: UserRole | null;\n  redirectTo?: string;\n}\n\nexport class RoleService {\n  /**\n   * Get the current user's role from their profile with timeout and retries\n   */\n  static async getCurrentUserRole(): Promise<UserRole | null> {\n    try {\n      console.log('[RoleService] Getting current user...');\n      \n      // Add timeout to getUser call\n      const userResult = await Promise.race([\n        supabase.auth.getUser(),\n        new Promise<never>((_, reject) => \n          setTimeout(() => reject(new Error('getUser timeout')), 2000)\n        )\n      ]);\n      \n      const user = userResult.data?.user;\n      if (!user) {\n        console.log('[RoleService] No authenticated user found');\n        return null;\n      }\n\n      console.log('[RoleService] Fetching user profile for:', user.id);\n      \n      // Add timeout to profile query with retry logic\n      let lastError: any;\n      for (let attempt = 1; attempt <= 2; attempt++) {\n        try {\n          const { data: profile, error } = await Promise.race([\n            supabase\n              .from('users')\n              .select('role')\n              .eq('id', user.id)\n              .single(),\n            new Promise<never>((_, reject) => \n              setTimeout(() => reject(new Error('Profile query timeout')), 1500)\n            )\n          ]);\n\n          if (error) {\n            console.error(`[RoleService] Error fetching user role (attempt ${attempt}):`, error);\n            lastError = error;\n            if (attempt < 2) {\n              await new Promise(resolve => setTimeout(resolve, 500)); // Wait before retry\n              continue;\n            }\n            // On final attempt, check if it's a \"no rows\" error vs connection error\n            if (error.code === 'PGRST116') {\n              console.warn('[RoleService] User profile not found - user may need to complete onboarding');\n              return 'player'; // Default role for users without profiles\n            }\n            throw error;\n          }\n\n          const role = profile?.role || 'player';\n          console.log('[RoleService] User role found:', role);\n          return role;\n        } catch (err) {\n          lastError = err;\n          if (attempt < 2) {\n            console.warn(`[RoleService] Attempt ${attempt} failed, retrying...`, err);\n            await new Promise(resolve => setTimeout(resolve, 500));\n            continue;\n          }\n          throw err;\n        }\n      }\n      \n      throw lastError;\n    } catch (error) {\n      console.error('[RoleService] Error getting current user role:', error);\n      // For admin access, be more permissive on errors to prevent lockout\n      return null;\n    }\n  }\n\n  /**\n   * Check if user has any of the specified roles with timeout protection\n   */\n  static async hasRole(allowedRoles: UserRole[]): Promise<RoleCheckResult> {\n    console.log('[RoleService] Checking roles:', allowedRoles);\n    \n    try {\n      const userRole = await Promise.race([\n        this.getCurrentUserRole(),\n        new Promise<UserRole | null>((_, reject) => \n          setTimeout(() => reject(new Error('Role check timeout')), 2000)\n        )\n      ]);\n      \n      console.log('[RoleService] User role retrieved:', userRole);\n      \n      if (!userRole) {\n        console.log('[RoleService] No user role found - redirecting to login');\n        return {\n          hasAccess: false,\n          userRole: null,\n          redirectTo: '/auth/login'\n        };\n      }\n\n      const hasAccess = allowedRoles.includes(userRole);\n      console.log('[RoleService] Access check result:', { userRole, allowedRoles, hasAccess });\n      \n      return {\n        hasAccess,\n        userRole,\n        redirectTo: hasAccess ? undefined : '/unauthorized'\n      };\n    } catch (error) {\n      console.error('[RoleService] Error in hasRole check:', error);\n      \n      // For admin roles, be more permissive on timeout/error to prevent lockout\n      const isAdminCheck = allowedRoles.includes('league_admin') || allowedRoles.includes('app_admin');\n      if (isAdminCheck) {\n        console.warn('[RoleService] Admin role check failed - failing open to prevent lockout');\n        return {\n          hasAccess: true,\n          userRole: 'league_admin', // Assume admin access on error\n          redirectTo: undefined\n        };\n      }\n      \n      return {\n        hasAccess: false,\n        userRole: null,\n        redirectTo: '/auth/login'\n      };\n    }\n  }\n\n  /**\n   * Check if user can access player features\n   */\n  static async canAccessPlayerApp(): Promise<RoleCheckResult> {\n    return this.hasRole(['player', 'captain', 'admin', 'league_admin', 'app_admin']);\n  }\n\n  /**\n   * Check if user can access admin features\n   */\n  static async canAccessAdminApp(): Promise<RoleCheckResult> {\n    return this.hasRole(['league_admin', 'app_admin']);\n  }\n\n  /**\n   * Check if user is a league administrator\n   */\n  static async isLeagueAdmin(): Promise<boolean> {\n    const result = await this.hasRole(['league_admin', 'app_admin']);\n    return result.hasAccess;\n  }\n\n  /**\n   * Check if user is an app administrator\n   */\n  static async isAppAdmin(): Promise<boolean> {\n    const result = await this.hasRole(['app_admin']);\n    return result.hasAccess;\n  }\n\n  /**\n   * Check if user can manage a specific league\n   */\n  static async canManageLeague(leagueId: string): Promise<boolean> {\n    try {\n      const userRole = await this.getCurrentUserRole();\n      \n      if (!userRole) return false;\n      \n      // App admins can manage any league\n      if (userRole === 'app_admin') {\n        return true;\n      }\n      \n      // League admins can manage leagues they created\n      if (userRole === 'league_admin') {\n        const { data: { user } } = await supabase.auth.getUser();\n        if (!user) return false;\n\n        const { data: league } = await supabase\n          .from('leagues')\n          .select('created_by')\n          .eq('id', leagueId)\n          .single();\n\n        return league?.created_by === user.id;\n      }\n      \n      return false;\n    } catch (error) {\n      console.error('Error checking league management permission:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Check if user can manage a specific team\n   */\n  static async canManageTeam(teamId: string): Promise<boolean> {\n    try {\n      const userRole = await this.getCurrentUserRole();\n      \n      if (!userRole) return false;\n      \n      // App admins can manage any team\n      if (userRole === 'app_admin') {\n        return true;\n      }\n      \n      const { data: { user } } = await supabase.auth.getUser();\n      if (!user) return false;\n\n      // Team captains and admins can manage their team\n      if (['captain', 'admin'].includes(userRole)) {\n        const { data: team } = await supabase\n          .from('teams')\n          .select('captain_id')\n          .eq('id', teamId)\n          .single();\n\n        if (team?.captain_id === user.id) {\n          return true;\n        }\n      }\n\n      // League admins can manage teams in their leagues\n      if (userRole === 'league_admin') {\n        const { data: team } = await supabase\n          .from('teams')\n          .select('league_id, leagues!inner(created_by)')\n          .eq('id', teamId)\n          .single();\n\n        return (team?.leagues as any)?.created_by === user.id;\n      }\n      \n      return false;\n    } catch (error) {\n      console.error('Error checking team management permission:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Get user role display name\n   */\n  static getRoleDisplayName(role: UserRole): string {\n    const roleNames: Record<UserRole, string> = {\n      player: 'Player',\n      captain: 'Team Captain',\n      admin: 'Team Admin',\n      league_admin: 'League Administrator',\n      app_admin: 'App Administrator'\n    };\n    \n    return roleNames[role] || 'Unknown';\n  }\n\n  /**\n   * Get role permissions description\n   */\n  static getRolePermissions(role: UserRole): string[] {\n    const permissions: Record<UserRole, string[]> = {\n      player: [\n        'Join teams',\n        'View leagues',\n        'View personal stats',\n        'Receive team invitations'\n      ],\n      captain: [\n        'All player permissions',\n        'Manage team roster',\n        'Invite players',\n        'Request league membership'\n      ],\n      admin: [\n        'All captain permissions',\n        'Manage team settings',\n        'View team analytics'\n      ],\n      league_admin: [\n        'Create and manage leagues',\n        'Approve team requests',\n        'Schedule matches',\n        'Manage league settings'\n      ],\n      app_admin: [\n        'All permissions',\n        'Manage all users',\n        'System administration',\n        'Global settings'\n      ]\n    };\n    \n    return permissions[role] || [];\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 6820, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/packages/auth/src/index.ts"],"sourcesContent":["/**\n * @matchday/auth\n *\n * Shared authentication utilities for MatchDay monorepo\n */\n\nexport * from './auth.service';\nexport * from './validator';\n// api-auth is app-specific, not exported from shared package\nexport * from './role.service';\n"],"names":[],"mappings":"AAAA;;;;CAIC;AAED;AACA;AACA,6DAA6D;AAC7D","debugId":null}},
    {"offset": {"line": 6850, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/apps/player/src/components/auth/supabase-auth-provider.tsx"],"sourcesContent":["/**\n * Robust Supabase Authentication Provider\n * \n * Advanced authentication system with:\n * - Atomic state management (no split-brain issues)\n * - Proactive health monitoring\n * - Automatic token refresh and recovery\n * - Consistent frontend/backend authentication state\n */\n\n'use client'\n\nimport React, { createContext, useContext, useEffect, useState, useCallback, useRef } from 'react'\nimport { User, Session, AuthError } from '@supabase/supabase-js'\nimport { supabase, clearAuthCookies, isInvalidJWTError } from '@/lib/supabase/client'\nimport { \n  validateAuthenticationState, \n  validateSessionHealth, \n  isTokenNearExpiry, \n  refreshAuthSession,\n  AuthValidationResult \n} from '@matchday/auth'\n\ninterface AuthState {\n  user: User | null\n  session: Session | null\n  isValid: boolean\n  isLoading: boolean\n  lastValidated: Date | null\n  validationStatus: string\n}\n\ninterface AuthContextType {\n  // State\n  user: User | null\n  session: Session | null\n  isLoading: boolean\n  isAuthenticated: boolean\n  isValid: boolean\n  lastValidated: Date | null\n  \n  // Actions\n  signUp: (data: {\n    email: string\n    password: string\n    displayName?: string\n    preferredPosition?: string\n    location?: string\n  }) => Promise<{ success: boolean; error?: string }>\n  signIn: (data: {\n    email: string\n    password: string\n  }) => Promise<{ success: boolean; error?: string }>\n  signInWithOAuth: (provider: 'google' | 'github' | 'discord') => Promise<{ success: boolean; error?: string }>\n  signOut: () => Promise<{ success: boolean; error?: string }>\n  resetPassword: (email: string) => Promise<{ success: boolean; error?: string }>\n  \n  // Advanced\n  validateAuth: () => Promise<AuthValidationResult>\n  refreshSession: () => Promise<boolean>\n}\n\nconst AuthContext = createContext<AuthContextType | undefined>(undefined)\n\ninterface AuthProviderProps {\n  children: React.ReactNode\n}\n\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {\n  // Atomic authentication state\n  const [authState, setAuthState] = useState<AuthState>({\n    user: null,\n    session: null,\n    isValid: false,\n    isLoading: true,\n    lastValidated: null,\n    validationStatus: 'initial'\n  })\n  \n  // Refs for cleanup\n  const mounted = useRef(true)\n  const healthCheckInterval = useRef<NodeJS.Timeout>()\n  const refreshCheckInterval = useRef<NodeJS.Timeout>()\n\n  // Atomic state update function\n  const updateAuthState = useCallback(async (validation: AuthValidationResult) => {\n    if (!mounted.current) return\n    \n    console.log('üîÑ Updating auth state:', validation.status)\n    \n    setAuthState({\n      user: validation.user,\n      session: validation.session,\n      isValid: validation.isValid,\n      isLoading: false,\n      lastValidated: new Date(),\n      validationStatus: validation.status\n    })\n    \n    // Handle recovery actions\n    if (validation.shouldClearCookies) {\n      console.log('üßπ Clearing corrupted cookies')\n      clearAuthCookies()\n    }\n  }, [])\n\n  // Comprehensive authentication validation\n  const validateAuth = useCallback(async (): Promise<AuthValidationResult> => {\n    const validation = await validateAuthenticationState()\n    await updateAuthState(validation)\n    return validation\n  }, [updateAuthState])\n\n  // Refresh session manually\n  const refreshSession = useCallback(async (): Promise<boolean> => {\n    try {\n      const { success, session: newSession } = await refreshAuthSession()\n      \n      if (success && newSession) {\n        // Validate the new session\n        const validation = await validateAuthenticationState()\n        await updateAuthState(validation)\n        return validation.isValid\n      }\n      \n      return false\n    } catch (error) {\n      console.error('Manual session refresh failed:', error)\n      return false\n    }\n  }, [updateAuthState])\n\n  // Initial authentication setup\n  useEffect(() => {\n    mounted.current = true\n    \n    const initializeAuth = async () => {\n      console.log('üöÄ Initializing robust authentication...')\n      await validateAuth()\n    }\n    \n    initializeAuth()\n    \n    // Listen for auth state changes from Supabase\n    const { data: { subscription } } = supabase.auth.onAuthStateChange(async (event, session) => {\n      if (!mounted.current) return\n      \n      console.log('üîë Auth event:', event, !!session)\n      \n      // Re-validate after any auth state change\n      setTimeout(() => validateAuth(), 100)\n    })\n    \n    return () => {\n      mounted.current = false\n      subscription.unsubscribe()\n    }\n  }, [validateAuth])\n\n  // Proactive health monitoring\n  useEffect(() => {\n    if (!authState.session || !authState.isValid) {\n      // Clear intervals if no valid session\n      if (healthCheckInterval.current) clearInterval(healthCheckInterval.current)\n      if (refreshCheckInterval.current) clearInterval(refreshCheckInterval.current)\n      return\n    }\n    \n    // Health check every 5 minutes\n    healthCheckInterval.current = setInterval(async () => {\n      if (!mounted.current) return\n      \n      console.log('üè• Running periodic health check...')\n      await validateAuth()\n    }, 5 * 60 * 1000)\n    \n    // Refresh check every minute (check if token needs refresh)\n    refreshCheckInterval.current = setInterval(async () => {\n      if (!mounted.current || !authState.session) return\n      \n      if (isTokenNearExpiry(authState.session)) {\n        console.log('üîÑ Token near expiry, refreshing...')\n        await refreshSession()\n      }\n    }, 60 * 1000)\n    \n    return () => {\n      if (healthCheckInterval.current) clearInterval(healthCheckInterval.current)\n      if (refreshCheckInterval.current) clearInterval(refreshCheckInterval.current)\n    }\n  }, [authState.session, authState.isValid, validateAuth, refreshSession])\n\n  const isAuthenticated = authState.isValid && !!authState.user && !!authState.session\n\n  // Sign up with email/password\n  const signUp = async (data: {\n    email: string\n    password: string\n    displayName?: string\n    preferredPosition?: string\n    location?: string\n  }) => {\n    try {\n      setAuthState(prev => ({ ...prev, isLoading: true }))\n      \n      const { data: authData, error } = await supabase.auth.signUp({\n        email: data.email,\n        password: data.password,\n        options: {\n          data: {\n            display_name: data.displayName || '',\n            preferred_position: data.preferredPosition || '',\n            location: data.location || ''\n          }\n        }\n      })\n\n      if (error) {\n        console.error('Sign up error:', error)\n        return { success: false, error: error.message }\n      }\n\n      // Validate the new auth state\n      await validateAuth()\n      return { success: true }\n    } catch (error) {\n      console.error('Sign up error:', error)\n      return { success: false, error: 'An unexpected error occurred' }\n    }\n  }\n\n  // Sign in with email/password\n  const signIn = async (data: { email: string; password: string }) => {\n    try {\n      setAuthState(prev => ({ ...prev, isLoading: true }))\n      \n      const { data: authData, error } = await supabase.auth.signInWithPassword({\n        email: data.email,\n        password: data.password,\n      })\n\n      if (error) {\n        console.error('Sign in error:', error)\n        setAuthState(prev => ({ ...prev, isLoading: false }))\n        \n        // Return user-friendly error messages\n        if (error.message.includes('Invalid login credentials')) {\n          return { success: false, error: 'Invalid email or password. Please try again.' }\n        }\n        if (error.message.includes('Email not confirmed')) {\n          return { success: false, error: 'Please confirm your email before signing in.' }\n        }\n        \n        return { success: false, error: error.message }\n      }\n\n      // Validate the new auth state\n      await validateAuth()\n      return { success: true }\n    } catch (error: any) {\n      console.error('Sign in error:', error)\n      setAuthState(prev => ({ ...prev, isLoading: false }))\n      \n      // Handle network errors\n      if (error?.message?.includes('fetch')) {\n        return { success: false, error: 'Network error. Please check your connection.' }\n      }\n      \n      return { success: false, error: 'An unexpected error occurred. Please try again.' }\n    } finally {\n      // Ensure loading state is cleared\n      setAuthState(prev => ({ ...prev, isLoading: false }))\n    }\n  }\n\n  // Sign in with OAuth\n  const signInWithOAuth = async (provider: 'google' | 'github' | 'discord') => {\n    try {\n      setAuthState(prev => ({ ...prev, isLoading: true }))\n      \n      const { data, error } = await supabase.auth.signInWithOAuth({\n        provider,\n        options: {\n          redirectTo: `${window.location.origin}/dashboard`\n        }\n      })\n\n      if (error) {\n        console.error('OAuth sign in error:', error)\n        return { success: false, error: error.message }\n      }\n\n      return { success: true }\n    } catch (error) {\n      console.error('OAuth sign in error:', error)\n      return { success: false, error: 'An unexpected error occurred' }\n    }\n  }\n\n  // Sign out\n  const signOut = async () => {\n    try {\n      setAuthState(prev => ({ ...prev, isLoading: true }))\n      \n      const { error } = await supabase.auth.signOut()\n\n      if (error) {\n        console.error('Sign out error:', error)\n        return { success: false, error: error.message }\n      }\n\n      // Clear all auth state\n      setAuthState({\n        user: null,\n        session: null,\n        isValid: false,\n        isLoading: false,\n        lastValidated: null,\n        validationStatus: 'signed_out'\n      })\n      \n      // Clear cookies as well\n      clearAuthCookies()\n\n      return { success: true }\n    } catch (error) {\n      console.error('Sign out error:', error)\n      return { success: false, error: 'An unexpected error occurred' }\n    }\n  }\n\n  // Reset password\n  const resetPassword = async (email: string) => {\n    try {\n      const { error } = await supabase.auth.resetPasswordForEmail(email, {\n        redirectTo: `${window.location.origin}/auth/reset-password`\n      })\n\n      if (error) {\n        console.error('Password reset error:', error)\n        return { success: false, error: error.message }\n      }\n\n      return { success: true }\n    } catch (error) {\n      console.error('Password reset error:', error)\n      return { success: false, error: 'An unexpected error occurred' }\n    }\n  }\n\n  const value: AuthContextType = {\n    // State\n    user: authState.user,\n    session: authState.session,\n    isLoading: authState.isLoading,\n    isAuthenticated,\n    isValid: authState.isValid,\n    lastValidated: authState.lastValidated,\n    \n    // Actions\n    signUp,\n    signIn,\n    signInWithOAuth,\n    signOut,\n    resetPassword,\n    \n    // Advanced\n    validateAuth,\n    refreshSession,\n  }\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>\n}\n\nexport const useAuth = (): AuthContextType => {\n  const context = useContext(AuthContext)\n  if (context === undefined) {\n    throw new Error('useAuth must be used within an AuthProvider')\n  }\n  return context\n}\n\n// Export a helper for getting session in client components\nexport const getSession = async () => {\n  try {\n    const { data: { session }, error } = await supabase.auth.getSession()\n    if (error) {\n      console.error('Error getting session:', error)\n      return null\n    }\n    return session\n  } catch (error) {\n    console.error('Error getting session:', error)\n    return null\n  }\n}"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 7272, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/apps/player/src/components/layout/header.tsx"],"sourcesContent":["/**\n * Professional Header Component\n * \n * Main navigation header that makes amateur players feel like they're using\n * a professional sports platform. Includes MatchDay branding and key navigation.\n */\n\n'use client';\n\nimport React from 'react';\nimport Link from 'next/link';\nimport { usePathname, useRouter } from 'next/navigation';\nimport { LogIn, LogOut, User } from 'lucide-react';\nimport { useAuth } from '@/components/auth/supabase-auth-provider';\n\ninterface HeaderProps {\n  className?: string;\n}\n\nexport const Header: React.FC<HeaderProps> = ({ className = '' }) => {\n  const pathname = usePathname();\n  const router = useRouter();\n  const { user, isLoading, signOut, forceSignOut } = useAuth();\n\n  // Debug logging for auth state\n  console.log('üé® Header render - Loading:', isLoading, 'User:', user?.email || 'null', 'Will show:', \n    isLoading ? 'loading' : user ? 'logout button' : 'login button');\n\n  const navItems = [\n    { href: '/dashboard', label: 'My Dashboard', icon: 'üìä' },\n    { href: '/leagues', label: 'Explore Leagues', icon: 'üèÜ' },\n    { href: '/teams', label: 'My Teams', icon: 'üë•' },\n    { href: '/matches', label: 'Matches', icon: '‚öΩ' },\n    { href: '/profile', label: 'Profile Settings', icon: '‚öôÔ∏è' },\n  ];\n\n  const isActive = (href: string) => {\n    if (href === '/') {\n      return pathname === '/';\n    }\n    return pathname.startsWith(href);\n  };\n\n  const handleLogin = () => {\n    router.push('/auth/login');\n  };\n\n  const handleLogout = async () => {\n    try {\n      console.log('üé® Header: Starting logout...');\n      const result = await signOut();\n      \n      if (result.success) {\n        console.log('üé® Header: Logout succeeded, redirecting...');\n        // Only redirect if logout actually succeeded\n        if (typeof window !== 'undefined') {\n          window.location.href = '/';\n        } else {\n          router.push('/');\n        }\n      } else {\n        console.error('üé® Header: Logout failed:', result.error);\n        \n        // If logout failed due to network issues, offer force logout\n        if (result.canForceLogout) {\n          const forceLogout = confirm(\n            `${result.error}\\n\\nWould you like to force logout? This will clear your local session but the server session may remain active.`\n          );\n          \n          if (forceLogout) {\n            console.log('üé® Header: User chose force logout');\n            const forceResult = await forceSignOut();\n            \n            if (forceResult.success) {\n              console.log('üé® Header: Force logout succeeded');\n              if (forceResult.error) {\n                // Show warning about potential server session\n                alert(`Force logout completed. ${forceResult.error}`);\n              }\n              window.location.href = '/';\n            } else {\n              alert(`Force logout failed: ${forceResult.error}`);\n            }\n          }\n        } else {\n          // Regular error message for non-network issues\n          alert(`Logout failed: ${result.error}`);\n        }\n      }\n    } catch (error) {\n      console.error('üé® Header: Logout exception:', error);\n      alert('Logout failed due to unexpected error. Please try again.');\n    }\n  };\n\n  return (\n    <header className={`bg-white dark:bg-gray-900 border-b border-gray-200 dark:border-gray-700 ${className}`}>\n      <div className=\"container mx-auto px-4\">\n        <div className=\"flex items-center justify-between h-16\">\n          {/* Logo */}\n          <Link href=\"/\" className=\"flex items-center space-x-2\">\n            <div className=\"w-8 h-8 bg-gradient-to-r from-blue-600 to-purple-600 rounded-lg flex items-center justify-center\">\n              <span className=\"text-white font-bold text-sm\">M</span>\n            </div>\n            <span className=\"text-xl font-bold bg-gradient-to-r from-blue-600 to-purple-600 bg-clip-text text-transparent\">\n              MatchDay\n            </span>\n          </Link>\n\n          {/* Navigation */}\n          <nav className=\"hidden md:flex items-center space-x-1\">\n            {navItems.map((item) => (\n              <Link\n                key={item.href}\n                href={item.href}\n                className={`flex items-center space-x-2 px-4 py-2 rounded-lg transition-colors ${\n                  isActive(item.href)\n                    ? 'bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300'\n                    : 'text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800'\n                }`}\n              >\n                <span className=\"text-lg\">{item.icon}</span>\n                <span className=\"font-medium\">{item.label}</span>\n              </Link>\n            ))}\n          </nav>\n\n          {/* Mobile menu button and action */}\n          <div className=\"flex items-center space-x-4\">\n            {/* Authentication Controls */}\n            {isLoading ? (\n              <div className=\"animate-pulse bg-gray-200 dark:bg-gray-700 h-8 w-20 rounded\"></div>\n            ) : user ? (\n              <div className=\"flex items-center space-x-3\">\n                {/* User Info */}\n                <div className=\"hidden sm:flex items-center space-x-2\">\n                  <User className=\"w-5 h-5 text-gray-600 dark:text-gray-300\" />\n                  <span className=\"text-sm font-medium text-gray-700 dark:text-gray-300\">\n                    {user.profile?.display_name || user.email}\n                  </span>\n                </div>\n                \n                {/* Logout Button */}\n                <button\n                  onClick={handleLogout}\n                  className=\"flex items-center space-x-2 px-3 py-2 bg-red-600 hover:bg-red-700 text-white font-medium rounded-lg transition-colors\"\n                >\n                  <LogOut className=\"w-4 h-4\" />\n                  <span className=\"hidden sm:inline\">Logout</span>\n                </button>\n              </div>\n            ) : (\n              <button\n                onClick={handleLogin}\n                className=\"flex items-center space-x-2 bg-gradient-to-r from-blue-600 to-purple-600 text-white px-4 py-2 rounded-lg font-medium hover:from-blue-700 hover:to-purple-700 transition-colors\"\n              >\n                <LogIn className=\"w-4 h-4\" />\n                <span>Login</span>\n              </button>\n            )}\n\n            {/* Mobile Navigation */}\n            <div className=\"md:hidden\">\n              <div className=\"flex items-center space-x-1\">\n                {navItems.slice(1).map((item) => (\n                  <Link\n                    key={item.href}\n                    href={item.href}\n                    className={`p-2 rounded-lg transition-colors ${\n                      isActive(item.href)\n                        ? 'bg-blue-100 dark:bg-blue-900 text-blue-700 dark:text-blue-300'\n                        : 'text-gray-600 dark:text-gray-300 hover:bg-gray-100 dark:hover:bg-gray-800'\n                    }`}\n                  >\n                    <span className=\"text-xl\">{item.icon}</span>\n                  </Link>\n                ))}\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </header>\n  );\n};"],"names":[],"mappings":"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","debugId":null}},
    {"offset": {"line": 7614, "column": 0}, "map": {"version":3,"sources":["file:///Users/lukini/MatchDay/apps/player/src/components/providers/query-provider.tsx"],"sourcesContent":["/**\n * React Query Provider\n * \n * Sets up React Query for the application to enable data fetching\n * and caching throughout the app.\n */\n\n'use client';\n\nimport React from 'react';\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\n\ninterface QueryProviderProps {\n  children: React.ReactNode;\n}\n\nexport const QueryProvider: React.FC<QueryProviderProps> = ({ children }) => {\n  const [queryClient] = React.useState(() => new QueryClient({\n    defaultOptions: {\n      queries: {\n        staleTime: 5 * 60 * 1000, // 5 minutes\n        refetchOnWindowFocus: false,\n        retry: 1,\n      },\n    },\n  }));\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      {children}\n    </QueryClientProvider>\n  );\n};"],"names":[],"mappings":"AAAA;;;;;CAKC;;;;AAID;AACA;AAAA;;;AAHA;;;AASO,MAAM,gBAA8C;QAAC,EAAE,QAAQ,EAAE;;IACtE,MAAM,CAAC,YAAY,GAAG,8TAAA,CAAA,UAAK,CAAC,QAAQ;kCAAC,IAAM,IAAI,yPAAA,CAAA,cAAW,CAAC;gBACzD,gBAAgB;oBACd,SAAS;wBACP,WAAW,IAAI,KAAK;wBACpB,sBAAsB;wBACtB,OAAO;oBACT;gBACF;YACF;;IAEA,qBACE,8VAAC,yRAAA,CAAA,sBAAmB;QAAC,QAAQ;kBAC1B;;;;;;AAGP;GAhBa;KAAA","debugId":null}}]
}